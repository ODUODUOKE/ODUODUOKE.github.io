<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Sm国密实现数字信封加密方式 | 哦哆哆克の博客</title><meta name="author" content="MUMU"><meta name="copyright" content="MUMU"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于国密（SM2，SM3，SM4）的数字信封加密加签实现   数字信封加密业务流程  SM2 import org.bouncycastle.asn1.gm.GMNamedCurves;import org.bouncycastle.asn1.x9.X9ECParameters;import org.bouncycastle.crypto.CipherParameters;import org."><meta property="og:type" content="article"><meta property="og:title" content="Sm国密实现数字信封加密方式"><meta property="og:url" content="https://blog.wo0ow.com/mblog/55103.html"><meta property="og:site_name" content="哦哆哆克の博客"><meta property="og:description" content="基于国密（SM2，SM3，SM4）的数字信封加密加签实现   数字信封加密业务流程  SM2 import org.bouncycastle.asn1.gm.GMNamedCurves;import org.bouncycastle.asn1.x9.X9ECParameters;import org.bouncycastle.crypto.CipherParameters;import org."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/124662384"><meta property="article:published_time" content="2024-10-22T10:59:30.000Z"><meta property="article:modified_time" content="2024-10-22T11:10:32.413Z"><meta property="article:author" content="MUMU"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/124662384"><link rel="shortcut icon" href="/custom/favicon/favicon-32x32.png"><link rel="canonical" href="https://blog.wo0ow.com/mblog/55103.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(()=>{var e={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},t=(window.btf={saveToLocal:e,getScript:(o,n={})=>new Promise((e,t)=>{const a=document.createElement("script");a.src=o,a.async=!0,Object.entries(n).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,n)=>new Promise((e,t)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var n;e.startsWith("pjax")||((n=o.globalFn||{})[e]=n[e]||{},a&&n[e][a])||(n[e][a||Object.keys(n[e]).length]=t,o.globalFn=n)}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")}),a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},o=(btf.activateDarkMode=t,btf.activateLightMode=a,e.get("theme")),t=("dark"===o?t():"light"===o&&a(),e.get("aside-status"));void 0!==t&&document.documentElement.classList.toggle("hide-aside","hide"===t);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/content.json",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:{limitDay:90,position:"top",messagePrev:"请注意，本文发布于",messageNext:"天前，内容可能已过时。"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"medium_zoom",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-right"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Sm国密实现数字信封加密方式",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!1,postUpdate:"2024-10-22 19:10:32"}</script><link rel="stylesheet" href="/css/custom/footer.css"><link rel="stylesheet" href="/css/custom/background.css"><link rel="stylesheet" href="/css/custom/mouse.css"><link rel="stylesheet" href="/css/custom/font.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss.xml" title="哦哆哆克の博客" type="application/atom+xml"></head><body><script>window.paceOptions={restartOnPushState:!1},btf.addGlobalFn("pjaxSend",()=>{Pace.restart()},"pace_restart")</script><link rel="stylesheet" href="/css/custom/pagejs/pace.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://avatars.githubusercontent.com/u/124662384" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">320</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-splotch"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">哦哆哆克の博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Sm国密实现数字信封加密方式</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-splotch"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Sm国密实现数字信封加密方式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-22T10:59:30.000Z" title="发表于 2024-10-22 18:59:30">2024-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-22T11:10:32.413Z" title="更新于 2024-10-22 19:10:32">2024-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">技术博客</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/helloworders/article/details/140467817">基于国密（SM2，SM3，SM4）的数字信封加密加签实现</a></p></blockquote><hr><p>数字信封加密业务流程</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/mblog/55103/Snipaste_2024-10-22_19-00-43.png"></p><p>SM2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import org.bouncycastle.asn1.gm.GMNamedCurves;</span><br><span class="line">import org.bouncycastle.asn1.x9.X9ECParameters;</span><br><span class="line">import org.bouncycastle.crypto.CipherParameters;</span><br><span class="line">import org.bouncycastle.crypto.engines.SM2Engine;</span><br><span class="line">import org.bouncycastle.crypto.params.ECDomainParameters;</span><br><span class="line">import org.bouncycastle.crypto.params.ECPrivateKeyParameters;</span><br><span class="line">import org.bouncycastle.crypto.params.ECPublicKeyParameters;</span><br><span class="line">import org.bouncycastle.crypto.params.ParametersWithRandom;</span><br><span class="line">import org.bouncycastle.crypto.signers.SM2Signer;</span><br><span class="line">import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;</span><br><span class="line">import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;</span><br><span class="line">import org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line">import org.bouncycastle.jce.spec.ECParameterSpec;</span><br><span class="line">import org.bouncycastle.jce.spec.ECPrivateKeySpec;</span><br><span class="line">import org.bouncycastle.math.ec.ECPoint;</span><br><span class="line">import org.bouncycastle.util.encoders.Hex;</span><br><span class="line"></span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.security.*;</span><br><span class="line">import java.security.spec.ECGenParameterSpec;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">public class SM2Utils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成 SM2 公私钥对</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * @throws NoSuchAlgorithmException</span><br><span class="line">     * @throws InvalidAlgorithmParameterException</span><br><span class="line">     */</span><br><span class="line">    public static KeyPair geneSM2KeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException &#123;</span><br><span class="line">        final ECGenParameterSpec sm2Spec = new ECGenParameterSpec(&quot;sm2p256v1&quot;);</span><br><span class="line">        // 获取一个椭圆曲线类型的密钥对生成器</span><br><span class="line">        final KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;, new BouncyCastleProvider());</span><br><span class="line">        // 产生随机数</span><br><span class="line">        SecureRandom secureRandom = new SecureRandom();</span><br><span class="line">        // 使用SM2参数初始化生成器</span><br><span class="line">        kpg.initialize(sm2Spec, secureRandom);</span><br><span class="line">        // 获取密钥对</span><br><span class="line">        KeyPair keyPair = kpg.generateKeyPair();</span><br><span class="line">        return keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生产hex秘钥对</span><br><span class="line">     */</span><br><span class="line">    public static void geneSM2HexKeyPair()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyPair keyPair = geneSM2KeyPair();</span><br><span class="line">            PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">            PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">            System.out.println(&quot;========  EC X Y keyPair    ========&quot;);</span><br><span class="line">            System.out.println(privateKey.toString());</span><br><span class="line">            System.out.println(publicKey.toString());</span><br><span class="line">            System.out.println(&quot;========  hex keyPair       ========&quot;);</span><br><span class="line">            System.out.println(&quot;hex priKey: &quot; + getPriKeyHexString(privateKey));</span><br><span class="line">            System.out.println(&quot;hex pubKey: &quot; + getPubKeyHexString(publicKey));</span><br><span class="line">            System.out.println(&quot;========  base64 keyPair    ========&quot;);</span><br><span class="line">            System.out.println(&quot;base64 priKey: &quot; + new String(Base64.getEncoder().encode(privateKey.getEncoded())));</span><br><span class="line">            System.out.println(&quot;base64 pubKey: &quot; + new String(Base64.getEncoder().encode(publicKey.getEncoded())));</span><br><span class="line">            System.out.println(&quot;========  generate finished ========&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取私钥（16进制字符串，头部不带00长度共64）</span><br><span class="line">     *</span><br><span class="line">     * @param privateKey 私钥PrivateKey型</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getPriKeyHexString(PrivateKey privateKey) &#123;</span><br><span class="line">        // OK</span><br><span class="line">//	        BCECPrivateKey s=(BCECPrivateKey)privateKey;</span><br><span class="line">//	        String priKeyHexString = Hex.toHexString(s.getD().toByteArray());</span><br><span class="line">//	        if(null!= priKeyHexString &amp;&amp; priKeyHexString.length()==66 &amp;&amp; &quot;00&quot;.equals(priKeyHexString.substring(0,2)))&#123;</span><br><span class="line">//	            return priKeyHexString.substring(2);</span><br><span class="line">//	        &#125;</span><br><span class="line">        // OK</span><br><span class="line">        BCECPrivateKey key = (BCECPrivateKey) privateKey;</span><br><span class="line">        BigInteger intPrivateKey = key.getD();</span><br><span class="line">        String priKeyHexString = intPrivateKey.toString(16);</span><br><span class="line">        return priKeyHexString;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取私钥 base64字符串</span><br><span class="line">     *</span><br><span class="line">     * @param privateKey 私钥PrivateKey型</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getPriKeyBase64String(PrivateKey privateKey) &#123;</span><br><span class="line">        return new String(Base64.getEncoder().encode(privateKey.getEncoded()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取公钥（16进制字符串，头部带04长度共130）</span><br><span class="line">     *</span><br><span class="line">     * @param publicKey 公钥PublicKey型</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getPubKeyHexString(PublicKey publicKey) &#123;</span><br><span class="line">        BCECPublicKey key = (BCECPublicKey) publicKey;</span><br><span class="line">        return Hex.toHexString(key.getQ().getEncoded(false));</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取公钥 base64字符串</span><br><span class="line">     *</span><br><span class="line">     * @param publicKey 公钥PublicKey型</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getPubKeyBase64String(PublicKey publicKey) &#123;</span><br><span class="line">        return new String(Base64.getEncoder().encode(publicKey.getEncoded()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SM2加密算法</span><br><span class="line">     *</span><br><span class="line">     * @param publicKey 公钥</span><br><span class="line">     * @param data      明文数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(String data, PublicKey publicKey) &#123;</span><br><span class="line">        return encrypt(data.getBytes(StandardCharsets.UTF_8), publicKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param data</span><br><span class="line">     * @param publicKey</span><br><span class="line">     * @return</span><br><span class="line">     * @author</span><br><span class="line">     * @version 1.0</span><br><span class="line">     * 2023年4月12日下午4:41:24</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(byte[] data, PublicKey publicKey) &#123;</span><br><span class="line">        BCECPublicKey key = (BCECPublicKey) publicKey;</span><br><span class="line">        return encrypt(data, Hex.toHexString(key.getQ().getEncoded(false)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param data</span><br><span class="line">     * @param pubKeyHexString</span><br><span class="line">     * @return</span><br><span class="line">     * @author</span><br><span class="line">     * @version 1.0</span><br><span class="line">     * 2023年4月12日下午4:46:37</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(String data, String pubKeyHexString) &#123;</span><br><span class="line">        return encrypt(data.getBytes(StandardCharsets.UTF_8), pubKeyHexString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SM2加密算法</span><br><span class="line">     *</span><br><span class="line">     * @param pubKeyHexString 公钥（16进制字符串）</span><br><span class="line">     * @param data            明文数据</span><br><span class="line">     * @return hex字符串</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(byte[] data, String pubKeyHexString) &#123;</span><br><span class="line">        // 获取一条SM2曲线参数</span><br><span class="line">        X9ECParameters sm2ECParameters = GMNamedCurves.getByName(&quot;sm2p256v1&quot;);</span><br><span class="line">        // 构造ECC算法参数，曲线方程、椭圆曲线G点、大整数N</span><br><span class="line">        ECDomainParameters domainParameters = new ECDomainParameters(sm2ECParameters.getCurve(), sm2ECParameters.getG(), sm2ECParameters.getN());</span><br><span class="line">        //提取公钥点</span><br><span class="line">        ECPoint pukPoint = sm2ECParameters.getCurve().decodePoint(Hex.decode(pubKeyHexString));</span><br><span class="line">        // 公钥前面的02或者03表示是压缩公钥，04表示未压缩公钥, 04的时候，可以去掉前面的04</span><br><span class="line">        ECPublicKeyParameters publicKeyParameters = new ECPublicKeyParameters(pukPoint, domainParameters);</span><br><span class="line"></span><br><span class="line">        SM2Engine sm2Engine = new SM2Engine(SM2Engine.Mode.C1C3C2);</span><br><span class="line">        // 设置sm2为加密模式</span><br><span class="line">        sm2Engine.init(true, new ParametersWithRandom(publicKeyParameters, new SecureRandom()));</span><br><span class="line"></span><br><span class="line">        byte[] arrayOfBytes = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            arrayOfBytes = sm2Engine.processBlock(data, 0, data.length);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;SM2加密时出现异常:&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        String cipherData = Hex.toHexString(arrayOfBytes);</span><br><span class="line">        return cipherData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String encrypt2(String dataStr, String pubKeyHexString) &#123;</span><br><span class="line">        byte[] data = dataStr.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        // 获取一条SM2曲线参数</span><br><span class="line">        X9ECParameters sm2ECParameters = GMNamedCurves.getByName(&quot;sm2p256v1&quot;);</span><br><span class="line">        // 构造ECC算法参数，曲线方程、椭圆曲线G点、大整数N</span><br><span class="line">        ECDomainParameters domainParameters = new ECDomainParameters(sm2ECParameters.getCurve(), sm2ECParameters.getG(), sm2ECParameters.getN());</span><br><span class="line">        //提取公钥点</span><br><span class="line">        ECPoint pukPoint = sm2ECParameters.getCurve().decodePoint(Hex.decode(pubKeyHexString));</span><br><span class="line">        // 公钥前面的02或者03表示是压缩公钥，04表示未压缩公钥, 04的时候，可以去掉前面的04</span><br><span class="line">        ECPublicKeyParameters publicKeyParameters = new ECPublicKeyParameters(pukPoint, domainParameters);</span><br><span class="line"></span><br><span class="line">        SM2Engine sm2Engine = new SM2Engine(SM2Engine.Mode.C1C3C2);</span><br><span class="line">        // 设置sm2为加密模式</span><br><span class="line">        sm2Engine.init(true, new ParametersWithRandom(publicKeyParameters, new SecureRandom()));</span><br><span class="line"></span><br><span class="line">        byte[] arrayOfBytes = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            arrayOfBytes = sm2Engine.processBlock(data, 0, data.length);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;SM2加密时出现异常:&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        String cipherData = Hex.toHexString(arrayOfBytes);</span><br><span class="line">        if (cipherData.startsWith(&quot;04&quot;)) &#123;</span><br><span class="line">            cipherData = cipherData.substring(2);</span><br><span class="line">        &#125;</span><br><span class="line">        return cipherData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SM2解密算法</span><br><span class="line">     * @param cipherData    hex格式密文</span><br><span class="line">     * @param privateKey    密钥PrivateKey型</span><br><span class="line">     * @return              明文</span><br><span class="line">     */</span><br><span class="line">    public static String decrypt(String cipherData, PrivateKey privateKey) &#123;</span><br><span class="line">        return decrypt(Hex.decode(cipherData), privateKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param cipherData</span><br><span class="line">     * @param privateKey</span><br><span class="line">     * @return</span><br><span class="line">     * @author</span><br><span class="line">     * @version 1.0</span><br><span class="line">     * 2023年4月12日下午4:46:50</span><br><span class="line">     */</span><br><span class="line">    public static String decrypt(byte[] cipherData, PrivateKey privateKey) &#123;</span><br><span class="line">        BCECPrivateKey key = (BCECPrivateKey) privateKey;</span><br><span class="line">        return decrypt(cipherData, Hex.toHexString(key.getD().toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param cipherData</span><br><span class="line">     * @param priKeyHexString</span><br><span class="line">     * @return</span><br><span class="line">     * @author</span><br><span class="line">     * @version 1.0</span><br><span class="line">     * 2023年4月12日下午4:46:53</span><br><span class="line">     */</span><br><span class="line">    public static String decrypt(String cipherData, String priKeyHexString) &#123;</span><br><span class="line">        // 使用BC库加解密时密文以04开头，传入的密文前面没有04则补上</span><br><span class="line">       // if (!cipherData.startsWith(&quot;04&quot;)) &#123;</span><br><span class="line">       //     cipherData = &quot;04&quot; + cipherData;</span><br><span class="line">       // &#125;</span><br><span class="line">        // cipherData = &quot;04&quot; + cipherData;</span><br><span class="line">        return decrypt(Hex.decode(cipherData), priKeyHexString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SM2解密算法</span><br><span class="line">     *</span><br><span class="line">     * @param cipherData      密文数据</span><br><span class="line">     * @param priKeyHexString 私钥（16进制字符串）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String decrypt(byte[] cipherData, String priKeyHexString) &#123;</span><br><span class="line">        //获取一条SM2曲线参数</span><br><span class="line">        X9ECParameters sm2ECParameters = GMNamedCurves.getByName(&quot;sm2p256v1&quot;);</span><br><span class="line">        //构造domain参数</span><br><span class="line">        ECDomainParameters domainParameters = new ECDomainParameters(sm2ECParameters.getCurve(), sm2ECParameters.getG(), sm2ECParameters.getN());</span><br><span class="line"></span><br><span class="line">        BigInteger privateKeyD = new BigInteger(priKeyHexString, 16);</span><br><span class="line">        ECPrivateKeyParameters privateKeyParameters = new ECPrivateKeyParameters(privateKeyD, domainParameters);</span><br><span class="line"></span><br><span class="line">        SM2Engine sm2Engine = new SM2Engine(SM2Engine.Mode.C1C3C2);</span><br><span class="line">        // 设置sm2为解密模式</span><br><span class="line">        sm2Engine.init(false, privateKeyParameters);</span><br><span class="line"></span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] arrayOfBytes = sm2Engine.processBlock(cipherData, 0, cipherData.length);</span><br><span class="line">            return new String(arrayOfBytes);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;SM2解密时出现异常:&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SM2解密算法 - 解密前端传的密文</span><br><span class="line">     * @param decryptData      密文数据</span><br><span class="line">     * @param priKeyHexString 私钥（16进制字符串）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String decrypt2(String decryptData, String priKeyHexString) &#123;</span><br><span class="line">        // 使用BC库加解密时密文以04开头，传入的密文前面没有04则补上</span><br><span class="line">        if (!decryptData.startsWith(&quot;04&quot;)) &#123;</span><br><span class="line">            decryptData = &quot;04&quot; + decryptData;</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] cipherData = Hex.decode(decryptData);</span><br><span class="line">        //获取一条SM2曲线参数</span><br><span class="line">        X9ECParameters sm2ECParameters = GMNamedCurves.getByName(&quot;sm2p256v1&quot;);</span><br><span class="line">        //构造domain参数</span><br><span class="line">        ECDomainParameters domainParameters = new ECDomainParameters(sm2ECParameters.getCurve(), sm2ECParameters.getG(), sm2ECParameters.getN());</span><br><span class="line"></span><br><span class="line">        BigInteger privateKeyD = new BigInteger(priKeyHexString, 16);</span><br><span class="line">        ECPrivateKeyParameters privateKeyParameters = new ECPrivateKeyParameters(privateKeyD, domainParameters);</span><br><span class="line"></span><br><span class="line">        SM2Engine sm2Engine = new SM2Engine(SM2Engine.Mode.C1C3C2);</span><br><span class="line">        // 设置sm2为解密模式</span><br><span class="line">        sm2Engine.init(false, privateKeyParameters);</span><br><span class="line"></span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] arrayOfBytes = sm2Engine.processBlock(cipherData, 0, cipherData.length);</span><br><span class="line">            //processBlock得到Base64格式，记得解码，不然前端传过来的密文无法解密</span><br><span class="line">            arrayOfBytes = Base64.getDecoder().decode(arrayOfBytes);</span><br><span class="line">            return new String(arrayOfBytes);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;SM2解密时出现异常:&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param data</span><br><span class="line">     * @param priKeyHexString hex私钥，长度64</span><br><span class="line">     * @return hex格式签名值</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String sign(String data, String priKeyHexString) throws Exception &#123;</span><br><span class="line">        return sign(data.getBytes(StandardCharsets.UTF_8), priKeyHexString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 签名</span><br><span class="line">     * @param data              原始数据，字节数组</span><br><span class="line">     * @param priKeyHexString   hex私钥，64长度</span><br><span class="line">     * @return                  Hex字符串</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String sign(byte[] data, String priKeyHexString) throws Exception &#123;</span><br><span class="line">        String signValue = null;</span><br><span class="line">        SM2Signer signer = new SM2Signer();</span><br><span class="line">        X9ECParameters sm2ECParameters = GMNamedCurves.getByName(&quot;sm2p256v1&quot;);</span><br><span class="line">        //构造domain参数</span><br><span class="line">        ECDomainParameters domainParameters = new ECDomainParameters(sm2ECParameters.getCurve(), sm2ECParameters.getG(), sm2ECParameters.getN());</span><br><span class="line">        CipherParameters param = new ParametersWithRandom(new ECPrivateKeyParameters(new BigInteger(priKeyHexString, 16), domainParameters));</span><br><span class="line">        signer.init(true, param);</span><br><span class="line">        signer.update(data, 0, data.length);</span><br><span class="line">        signValue = Hex.toHexString(signer.generateSignature());</span><br><span class="line">        return signValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验签</span><br><span class="line">     * @param data                  数据</span><br><span class="line">     * @param signValue             签名值(hex型)</span><br><span class="line">     * @param publicKeyHexString    hex130长度公钥</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean verify(String data, String signValue, String publicKeyHexString) throws Exception &#123;</span><br><span class="line">        return verify(data.getBytes(StandardCharsets.UTF_8), Hex.decode(signValue), publicKeyHexString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验签</span><br><span class="line">     * @param data                  原始数据字节数组</span><br><span class="line">     * @param sign                  字节数组()</span><br><span class="line">     * @param pKHexString    hex130长度公钥</span><br><span class="line">     * @return                      true or false</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static boolean verify(byte[] data, byte[] sign, String pKHexString) throws Exception &#123;</span><br><span class="line">        SM2Signer signer = new SM2Signer();</span><br><span class="line">        X9ECParameters sm2ECParameters = GMNamedCurves.getByName(&quot;sm2p256v1&quot;);</span><br><span class="line">        //构造domain参数</span><br><span class="line">        ECDomainParameters domainParameters = new ECDomainParameters(sm2ECParameters.getCurve(), sm2ECParameters.getG(), sm2ECParameters.getN());</span><br><span class="line">        if (pKHexString.length() == 128) &#123;</span><br><span class="line">            pKHexString = &quot;04&quot; + pKHexString;</span><br><span class="line">        &#125;</span><br><span class="line">        ECPoint ecPoint = sm2ECParameters.getCurve().decodePoint(Hex.decode(pKHexString));</span><br><span class="line">        CipherParameters param = new ECPublicKeyParameters(ecPoint, domainParameters);</span><br><span class="line">        signer.init(false, param);</span><br><span class="line">        signer.update(data, 0, data.length);</span><br><span class="line">        return signer.verifySignature(sign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 私钥生成公钥</span><br><span class="line">     * @param priKeyHexString 私钥Hex格式，必须64位</span><br><span class="line">     * @return 公钥Hex格式，04开头，130位</span><br><span class="line">     * @throws Exception 例如：</span><br><span class="line">     */</span><br><span class="line">    public static String getPubKeyByPriKey(String priKeyHexString) throws Exception &#123;</span><br><span class="line">        if (priKeyHexString == null || priKeyHexString.length() != 64) &#123;</span><br><span class="line">            System.err.println(&quot;priKey 必须是Hex 64位格式，例如：11d0a44d47449d48d614f753ded6b06af76033b9c3a2af2b8b2239374ccbce3a&quot;);</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String pubKeyHexString = null;</span><br><span class="line">        X9ECParameters sm2ECParameters = GMNamedCurves.getByName(&quot;sm2p256v1&quot;);</span><br><span class="line">        //构造domain参数</span><br><span class="line">        BigInteger privateKeyD = new BigInteger(priKeyHexString, 16);</span><br><span class="line"></span><br><span class="line">        ECParameterSpec ecParameterSpec = new ECParameterSpec(sm2ECParameters.getCurve(), sm2ECParameters.getG(), sm2ECParameters.getN());</span><br><span class="line">        ECPrivateKeySpec ecPrivateKeySpec = new ECPrivateKeySpec(privateKeyD, ecParameterSpec);</span><br><span class="line">        PrivateKey privateKey = null;</span><br><span class="line">        privateKey = KeyFactory.getInstance(&quot;EC&quot;, new BouncyCastleProvider()).generatePrivate(ecPrivateKeySpec);</span><br><span class="line"></span><br><span class="line">        // 临时解决办法</span><br><span class="line">        String pointString = privateKey.toString();</span><br><span class="line">//	        System.out.println(pointString);</span><br><span class="line">        String pointString_X = pointString.substring(pointString.indexOf(&quot;X: &quot;) + &quot;X: &quot;.length(), pointString.indexOf(&quot;Y: &quot;)).trim();</span><br><span class="line">        String pointString_Y = pointString.substring(pointString.indexOf(&quot;Y: &quot;) + &quot;Y: &quot;.length()).trim();</span><br><span class="line">//	        System.out.println(pointString_X);</span><br><span class="line">//	        System.out.println(pointString_Y);</span><br><span class="line"></span><br><span class="line">        pubKeyHexString = &quot;04&quot; + pointString_X + pointString_Y;</span><br><span class="line">        return pubKeyHexString;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       geneSM2HexKeyPair();</span><br><span class="line"></span><br><span class="line">        // String hexpriKey = &quot;ec0ebed3a633dd0c72d139b319205c412e6800cd2e68a537e9b275c6557671f1&quot;;</span><br><span class="line">        // String hexpubKey = &quot;04bc8503945bd80ac2fb9a1abf1bd3e0489bc0d37b9b102ba3244f2b5233b7458039060c05efc9467beb72c27b617a5c4c1463269bfea5af3a85dd242dbeb67955&quot;;</span><br><span class="line"></span><br><span class="line">        // String data = &quot;59817a86a44ab6ae820928b91799cf3f356be32047e6265309d6f1082ffe529e2b45a1ff1503791201104983d8fa92038dc28ce9fb42ff3f3fa8b6fe2dafd361fc4bc3b5c2068b88ab491fbd6e886afdd5dc80cc316852d31f6b6735f20674e65c7ea2dc7285dc13ad842e3517487eb94b0c30ce68e919436b9c74ce62d833e88a4bc0b37037c2f1ad3c5909071af933a74e43597fd89d0bb2dc14e73f577c3573abe0cd9b4a8f27f92a15dd9781a41fa83056ddc19549119ed10ab0b3f78770&quot;;</span><br><span class="line">        // String decryptData = decrypt(data, hexpriKey);</span><br><span class="line">        // System.out.println(&quot;明文：&quot; + decryptData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SM3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基于hutool工具</span><br><span class="line">SmUtil.sm3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-crypto&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bcpkix-jdk18on&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.78.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SM4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.withdrawal.utils.smUtil.sm4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line">import org.bouncycastle.util.encoders.Hex;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.spec.IvParameterSpec;</span><br><span class="line">import javax.crypto.spec.SecretKeySpec;</span><br><span class="line">import java.security.Security;</span><br><span class="line"></span><br><span class="line">public class sm4CbcUtilWithIv &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Security.addProvider(new BouncyCastleProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static byte[] encryptCbcPadding(byte[] key, byte[] iv, byte[] data) throws Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(&quot;SM4/CBC/PKCS5Padding&quot;, &quot;BC&quot;);</span><br><span class="line">        SecretKeySpec keySpec = new SecretKeySpec(key, &quot;SM4&quot;);</span><br><span class="line">        IvParameterSpec ivSpec = new IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);</span><br><span class="line">        return cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static byte[] decryptCbcPadding(byte[] key, byte[] iv, byte[] encryptedData) throws Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(&quot;SM4/CBC/PKCS5Padding&quot;, &quot;BC&quot;);</span><br><span class="line">        SecretKeySpec keySpec = new SecretKeySpec(key, &quot;SM4&quot;);</span><br><span class="line">        IvParameterSpec ivSpec = new IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);</span><br><span class="line">        return cipher.doFinal(encryptedData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // SM4密钥</span><br><span class="line">        // 16位字符密钥</span><br><span class="line">        String keyString = &quot;OFY2GP60WK9EHIVX&quot;;</span><br><span class="line">        // 将16位字符转换为字节数组</span><br><span class="line">        byte[] key = keyString.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">        // byte[] key = Hex.decode(&quot;0123456789ABCDEFFEDCBA9876543210&quot;);</span><br><span class="line">        // 初始化向量</span><br><span class="line">        // byte[] iv = Hex.decode(&quot;00000000000000000000000000000000&quot;);</span><br><span class="line">        // 16位字符密钥</span><br><span class="line">        String ivString = &quot;HTPJXVE5MSFQYAOL&quot;;</span><br><span class="line">        // 将16位字符转换为字节数组</span><br><span class="line">        byte[] iv = ivString.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">        // 需要加密的数据</span><br><span class="line">        String plainText = &quot;161213&quot;;</span><br><span class="line">        byte[] data = plainText.getBytes(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">        // 加密</span><br><span class="line">        byte[] encryptedData = encryptCbcPadding(key, iv, data);</span><br><span class="line">        // 输出加密后的数据</span><br><span class="line">        System.out.println(&quot;Encrypted data: &quot; + Hex.toHexString(encryptedData));</span><br><span class="line"></span><br><span class="line">        // 解密</span><br><span class="line">        String desStr = new String (decryptCbcPadding(key, iv, encryptedData), &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(&quot;Decrypted data: &quot; + desStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工具类 SignUtil</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.withdrawal.utils.smUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import cn.hutool.crypto.SmUtil;</span><br><span class="line">import com.withdrawal.utils.smUtil.sm2.SM2Utils;</span><br><span class="line">import org.bouncycastle.util.encoders.Hex;</span><br><span class="line"></span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.security.KeyPair;</span><br><span class="line">import java.security.PrivateKey;</span><br><span class="line">import java.security.PublicKey;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">import static com.withdrawal.utils.smUtil.sm2.SM2Utils.*;</span><br><span class="line">import static com.withdrawal.utils.smUtil.sm4.sm4CbcUtilWithIv.decryptCbcPadding;</span><br><span class="line">import static com.withdrawal.utils.smUtil.sm4.sm4CbcUtilWithIv.encryptCbcPadding;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @desc 基于sm国密工具类实现数字信封</span><br><span class="line"> * @author  </span><br><span class="line"> * @date 2024/10/22</span><br><span class="line"> * */</span><br><span class="line">public class SmSignUtil &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 生成服务端的sm2密钥对</span><br><span class="line">     * */</span><br><span class="line">    public static void initServer() throws Exception&#123;</span><br><span class="line">        KeyPair keyPair = geneSM2KeyPair();</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(&quot;========  hex keyPair       ========&quot;);</span><br><span class="line">        System.out.println(&quot;server hex priKey: &quot; + getPriKeyHexString(privateKey));</span><br><span class="line">        System.out.println(&quot;server hex pubKey: &quot; + getPubKeyHexString(publicKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 生成客户端的sm2密钥对</span><br><span class="line">     * */</span><br><span class="line">    public static void initClient() throws Exception&#123;</span><br><span class="line">        KeyPair keyPair = geneSM2KeyPair();</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(&quot;========  hex keyPair       ========&quot;);</span><br><span class="line">        System.out.println(&quot;client hex priKey: &quot; + getPriKeyHexString(privateKey));</span><br><span class="line">        System.out.println(&quot;client hex pubKey: &quot; + getPubKeyHexString(publicKey));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 生成服务端的sm4-iv</span><br><span class="line">     * */</span><br><span class="line">    public static void initSm4Iv()&#123;</span><br><span class="line">        String sm4Iv =  UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;).substring(0,16).toUpperCase();</span><br><span class="line">        System.out.println(&quot;========  sm4-Iv       ========&quot;);</span><br><span class="line">        System.out.println(&quot;sm4Iv:&quot;+sm4Iv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 生成服务端的sm4-iv</span><br><span class="line">     * */</span><br><span class="line">    public static void initSm3Key()&#123;</span><br><span class="line">        String sm3Key =  UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;).substring(0,32).toUpperCase();</span><br><span class="line">        System.out.println(&quot;========  sm3-Key      ========&quot;);</span><br><span class="line">        System.out.println(&quot;sm3Key:&quot;+sm3Key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 加密原始数据，获取sm4加密后字符串</span><br><span class="line">     * @author  </span><br><span class="line">     * @date 2024/10/22</span><br><span class="line">     * @param params 原始数据</span><br><span class="line">     * @param sm4Iv sm4的IV偏移向量</span><br><span class="line">     * @param sm4Key sm4的密钥</span><br><span class="line">     * @return ciphertext 加密密文</span><br><span class="line">     * */</span><br><span class="line">    public static String ciphertext(</span><br><span class="line">            String params,</span><br><span class="line">            String sm4Key,</span><br><span class="line">            String sm4Iv</span><br><span class="line">    ) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // sm4配置</span><br><span class="line">        byte[] key = sm4Key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        byte[] iv = sm4Iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        // 待加密数据</span><br><span class="line">        byte[] data = params.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        // 加密数据</span><br><span class="line">        return Hex.toHexString(encryptCbcPadding(key, iv, data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 通过sm3加密`ciphertext`得到摘要签名</span><br><span class="line">     * @remark sm4的密钥，在数字信封是动态变化，通过sm2解密后获取，每次传递的sm4的密钥随机。</span><br><span class="line">     * @author  </span><br><span class="line">     * @date 2024/10/22</span><br><span class="line">     * @param ciphertext 通过sm4加密后的数据</span><br><span class="line">     * @param sm3Key sm4的密钥</span><br><span class="line">     * */</span><br><span class="line">    public static String digest(</span><br><span class="line">            String ciphertext,</span><br><span class="line">            String sm3Key</span><br><span class="line">    )&#123;</span><br><span class="line">        // 生成基于sm3的摘要签名</span><br><span class="line">        return SmUtil.sm3( new String (ciphertext.getBytes(StandardCharsets.UTF_8),StandardCharsets.UTF_8) + sm3Key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 通过sm2加密sm4密钥，生成加密密文</span><br><span class="line">     * @remark sm4的密钥，在数字信封是动态变化，通过sm2解密后获取，每次传递的sm4的密钥随机。</span><br><span class="line">     * @author  </span><br><span class="line">     * @date 2024/10/22</span><br><span class="line">     * @param pubKeyHexString sm2的公钥</span><br><span class="line">     * @param sm4Key sm4的密钥</span><br><span class="line">     * */</span><br><span class="line">    public static String encryption_SM4Key(</span><br><span class="line">            String sm4Key,</span><br><span class="line">            String pubKeyHexString</span><br><span class="line">    ) throws Exception &#123;</span><br><span class="line">        return  SM2Utils.encrypt(sm4Key, pubKeyHexString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 通过sm2加密sm4密钥，生成sign签名</span><br><span class="line">     * @remark sm4的密钥，在数字信封是动态变化，通过sm2解密后获取，每次传递的sm4的密钥随机。</span><br><span class="line">     * @author  </span><br><span class="line">     * @date 2024/10/22</span><br><span class="line">     * @param priKeyHexString sm2的公钥</span><br><span class="line">     * @param digest sm3摘要</span><br><span class="line">     * */</span><br><span class="line">    public static String sign(</span><br><span class="line">            String digest,</span><br><span class="line">            String priKeyHexString</span><br><span class="line">    ) throws Exception &#123;</span><br><span class="line">        return  SM2Utils.sign(digest, priKeyHexString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 验签</span><br><span class="line">     * @param data                  数据</span><br><span class="line">     * @param signValue             签名值(hex型)</span><br><span class="line">     * @param publicKeyHexString    hex130长度公钥</span><br><span class="line">     */</span><br><span class="line">    public static boolean verify(</span><br><span class="line">            String data,</span><br><span class="line">            String signValue,</span><br><span class="line">            String publicKeyHexString</span><br><span class="line">    ) throws Exception &#123;</span><br><span class="line">       return SM2Utils.verify(data,signValue,publicKeyHexString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 通过sm2解密sm4密钥，获取sm4密钥，用于解密数据</span><br><span class="line">     * @author  </span><br><span class="line">     * @date 2024/10/22</span><br><span class="line">     * @param cipherData 加密密文</span><br><span class="line">     * @param priKeyHexString sm2的私钥</span><br><span class="line">     * */</span><br><span class="line">    public static String decryption_SM4Key(</span><br><span class="line">            String cipherData,</span><br><span class="line">            String priKeyHexString</span><br><span class="line">    )&#123;</span><br><span class="line">        return SM2Utils.decrypt(</span><br><span class="line">                cipherData,</span><br><span class="line">                priKeyHexString</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @desc 通过sm4解密加密数据</span><br><span class="line">     * @remark sm4Key密钥是通过sm2解密获取的，动态变化的sm4key密钥。</span><br><span class="line">     * @author  </span><br><span class="line">     * @date 2024/10/22</span><br><span class="line">     * */</span><br><span class="line">    public static String getParams(</span><br><span class="line">            String ciphertext,</span><br><span class="line">            String sm4Key,</span><br><span class="line">            String sm4Iv</span><br><span class="line">    ) throws Exception &#123;</span><br><span class="line">        // sm4配置</span><br><span class="line">        byte[] key = sm4Key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        byte[] iv = sm4Iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        // 待加密数据</span><br><span class="line">        byte[] data = Hex.decode(ciphertext);</span><br><span class="line"></span><br><span class="line">        // 已解密数据</span><br><span class="line">        return new String(decryptCbcPadding(key, iv, data),StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        /*生成密钥文件*/</span><br><span class="line">        // initServer();</span><br><span class="line">        // initClient();</span><br><span class="line">        // initSm4Iv();</span><br><span class="line">        // initSm3Key();</span><br><span class="line"></span><br><span class="line">        // ----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">        // 客户端向服务端请求</span><br><span class="line">        String  server_hex_priKey = &quot;e65601c82fecf1d8063f77be8024a4b1f8744164e0b3d17d7e1dbdc81a59ef60&quot;;</span><br><span class="line">        String  server_hex_pubKey = &quot;04eacb92a58039dd2d65385559d720cd8d20791f8f729ae6e5157d172b4c3becafe83e1a0ed28e05963f6ea4702dc047ceb9e1b0e48f6f0b39006692e8177488a5&quot;;</span><br><span class="line">        // 服务端向客户端响应</span><br><span class="line">        String  client_hex_priKey = &quot;cfb3c8655fbe7d01983ab3a91929006d8adc6c5104e87ba1c8391850fcf5c318&quot;;</span><br><span class="line">        String  client_hex_pubKey = &quot;0455f42c49e96594e03f0b5779560e953bb956962ab57e072f65bc02eebc44d385214d2b7c2f9a02466fa54d8d0a36d90c463e55a3e0b5669108c8aaaec562ff91&quot;;</span><br><span class="line">        String  sm4Iv = &quot;A8F602FDE7654BD0&quot;;</span><br><span class="line">        String sm3Key = &quot;EDCA0B82870C4F69A17FC83722899F14&quot;;</span><br><span class="line"></span><br><span class="line">        // 原始数据</span><br><span class="line">        String params = &quot;Hello World !&quot;;</span><br><span class="line">        System.out.println(&quot;params：&quot;+params);</span><br><span class="line"></span><br><span class="line">        // 随机</span><br><span class="line">        String sm4Key = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;).substring(0,16).toUpperCase();</span><br><span class="line">        System.out.println(&quot;sm4Key：&quot;+sm4Key);</span><br><span class="line"></span><br><span class="line">        // 加密密文</span><br><span class="line">        String ciphertext = ciphertext(params,sm4Key,sm4Iv);</span><br><span class="line">        System.out.println(&quot;ciphertext：&quot;+ciphertext);</span><br><span class="line"></span><br><span class="line">        // 通过sm3对加密密文进行获取摘要签名</span><br><span class="line">        String digest = digest(ciphertext,sm3Key);</span><br><span class="line">        System.out.println(&quot;digest：&quot;+digest);</span><br><span class="line"></span><br><span class="line">        // 对通过sm3摘要密文（sm4密钥）digest进行sm2签名（客户端的私钥）</span><br><span class="line">        String sign = sign(digest,client_hex_priKey);</span><br><span class="line">        System.out.println(&quot;sign：&quot;+sign);</span><br><span class="line"></span><br><span class="line">        // 对sm4密钥进行sm2加密(服务端的公钥)</span><br><span class="line">        String encryption_SM4Key =  encryption_SM4Key(sm4Key,server_hex_pubKey);</span><br><span class="line">        System.out.println(&quot;encryption_SM4Key：&quot;+encryption_SM4Key);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;------------------------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        // 验证签名（客户端的公钥）</span><br><span class="line">        boolean verify = verify(digest,sign,client_hex_pubKey);</span><br><span class="line">        System.out.println(&quot;verify：&quot;+verify);</span><br><span class="line"></span><br><span class="line">        // 解密sm4密钥（服务端的私钥）</span><br><span class="line">        String decryption_SM4Key = decryption_SM4Key(encryption_SM4Key,server_hex_priKey);</span><br><span class="line">        System.out.println(&quot;decryption_SM4Key：&quot;+decryption_SM4Key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 解密原始数据</span><br><span class="line">        String getParams = getParams(</span><br><span class="line">                ciphertext,</span><br><span class="line">                decryption_SM4Key,</span><br><span class="line">                sm4Iv</span><br><span class="line">        );</span><br><span class="line">        System.out.println(&quot;getParams:&quot;+getParams);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>yml中的sm国密配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 接口加密配置</span><br><span class="line">encry:</span><br><span class="line">  ## 国密加密配置</span><br><span class="line">  ## sm2 非对称加密</span><br><span class="line">  sm2:</span><br><span class="line">    # 服务端</span><br><span class="line">    server:</span><br><span class="line">      # 用途：客户端，公钥加密</span><br><span class="line">      hex_publicKey: </span><br><span class="line">      # 用途：服务端，私钥解密</span><br><span class="line">      hex_privateKey: </span><br><span class="line">    # 客户端</span><br><span class="line">    client:</span><br><span class="line">      # 用途：服务器，签名验证</span><br><span class="line">      hex_publicKey: </span><br><span class="line">      # 用途：客户端，私钥签名</span><br><span class="line">      hex_privateKey: </span><br><span class="line">  ## sm3 生成摘要，类似于md5（32位）&gt; 用于拼接待生成摘要的字符串后，提高安全性。</span><br><span class="line">  sm3:</span><br><span class="line">    key: EDCA0B82870C4F69A17FC83722899F14</span><br><span class="line">  ## sm4 对称加密</span><br><span class="line">  sm4:</span><br><span class="line">    iv: A8F602FDE7654BD0</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.wo0ow.com">MUMU</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.wo0ow.com/mblog/55103.html">https://blog.wo0ow.com/mblog/55103.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.wo0ow.com" target="_blank">哦哆哆克の博客</a>！</span></div></div><div class="tag_share"></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/custom/pay_qrcode/wx.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/custom/pay_qrcode/wx.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/custom/pay_qrcode/zfb.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/custom/pay_qrcode/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/mblog/57527.html" title="springBoot集成MybatisPlus3.0"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">springBoot集成MybatisPlus3.0</div></div><div class="info-2"><div class="info-item-1">【实用工具】利用MyBatisX插件自动生成代码 SpringBoot整合MyBatis-plus（超详细） java.lang.NoClassDefFoundError: org&#x2F;mybatis&#x2F;logging&#x2F;LoggerFactory</div></div></div></a><a class="pagination-related" href="/mblog/44542.html" title="win11无法开启热点"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">win11无法开启热点</div></div><div class="info-2"><div class="info-item-1">win11电脑开移动热点，但是手机连不上 根据博客指引，成功解决win11下开启热点，手机无法连接问题。 亲测：不需要开防火墙 以上操作完成后，应该是可以正常连接热点并上网的。</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://avatars.githubusercontent.com/u/124662384" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">MUMU</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">320</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ODUODUOKE"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/mblog/11025.html" title="Vmware中取消VmwareTools分辨率自适应">Vmware中取消VmwareTools分辨率自适应</a><time datetime="2025-01-17T16:29:24.000Z" title="发表于 2025-01-18 00:29:24">2025-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/mblog/28055.html" title="Linux下通过宝塔搭建勾股OA办公系统">Linux下通过宝塔搭建勾股OA办公系统</a><time datetime="2025-01-16T02:45:33.000Z" title="发表于 2025-01-16 10:45:33">2025-01-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/mblog/3933.html" title="IIS解决跨域问题">IIS解决跨域问题</a><time datetime="2025-01-14T03:16:29.000Z" title="发表于 2025-01-14 11:16:29">2025-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/mblog/26338.html" title="Nginx配置双主模式">Nginx配置双主模式</a><time datetime="2025-01-13T03:29:09.000Z" title="发表于 2025-01-13 11:29:09">2025-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/mblog/19394.html" title="WSL的Linux系统开启远程访问">WSL的Linux系统开启远程访问</a><time datetime="2025-01-13T01:20:32.000Z" title="发表于 2025-01-13 09:20:32">2025-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By MUMU</div><div class="framework-info"></div><div class="footer_custom_text">Copyright © 2018-2024 wo0ow.com All rights Reserved<br><img style="width:15px;height:15px;top:3px;position:relative" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/custom/icp/icp.png"> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32011402012106" target="_blank">苏公网安备32011402012106号</a> <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">渝ICP备18012869号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(()=>{const n=()=>{"object"==typeof pangu?pangu.autoSpacingPage():btf.getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})};var t=()=>{n()};btf.addGlobalFn("pjaxComplete",t,"pangu"),document.addEventListener("DOMContentLoaded",t)})()</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>