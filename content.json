[{"title":"一些大佬的网站","url":"/posts/5895.html","content":"\n\n## [Eurkon](https://blog.eurkon.com/)\n![](./一些大佬的网站/Snipaste_2023-05-09_12-07-47.jpg)\n","categories":["个人博客","分享收藏"],"tags":["大佬网站"]},{"title":"常用网址收藏","url":"/posts/57942.html","content":"\n## 在线图片压缩\n[docsmall](https://docsmall.com/image-compress)\n\n## 在线颜色选择器\n[photokit](https://photokit.com/colors/color-picker/?lang=zh)","categories":["个人博客","分享收藏"]},{"title":"常用md文档编辑示例","url":"/posts/1079.html","content":"\n## 常用符号\n - ⭐\n\n## 编辑技巧\n\n### 显示/隐藏\n> 1. 安装`hexo-renderer-markdown-it`创建\n> 2. 安装`markdown-it-expandable`插件,并在`_config.yml`配置文件`hexo-renderer-markdown-it`的plugins中启用\n>\n\n```\n\n+++ **点击展开/隐藏**\n\n点击展开内容示例\n\n+++\n\n```\n\n+++ **点击展开/隐藏**\n\n点击展开内容示例\n\n+++\n\n\n### 复杂表格实现\n\n+++ **点击展开/隐藏**\n\n\n\n> [Markdown表格——复杂表格](https://blog.csdn.net/dream_summer/article/details/110822636)\n\n#### 普通表格\n\n```\n<table>\n    <tr>\n        <td>行1列1</td> \n        <td>行1列2</td> \n        <td>行1列3</td> \n   </tr>\n    <tr>\n  \t\t<td>行2列1</td> \n        <td>行2列2</td> \n        <td>行2列3</td> \n    </tr>\n    <tr>\n        <td>行3列1</td> \n        <td>行3列2</td> \n        <td>行3列3</td> \n    </tr>\n</table>\n```\n\n<table>\n    <tr>\n        <td>行1列1</td> \n        <td>行1列2</td> \n        <td>行1列3</td> \n   </tr>\n    <tr>\n  \t\t<td>行2列1</td> \n        <td>行2列2</td> \n        <td>行2列3</td> \n    </tr>\n    <tr>\n        <td>行3列1</td> \n        <td>行3列2</td> \n        <td>行3列3</td> \n    </tr>\n</table>\n\n#### 合并单元格\n\n##### 合并行\n\n```\n<table>\n    <tr>\n        <td>行/列</td> \n        <td>列2</td> \n        <td>列3</td> \n   </tr>\n    <tr>\n  \t\t <td>行2列1</td> \n      \t <td colspan=\"2\">跨两列合并行</td>    \n    </tr>\n    <tr>\n        <td colspan=\"3\">跨三列合并行</td>    \n    </tr>\n</table>\n```\n\n<table>\n    <tr>\n        <td>行/列</td> \n        <td>列2</td> \n        <td>列3</td> \n   </tr>\n    <tr>\n  \t\t <td>行2列1</td> \n      \t <td colspan=\"2\">跨两列合并行</td>    \n    </tr>\n    <tr>\n        <td colspan=\"3\">跨三列合并行</td>    \n    </tr>\n</table>\n\n\n##### 合并列\n```\n<table>\n    <tr>\n        <td>行1列1</td> \n        <td>行1列2</td> \n        <td>行1列3</td> \n   </tr>\n    <tr>\n        <td rowspan=\"2\">合并两列</td>    \n  \t\t <td>行2列2</td> \n      \t <td>行2列3</td> \n    </tr>\n    <tr>\n        <td>行3列2</td> \n        <td>行3列3</td>    \n    </tr>\n</table>\n```\n\n<table>\n    <tr>\n        <td>行1列1</td> \n        <td>行1列2</td> \n        <td>行1列3</td> \n   </tr>\n    <tr>\n        <td rowspan=\"2\">合并两列</td>    \n  \t\t <td>行2列2</td> \n      \t <td>行2列3</td> \n    </tr>\n    <tr>\n        <td>行3列2</td> \n        <td>行3列3</td>    \n    </tr>\n</table>\n\n+++","categories":["个人博客","置顶文档"]},{"title":"活动日历","url":"/posts/20802.html","content":"\n{% calendar %}\n{\"monthLang\": \"cn\", \"dayLang\": \"cn\", \"title\": \"\", \"width\": \"800\"}\n{% endcalendar %}\n\n\n\n## [常用md文档编辑示例](/posts/1079.html)\n> TOP: 9500","categories":["个人博客","置顶文档"]},{"title":"常见开发英文单词","url":"/posts/51038.html","content":"\n## Qualifier\n  - 音标: /ˈkwɒlɪfaɪə(r)/\n  - 汉语: 括里fai而\n  - 释义: 限定符;限定词;修饰符;限定语;修饰词\n\n\nSmsService方法的实现类存在2个方法,使用Qualifier限定注入对象\n ```\n@Autowired\n@Qualifier(value = \"smsServiceImpl1\")\nprivate SmsService smsService;\n ```\n\n\n## private \n- 音标: [ˈpraɪvət] (美)\n- 汉语: 朴瑞v特\n- 释义: 私有的\n\n## implement\n- 音标: [ˈɪmpləmənt] (美)\n- 汉语: 因普门特\n- 释义: 实现,实现接口\n\n## synchronize\n- 音标: [ˈsɪŋkrəˌnaɪz] (美)\n- 汉语: 森括来日\n- 释义: 同步的,同步化的\n\n## volatile\n- 音标: [ˈvɒlətaɪl] (英)\n- 汉语: 喔里特哦\n- 释义: 不稳定的\n\n## transient\n- 音标: [ˈtrænziənt]\n- 汉语: try人嗯特\n- 作用: 阻⽌实例中那些⽤此关键字修饰的的变量序列化\n\n## EnableAutoConfiguration\n- 音标：\n- 汉语：因able哎吐come非哥哎行\n- 作用：自动装配注解springBoot的\n\n\n## Serializable\n- 音标：/ˈsɪərɪəlaɪzəbl/ 英\n- 汉语：sei瑞赖日博\n- 作用： 可串行化\n\n## Repeatable Read\n- 音标：/rɪˈpiːtəbl riːd/ 美\n- 汉语：瑞批特博 瑞得\n- 作用：可重复读\n\n## Read Uncommitted \n- 音标\n- 汉语：瑞得 昂com米特得 \n- 作用：读未提交\n\n## ThreadLocal\n- 音标：\n- 汉语：斯rui得-漏扣\n- 作用：本地线程\n\n\n## MyISAM\n- 音标：maiˈzæm\n- 汉语：卖惹俺\n- 释义：MySQL数据库`MyISAM`引擎\n- 链接: [MyISAM的正确读法](https://blog.csdn.net/Anenan/article/details/116937780)","categories":["个人博客","英语学习"]},{"title":"百词斩-记单词0424","url":"/posts/30626.html","content":"\n![](Snipaste_2023-04-24_10-33-39.jpg)\n\n---\n\n> 数据来源：百词斩APP\n\n## steak\n\n音标：/steik/\n\n助记词：*斯特课*\n\n复数形式：**steaks**\n\n名词（n）： 牛排；鱼块；\n\n图文\n```\n#叉子上叉了两块美味的牛排。\nThere are tow pieces of delicious `steak` on the fork. \n```\n\n\n---\n\n## cough\n\n音标：/kɔːf/\n\n助记词：*卡夫*\n\n动词（v）：咳嗽\n\n名词（n）：咳嗽\n\n复数：coughs\n\n第三人称单数：coughs\n\n现在分词：coughing\n\n过去式：coughed\n\n过去分词：coughed\n\n\n```\n#他生病时咳嗽的厉害\nHe coughed badly when he was ill .\n```\n\n---\n\n## pressure\n\n音标：/ˈpreʃər/\n\n助记词：*普睿西儿*\n\n名词（n）：压力\n\n及物动词（vt）：对...施加压力\n\n复数：pressures\n\n第三人称单数： pressures\n\n现在分词：pressuring\n\n过去式：pressured\n\n过去分词： pressured\n\n\n```\n#这个大梨的压力实在是难以承受。\nThe pressure of ths giant pear is unbearable.\n```\n---\n\n## hinder\n\n音标：/ˈhɪndər/\n\n助记词：*哼der*\n\n动词（v）：阻碍、妨碍\n\n第三人称单数：hinders\n\n现在分词： hindering\n\n过去式：hindered\n\n过去分词：hindered\n\n\n```\n#这个障碍物实在是阻碍我前进\nThe obstacle really `hinders` my forward progress.\n```\n\n---\n\n## raw\n\n音标：/rɔː/\n\n助记词：*若*\n\n形容词（adj）：生的、为煮过的；（因皮肤开裂）疼痛的\n\n比较级：rawer\n\n最高级：rawest\n\n名词：rawness\n\n副词：rawly\n\n\n```\n#木板上的牛肉是生的。\nThe beef on the wooden board is `raw`.\n```\n---\n## luggage\n音标：/ˈlʌɡɪdʒ/\n\n助记词：*拉给及*\n\n名词（n）：行李\n\n\n```\n#你可以从这些行李箱中选择任意的尺寸和颜色的一个作为你的行李箱。\nYou can choose your `luggage` of any size and color from these ones.\n```\n---\n\n## extent\n音标：/ɪkˈstent/\n\n助记词：*一可斯坦特*\n\n名词（n）：范围；长度；程度；\n\n\n```\n#围栏以内都是我的财产范围。\nThe `extent` of my property is marked by a fence.\n```\n---\n\n## faulty\n音标：/ˈfɔːlti/\n\n助记词：*佛提*\n\n比较级：faultier\n\n最高级：faultiest\n\n名词：faultiness\n\n副词：faultily\n\n\n```\n#快跑！这个烤面包机出故障了，它随时都可能毁了你的面包！\nRun! This toaster is `faulty` and might kill your toast at \nany time !\n```\n\n---\n## ground\n音标：/ɡraʊnd/\n\n助记词：*过让得*\n\n名词（n）：地面\n\n复数：grounds\n\n第三人称单数：grounds\n\n现在分词：grounding\n\n过去式：grounded\n\n过去分词：grounded\n\n\n```\nThe man is lying on the `ground`.\n```\n---\n\n## encounter\n\n音标：/ɪnˈkaʊntər/\n\n助记词：*因康特儿*\n\n及物动词（vt）：邂逅，偶遇\n\n名词（n）：偶然碰见，遭遇\n\n复数：encounters\n\n第三人称单数：encounters\n\n现在分词：encountering\n\n过去式：encountered\n\n过去分词:encountered\n\n\n```\n#他在街上遇到了老朋友。\nHe `encountered` his old friend on the street.\n```\n---\n## reap\n音标：/riːp/\n\n助记词：*瑞普*\n\n动词（v）：收割；获得；收获；\n\n第三人称单数：reaps\n\n现在分词：reaping \n\n过去式：reaped\n\n过去分词：reaped\n\n\n```\n#庄稼已经完全成熟，是时候收割了。\nThe crops are fully grown,and it`s time to `reap` them.\n```\n---\n\n## nutrient\n音标：/ˈnuːtriənt/\n\n助记词：*牛醉ing嗯特*\n\n名词（n）：营养物\n\n形容词（adj）：营养的\n\n复数：nutrients\n\n\n```\n#苹果含有许多有益身体健康的营养成分。\nApples contain many healthy `nutrients` for the body.\n```\n\n---\n ## fair \n 音标：/fer/\n\n 助记词：*菲尔*\n\n 形容词（adj）：合理的，公平的；相当的，尚好的\n\n 名词（n）：集市，交易会\n\n 复数： fairs\n\n 第三人称单数：fairs\n\n 现在分词：fairing\n\n 过去式：faired\n\n 过去分词：faired\n\n 比较级：fairer\n\n 最高级：fairest\n\n \n ```\n #相比较左边的饮料，右边的饮料售价更合理。\n Compared to that on the left,the drink on the right is being sold at a `fair` price.\n ```\n\n ---\n\n ## bore\n\n 音标：/bɔːr/\n\n 助记词：*波儿*\n\n 动词（v）：使厌烦\n\n 复数：bores\n\n 第三人称单数：bores\n\n 现在分词：boring\n\n 过去式：bored\n\n 过去分词：bored\n\n \n ```\n #这个男人冗长的讲话让同事们都厌烦的想睡觉了。\n The man`s endless talking has `bored` his colleagues to sleep.\n ```\n ---\n ## tragedy\n 音标：/ˈtrædʒədi/\n \n 助记词：*tra极地*\n\n 名词（n）：悲剧\n\n 复数：targedies\n\n \n ```\n #这场车祸对于这个男人来说是场灾难。\n The car accident was `tragedy` for the man.\n ```\n---\n\n ## abundance\n 音标：/əˈbʌndəns/\n\n 助记词：*额班等斯* （a+bun+dan+ce）\n\n 名词（n）：大量；丰富\n\n \n ```\n #这只可爱的小动物有满满一堆的食物。\n This cute animal has an `abundance` of foood.\n ```\n\n ---\n## emphasis\n音标：/ˈemfəsɪs/\n\n助记词：*嗯fo塞斯*（em+pha+sis）\n\n名词（n）：重点；强调；重要性；\n\n复数：emphases\n\n\n```\n#标亮单词，以示重点。\nThe word has been highlighted to provide `emphasis`.\n```\n---\n## wage\n音标：/weɪdʒ/\n\n助记词：*为己*  （wa+ge）\n\n名词（n）：工资，薪水\n\n及物动词（vt）：开展，进行（战争、运动）\n\n复数：wages\n\n第三人称单数：wages\n\n现在分词：waging\n\n过去式：waged\n\n过去分词：waged\n\n\n```\n#这个工人拿到工资的时候很开心。\nThe worker was so happy when she got her `wages`.\n```\n\n---\n\n## conservative \n音标：/kənˈsɜːrvətɪv/\n\n助记词：*康色五提悟* （con+ser+va+tive）\n\n形容词（adj）：保守的；保守估计的；保守党的\n\n名词（n）：保守者；保守党党员\n\n复数：conservatives\n\n\n```\n#这个人的态度如此保守，就连情侣牵手他都看不惯。\nThe man has such a `conservative` attitude; he even despiese the couple holding hands.\n```\n---\n##  intermediate\n音标：/ˌɪntərˈmiːdiət/\n\n助记词：*因特儿米地儿特* （inter+me+di+ate）\n\n形容词（adj）：中间的\n\n名词（n）；媒介\n\n动词（v）：调节，干涉\n\n复数：intermediates\n\n第三人称单数：intermediates\n\n现在分词：intermediating\n\n过去式：intermediated\n\n过去分词：intermediated\n\n\n```\n#中间物品的尺寸适中。\nThe toy in the middle is of `intermediate` size.\n```\n\n---\n## pursue \n音标：/pərˈsuː/\n\n助记词：*per树* （pur+sue）\n\n动词（v）：追赶；进行，从事\n\n第三人称单数：pursues\n\n现在分词：pursuing\n\n过去式：pursued\n\n过去分词：pursued\n\n\n```\n#警察正在追赶那两个小偷，他们偷了一个女人的钱包。\nThe police were `pursuing` the two thieves who had stolen a woman`s purse.\n```\n\n---\n## urgency\n音标：/ˈɜːrdʒənsi/\n\n助记词：*儿金塞* （ur+gen+cy）\n\n名词（n）：紧急；紧急的事\n\n\n```\n#她急匆匆的跑着，生怕开会迟到。\nShe ran with a sence of `urgency`,afraid of being late for the meeting .\n```\n---\n## extinction \n音标：/ɪkˈstɪŋkʃn/\n\n助记词：*一可斯滕行* （ex+tin+ction）\n\n名词（n）：灭绝\n\n\n```\n#这类动物的灭绝发生在大约6600万年前。\nThe `extinction` of this animal occourred around 66 million years ago.\n```\n---\n## furniture\n音标：/ˈfɜːrnɪtʃər/\n\n助记词：*fer尼切儿* （fur+ni+ture）\n\n名词（n）：家具；装置；设备\n\n\n```\n#他的所有的家具都是成套的。\nAll of his `furniture` came as a set.\n```\n---\n## curb\n音标：/kɜːrb/\n\n助记词：*可布* （cur+b）\n\n动词（v）：勒住；印制；控制；约束\n名词（n）：路缘；控制；约束\n\n复数：curbs\n\n第三人称单数：curbs\n\n现在分词：curbing\n\n过去式：curbed\n\n过去分词：curbed\n\n\n```\n#在你的马掉下悬崖前，快勒住它！\n`Curb` your horse now before it runs off ths cliff!\n```\n---\n## analyst\n音标：/ˈænəlɪst/\n\n助记词：*安no来斯特* （an+a+lyst）\n\n名词（n）：分析员\n\n复数：analysts\n\n\n```\n#分析员正在解说股市走向。\nThs `analyst` is explaining the trend of ths stock market.\n```\n---\n## loosen\n音标：/ˈluːsn/\n\n助记词：*路森*（loo+sen）\n\n动词（v）：松开；松弛\n\n第三人称单数：loosens\n\n现在分词：loosening\n\n过去式：loosened\n\n过去分词：loosened\n\n\n```\n#在办公室工作一天后，我松了松领带。\nI `loosen` my tie after a long day in the office.\n```\n\n---\n## appear\n音标：/əˈpɪr/\n\n助记词：*额皮儿* （app+ear）\n\n不及物动词（vi）：出现，露面\n\n第三人称单数：appears\n\n现在分词：appearing\n\n过去式：appeared\n\n过去分词：appeared\n\n\n```\n#我实在太激动了！我的偶像马上就要出现在舞台上了。\nI`m so excited! My idol is about to `appear` on stage.\n```\n\n---\n\n## mortgage\n\n音标：/ˈmɔːrɡɪdʒ/\n\n助记词：*莫儿给及* （mort+gage）\n\n名词（n）：抵押贷款\n\n动词（v）：抵押\n\n复数：mortgages\n\n第三人称单数：mortgages\n\n现在分词：mortgaging\n\n过去式：mortgaged\n\n过去分词：mortgaged\n\n\n```\n#他办理过抵押贷款，这意味着他是借钱买的房子。\nHe took out a `mortgage`,meaning he borrowed money to buy his home.\n```\n\n---\n\n## reply\n音标：/rɪˈplaɪ/\n\n助记词：*瑞普来* （re+ply）\n\n动词（v）：答复\n\n名词（n）：答复\n\n复数：replies\n\n第三人称单数：replies\n\n现在分词：replying\n\n过去式：replied\n\n过去分词：replied\n\n\n```\n#我给她发了好多条消息，她却只回复了一个字。\nI sent her many messages,but she `replied` with only one word.\n```\n---\n\n## forgetful\n音标：/fərˈɡetfl/\n\n助记词：*非儿给特佛* （for+get+ful）\n\n形容词（adj）：健忘的；使遗忘...的\n\n\n```\n#这位老人很健忘，他不记得自己在干什么。\nThe old man is so `forgetful` that he can`t remember what he`s doing.\n```\n\n---\n\n## theater\n\n音标：/ˈθiːətər/\n\n助记词：*非额切儿* （the+a+ter）\n\n复数：theaters\n\n\n```\n#表演结束之后，戏院很快就空了。\nThe `theater` quickly emptied when the performance ended.\n```\n\n---\n## foremost\n音标：/ˈfɔːrmoʊst/\n\n助记词：*佛儿眸斯特* （for+e+most）\n\n形容词（adj）：首要的\n\n副词（adv）：首先\n\n\n```\n#特斯拉被视为他那一代人里最棒的发明家之一。\nTesla is regarded as one of the `foremost` inventors of his generation.\n```\n---\n## correspond\n\n音标：/ˌkɔːrəˈspɑːnd/\n\n助记词：*扩儿斯棒的* （corr+es+pond）\n\n不及物动词（vi）：通信；相似\n\n第三人称单数：corresponds\n\n现在分词：corresponding\n\n过去式：corresponded\n\n过去分词：corresponded\n\n\n```\n#现如今，人们有许多不同的方式进行通信。\nNowadays, People `correspond` with each other in many different ways.\n```\n\n---\n\n## severe\n\n音标：/sɪˈvɪr/\n\n助记词：*赛V儿* （se+ve+re）\n\n形容词（adj）：极为恶劣的；严重的；严厉的；剧烈的\n\n比较级：severer\n\n最高级：severest\n\n\n```\n#在如此恶劣的天气条件下，人们走的很艰难。\nIt`s hard for people to wald in such `severe` weather conditions.\n```\n\n---\n## bug\n音标：/bʌɡ/\n\n助记词：*巴格*\n\n名词（n）：错入，故障\n\n及物动词（vt）：使厌烦\n\n复数：bugs\n\n第三人称单数：bugs\n\n现在分词：bugging\n\n过去式：bugged\n\n过去分词：bugged\n\n\n```\n#程序员正在努力修复软件中的故障。\nThe programmer is trying to fix the `bug` in the software.\n```\n\n---\n## consensus\n\n音标：/kənˈsensəs/\n\n助记词：*康森色斯* （con+sen+sus）\n\n名词（n）：一致同意\n\n\n```\n#大家就聚餐吃什么问题达成了一致。\nThey reached a `consensus` about what to eat for dinner.\n```\n\n\n\n\n\n\n\n","categories":["个人博客","英语学习"],"tags":["英语学习"]},{"title":"Docker下安装Mysql","url":"/posts/11638.html","content":"\n> 参考博客：[Docker下安装Mysql-01](http://www.taodudu.cc/news/show-1347332.html)\n>\n> 参考博客：[Docker下安装Mysql-02](https://blog.csdn.net/weixin_44037416/article/details/117956869)\n>\n> 参考博客：[Docker下安装Mysql-03](https://blog.csdn.net/qq_25288617/article/details/125423194)\n## 通过Docker拉取Mysql镜像\n```\ndocker pull mysql:5.6\n```\n\n![](./Docker下安装Mysql/Snipaste_2023-06-13_20-00-25.png)\n\n\n## 运行Docker下Mysql容器\n```\ndocker run \\\n-d \\\n-p 3306:3306 \\\n--restart=always \\\n--privileged=true \\\n-v /home/docker/mysql/logs:/var/log/mysql \\\n-v /home/docker/mysql/conf:/etc/mysql/conf.d \\\n-v /home/docker/mysql/data:/var/lib/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n--name mysql mysql:5.6 \\\n--character-set-server=utf8mb4 \\\n--collation-server=utf8mb4_general_ci\n```\n\n- -d 表示后台运行\n- -p 表示容器内部端口和服务器端口映射关联\n- --restart=always 重启docker时，自动启动相关容器\n- --privileged=true 设置root用户权限\n- -v 映射docker容器的目录到服务器目录\n\n## 配置Mysql远程访问\n\n### 进入Docker-Mysql容器\n```\ndocker exec -it 容器名称(mysql) bash\n```\n\n### 设置账号访问权限\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n```\n\n刷新权限\n```\nflush privileges;\n```\n\n## 配置my.cnf文件\n在`/home/docker/mysql/conf/`目录下创建文件`my.cnf`\n```\ntouch my.cnf\n```\n\nmy.cnf内容参考\n```\n# Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n\n#\n# The MySQL  Server configuration file.\n#\n# For explanations see\n# http://dev.mysql.com/doc/mysql/en/server-system-variables.html\n\n[mysqld]\npid-file        = /var/run/mysqld/mysqld.pid\nsocket          = /var/run/mysqld/mysqld.sock\ndatadir         = /var/lib/mysql\nsecure-file-priv= NULL\ndefault-time-zone = '+8:00'\n\n#最大链接数\nmax_connections=1024\n\n#是否对sql语句大小写敏感，1表示不敏感\nlower_case_table_names=1\nlog_bin_trust_function_creators=1\n#启用log-bin\nlog-bin=mysql-bin\n\n#设置日志格式\nbinlog_format=mixed\n\n#设置binlog清理时间\nexpire_logs_days=7\n\n# 数据表默认时区\ndefault-time-zone='+08:00'\n\n# Custom config should go here\n!includedir /etc/mysql/conf.d/\n```\n\n重启docker容器\n```\ndocker restart 容器id\n```","categories":["技术博客","Docker"],"tags":["Docker","Mysql","Linux"]},{"title":"Docker构建Tomcat和war包镜像","url":"/posts/42172.html","content":"> 参考博客：[docker制作tomcat镜像并部署war包](https://blog.csdn.net/qq_42216791/article/details/125784203  )\n>\n> 参考博客：[docker快速入门](https://blog.csdn.net/chongcilingjian/article/details/119640314)\n>\n> 参考博客：[Dockerfile常用指令](https://blog.csdn.net/xgp666/article/details/107228785)\n  \n\n## 前期准备\n1. 下载JDK的包\n   例如：`jdk-8u151-linux-x64.tar.gz`\n2. 下载Tomcat-xxx.tar.gz的包\n   例如：`apache-tomcat-8.5.54.tar.gz`\n3. 准备部署项目*.war包\n   例如：demo_war.war\n4. 将以上文件均放置同一目录下,例如：`/root/mumu`下\n\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_10-49-36.png)\n\n## 编写`DockerFile`文件\n```\n#FROM指令：用来指定基础镜像\nFROM centos\n#MAINTAINER指令：设置创建镜像的作者的标识\nMAINTAINER mumu\n#ADD指令：拷贝文件或目录到镜像，如果是URL或压缩包会自动下载或自动解压\nADD jdk-8u151-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-8.5.54.tar.gz /usr/local/\n#RUN指令：构建镜像时运行的shell命令\nRUN chmod a+x /usr/local\n#ENV指令：设置容器环境变量\nENV MYPATH /usr/local\n#WORKDIR指令：为RUN、CMD、ENTRYPOINT、 COPY和ADD设置工作目录，意思为切换目录\nWORKDIR $MYPATH\nENV JAVA_HOME $MYPATH/jdk1.8.0_151\nENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME $MYPATH/apache-tomcat-8.5.54\nENV CATALINA_BASH $MYPATH/apache-tomcat-8.5.54\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\n# 把war包放到webapps目录下\nADD demo_war.war $CATALINA_HOME/webapps\n#EXPOSE指令：声明容器的服务端口\nEXPOSE 8080\nWORKDIR $CATALINA_HOME/bin\nRUN chmod a+x $CATALINA_HOME/bin/startup.sh\n#VOLUME指令：指定容器挂载点到宿主机自动生成的目录或其他容器\nVOLUME [\"$CATALINA_HOME/logs/\",\"$CATALINA_HOME/webapps\"]\n# 注意：tail -F ,这里如果用小写的f，启动容器的时候打印完日志后会退出，用大写-F容器才会停留\nCMD $CATALINA_HOME/bin/startup.sh && tail -F $CATALINA_HOME/logs/catalina.out\n```\n\n## 制作镜像\n\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_11-02-22.png)\n\n### 打包镜像\n> 备注：若由于网络环境问题下载镜像失败，可配置阿里云镜像容器加速工具([Docker配置aliyun阿里云镜像加速](/posts/25181.html))\n\n```\ndocker build -f /root/mumu/Dockerfile -t docker_tomcat_war_demo:3.0 /root/mumu\n```\n\n注意：镜像名需要全小写，大写报错（[repository name must be lowercase](https://blog.csdn.net/wangchaoqi1985/article/details/108959816)）\n\n### 查看镜像\n```\ndocker images;\n```\n\n### 运行镜像\n```\ndocker run -itd -p 8080:8080 docker_tomcat_war_demo:3.0\n```\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_11-03-49.png)\n\n### 查看容器日志\n```\ndocker logs xxx(容器id)\n```\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_11-04-38.png)\n\n## 转存/还原镜像\n### 转存\n```\ndocker save -o mytomcat_image.docker docker_tomcat_war_demo:3.0\n```\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_11-07-31.png)\n\n通过`scp`传输至其他服务器\n```\nscp mytomcat_image.docker root@192.168.136.132:/root/\n```\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_11-12-47.png)\n\n### 还原\n```\ndocker load -i  mytomcat_image.docker\n```\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_11-13-45.png)\n\n运行镜像\n![](./Docker构建Tomcat和war包镜像/Snipaste_2023-06-17_11-16-14.png)\n\n\n## 附录\n> 鼠标右键单击另存链接下载\n> \n[demo_war.zip](./Docker%E6%9E%84%E5%BB%BATomcat%E5%92%8Cwar%E5%8C%85%E9%95%9C%E5%83%8F/demo_war.zip)","categories":["技术博客","Docker"],"tags":["Docker","Images"]},{"title":"Docker配置aliyun阿里云镜像加速","url":"/posts/25181.html","content":"\n## 前提\n未配置阿里云加速前，通过docker的`build`命令构建镜像失败!\n![](./Docker配置aliyun阿里云镜像加速/Snipaste_2023-06-17_09-25-53.png)\n\n## 配置aliyun的docker加速\n阿里云搜索`容器镜像服务`点击`镜像工具/镜像加速器`\n![](./Docker配置aliyun阿里云镜像加速/Snipaste_2023-06-17_09-29-39.png)\n\n配置命令\n\n> 已存在 `/etc/docker/daemon.json` 可跳过\n```\nmkdir -p /etc/docker\n```\n\n配置加速地址\n```\ntee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://xxx.aliyuncs.com\"]\n}\nEOF\n```\n\n重启docker服务\n```\nsystemctl daemon-reload\nsystemctl restart docker\n```\n## 验证加速器\n![](./Docker配置aliyun阿里云镜像加速/Snipaste_2023-06-17_09-36-38.png)","categories":["技术博客","Docker"],"tags":["aliyun","镜像加速器","docker"]},{"title":"GitHub新增SSH令牌","url":"/posts/60922.html","content":"\n```\nssh-keygen -t ed25519 -C \"oddk@github.com\" -f C:\\Users\\14751\\.ssh\\github_id_rsa\n```\n\n> -f 表示生成文件的位置\n\n---\n\n注意：如果你使用的是不支持 Ed25519 算法的旧系统，请使用以下命令：\n```\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```","categories":["技术博客","GIT"]},{"title":"git 拉取远端所有分支","url":"/posts/32933.html","content":"\n\n[CSDN博客原文参考地址](https://blog.csdn.net/weixin_42253753/article/details/116917450)\n\n## 关键命令代码\n> git branch -r | grep -v '\\->' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done\n> git fetch --all\n> git pull --all\n\n___\n\n## 操作步骤截图\n\n### 通过 git bash 窗口输入git clone 命令\n\n![](1.jpg \"通过 git bash 窗口输入git clone 命令\")\n\n### 克隆项目到本地\n\n![](2.jpg \"克隆项目到本地\")\n\n### 进入项目 jmt_lp 文件夹目录下\n\n![](3.jpg \"进入项目 jmt_lp 文件夹目录下\")\n\n### 执行以下命令\n\n`git branch -r | grep -v '\\->' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done\ngit fetch --all\ngit pull --all\n`\n  \n## 下载所有分支代码  \n\n![](4.jpg \"下载所有分支代码\")\n\n## 打开Idea查看项目所有分支代码下载结果\n\n![](5.jpg \"打开Idea查看项目所有分支代码下载结果\")\n","categories":["技术博客","GIT"],"tags":["GIT"]},{"title":"Git配置多个账号","url":"/posts/52878.html","content":"\n\n> 参考博客: [配置多个Git账号（windows 10）](https://blog.csdn.net/q13554515812/article/details/83506172)\n>\n> 参考博客：[git 设置多账号](https://juejin.cn/post/7058642341644484621)\n\n\n## 移除全局配置账户信息\n> 如果未设置全局账户信息则忽略\n\n移除全局用户名配置\n```\ngit config --global --unset user.name\n```\n\n移除全局邮箱配置\n```\ngit config --global --unset user.email\n```\n\n移除全局密码\n```\ngit config --global --unset user.password\n```\n\n### 查看全局配置信息\n```\n#用户名\ngit config --global user.name\n\n#邮箱\ngit config --global user.email\n\n#密码\ngit config --global user.password\n```\n\n## 创建多git账户配置文件\n在目录`.ssh`下创建`config`文件\n\n文件内容示例\n```\n##模板示例##\n#Host 主机别名\n#HostName 服务器真实地址\n#User 用户名\n#PreferredAuthentications 认证方式\n#IdentityFile 私钥文件路径\n\n##gitee##\nHost gitee.com #gitee\nHostName gitee.com #gitee\nUser your_name\nPreferredAuthentications publickey #默认\nIdentityFile C:/Users/14751/.ssh/id_ed25519 #指定pub文件路径\n```\n\n### 打开`git-bash`窗口测试配置是否有效\n\n```\nssh -T git@gitee.com\n```\n\n## 不同`git`仓库项目单独配置用户名和邮箱\n\n用户名\n```\ngit config user.name \"user1\"\n```\n邮箱\n```\ngit config user.email \"user1@email.com\"\n```\n\n### 原先使用HTTPS通信，则需要修改远程仓库地址\n\n```\ngit remote rm origin\ngit remote add origin git@user1.github.com:xxx/xxxxx.git\n```","categories":["技术博客","GIT"],"tags":["gitee","github","gitlab"]},{"title":"Hexo博客文件迁移新环境部署","url":"/posts/9968.html","content":"\n## 文档位于云仓库\n`Hexo`文档博客已上传`gitee`仓库\n![](./Hexo博客文件迁移新环境部署/Snipaste_2023-06-13_22-58-56.png)\n\n## 新环境部署\n\n### 新环境重新部署/迁移注意事项\n1. 确保电脑已安装nodeJs和Git\n2. npm install hexo-cli -g #全局安装hexo-cli客户端\n3. npm install #项目局部安装依赖\n4. hexo g #打包 (win10/11的powershell无法执行hexo命令，用cmd命令提示符即可)\n5. hexo s #运行 (同上所述)\n\n### 一键运行脚本\n一键运行脚本文件目录[ other ]下\n\n1. 一键创建页面hexo.bat\n2. 一键部署启动hexo.bat\n3. 一键部署GitHub_Pages.bat\n\n> 注意：若`hexo文档目录`与`脚本.bat`不符合,请修改bat文件中最新目录位置，否则脚本启动有问题！\n\n## 注意事项\n1. 创建发布目录,用于`hexo g`打包页面资源文件发布提交`github`\n   \n```\n   .deploy\n```\n\n2. 以克隆方式拉取`github`上仓库的项目到本地，主要是获取`.git`配置\n\n![](./Hexo博客文件迁移新环境部署/Snipaste_2023-06-13_23-04-43.png)\n\n3. 将`del.bat`脚本复制到`.deploy`目录\n> `del.bat` 脚本会在提交推送文件后清空当前目录文件\n\n![](./Hexo博客文件迁移新环境部署/Snipaste_2023-06-13_23-07-22.png)\n\n## 其他补充\n\n### 自定义css样式\n主题`theme`目录下的`css`下的`custom`目录未自建目录,非主题初始化自带。主要作用是对博客主题自定义美化的css样式配置等；\n![](./Hexo博客文件迁移新环境部署/Snipaste_2023-06-14_08-40-46.png)\n\n### 自定义资源文件\n可配置相关资源文件图片等，通过命令`hexo -g`打包生成html静态页面会附带当前资源等。\n![](./Hexo博客文件迁移新环境部署/Snipaste_2023-06-14_08-41-11.png)","categories":["技术博客","Hexo"]},{"title":"Hexo博客相关文档","url":"/posts/7324.html","content":"\n> 仅作记录，汇总相关Hexo的博客\n\n# Hexo主题美化\n>[Butterfly美化](https://www.cnblogs.com/MoYu-zc/p/14395965.html)\n\n# Hexo文章置顶\n> [hexo博客主题 Butterfly优化之文章置顶](https://blog.csdn.net/weixin_43372529/article/details/114176470)\n>\n# Hexo图片懒加载教程\n> [hexo开启懒加载后图片无法立即显示的问题](https://blog.csdn.net/qq_41911142/article/details/124253167)\n>\n\n# Hexo文章置顶与首页隐藏\n> [同时支持置顶和隐藏文章的 hexo 生成器插件（hexo-generator-index-custom）](https://blog.csdn.net/qq_42777659/article/details/126516780)\n\nhexo-generator-index-pin-top -> 置顶\nhexo-generator-index2 -> 隐藏\n\nhexo-generator-index-custom -> 置顶 + 隐藏\n\n\n# Hexo文章加密\n> [hexo-blog-encrypt](https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md)\n\n\n# Hexo插件-日志的自动分类插件 (⭐⭐⭐⭐⭐)\n> [日志的自动分类插件 hexo-auto-category ](https://blog.eson.org/pub/e2f6e239/)\n\n# hexo-renderer-markdown-it 高级的Markdown渲染器\n\n> [hexo-renderer-markdown-it 的配置与插件配置](https://blog.cxplay.org/works/hexo-renderer-markdown-it_and_plugins_config/)\n> \n> [【Hexo】选择更高级的Markdown渲染器](https://blog.csdn.net/qq_42951560/article/details/123596899)\n\n备注:需要安装额外插件`hexo-asset-image`不然图片不显示\n\n其他补充插件:\n```\n#自定义容器(需要额外配置)\nnpm i markdown-it-container\n#自定义图片宽高\nnpm i markdown-it-imsize\n#折叠/展开内容\nnpm i markdown-it-expandable\n```\n\n# 通过PicGo搭配gitee创建图传\n> [PicGo一条龙：下载、安装、配置gitee、配置typora](https://blog.csdn.net/weixin_45525272/article/details/125387761)\n>\n\n我这里只是用来给hexo用作图传,编辑器使用的vscode,因为typora目前已经开始收费了(呜呜呜)\n \n 备注: gitee存在防盗链,目前无法正常预览图片.\n \n 后期可以自建Minio服务,然后通过pigGo搭建配置属于自己的图床\n ","categories":["技术博客","Hexo"],"tags":["Hexo主题butterfly美化","Hexo文章置顶"]},{"title":"Hexo启动报错port问题","url":"/posts/38317.html","content":"\n> [win10 端口无故被占用的问题](https://www.cnblogs.com/acgq/p/14765179.html)\n\n# 问题描述\n\n正常运行`hexo s`失败异常，端口4000使用不了，\n切换命令`hexo server -p 4001`报错依旧。\n\n> Permission denied. You can't use port 4001\n> \n![](Snipaste_2023-04-28_13-33-37.jpg)\n\n\n# 解决方法\n\n以`管理员`身份运行`CMD`\n\n执行以下命令\n```\n#先关闭服务\nnet stop winnat\n#在开启服务\nnet start winnat\n```\n\n![](Snipaste_2023-04-28_13-38-45.jpg)\n![](Snipaste_2023-04-28_13-38-33.jpg)\n\n\n\n# 补充：排查Windows下端口占用命令\n```\nnetstat-aon|findstr 端口号\n```","categories":["技术博客","Hexo"],"tags":["winnat"]},{"title":"Hexo图片不显示解决","url":"/posts/13094.html","content":"\n## 安装插件及页面配置\n\n<br>\n\n安装插件\n```\nnpm install hexo-renderer-marked\n```\n\n修改hexo根目录配置文件_config.yml\n```\n#更改hexo设置\npost_asset_folder: true\n#添加marked插件设置\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n模拟创建新页面\n```\nhexo n testPage\n```\n在文件testPage.md中引入图片命令\n\n> vscode编辑器中正常预览现实图片\n```\n![](./testPage/test.jpg)\n```\n> hexo发布网页\n```\n![](test.jpg)\n```\n\n<br>\n\n## 模拟创建页面-预览效果截图\n\n<br>\n\nVscode中预览**图片展示**（图片使用的相对路径）\n![](Snipaste_2023-04-23_21-27-55.jpg)\n\n<br>\n\nHexo部署页面打包预览**图片不展示**\n![](Snipaste_2023-04-23_21-29-58.jpg)\n\n<br>\n\nHexo部署页面打包预览**图片展示**\n![](Snipaste_2023-04-23_21-31-41.jpg)\n\n\n## 日常编辑、发布工作流\n\n<br>\n\n> 备注：在上述插件已经安装且配置文件已如上述所示修改完成后\n\n1. 通过命令 `hexo n newPage`创建新的页面\n2. 复制已创建的`newPage`文件夹及`newPage.md`文件到vscode工作目录下\n3. 在vscode中正常书写信息、引用相关图片素材资源放置`newPage`文件夹中\n4. 在vscode中完成书写后，复制当前步骤[**2**]的文件夹及文件到hexo的工作目录下覆盖初始创建的文件夹及目录\n5. 全局替换hexo工作目录下`newPage.md`文件中图片引入代码`./newPage/`，使其图片目录由`![](./newPage/xxx.jpg)`为变为`![](xxx.jpg)`\n6. 执行`hexo g`命令进行打包，运行`hexo s`命令预览页面\n7. 复制hexo工作目录下`public`下所有资源到相应仓库下进行提交发布即可\n\n\n## 补充vscode下编辑md文件的相关插件\n![](Snipaste_2023-04-23_21-48-18.jpg)\n\n\n## 最新补充\n\n`hexo-renderer-markdown-it`比`hexo-renderer-marked`更强大!\n\n新增插件:\n`hexo-renderer-markdown-it (需要卸载:hexo-renderer-marked)`\n\n\n此时图片显示不出来,需要额外安装插件:\n`hexo-renderer-markdown-it`","categories":["技术博客","Hexo"],"tags":["hexo-renderer-marked"]},{"title":"Hexo添加搜索插件-hexo-generator-searchdb","url":"/posts/62708.html","content":"\n> [【CSDN】hexo博客添加本地搜索功能](https://blog.csdn.net/nineya_com/article/details/103338696#2hexogeneratorsearchdb_10)\n\n---\n\n## 到`blog`目录下\n![](Snipaste_2023-04-25_11-08-07.jpg)\n\n## 添加插件 hexo-generator-searchdb\n```\nnpm install hexo-generator-searchdb --save\n```\n![](Snipaste_2023-04-25_11-09-16.jpg)\n\n## 修改博客目录下_config.yml配置文件\n> 添加以下内容\n```\nsearch:\n  path: search.xml\n  field: post\n  content: true\n  format: html\n```\n\n![](Snipaste_2023-04-25_11-12-40.jpg)\n\n*补充描述：*\n> `path：`表示搜索后生成的文件路径，可以生成xml和json两种格式\n> \n> `field：`表示搜索的范围，有“post、page和all”三种值\n> \n>>  post：所有的文章；\n>>\n>>  page：所有顶部导航选项的页面；\n>>\n>>  all：所有的文章和顶部导航选项的页面。\n>\n>` content：`是否包含搜索到的文章的全部内容。如果false，生成的结果只包括标题和创建时间这些信息，没有文章主体。默认情况下是true.\n> \n> `format：`搜索到的内容、选项的格式。\n>>\n>>html(默认)：将html原文本缩略。\n>>\n>> striptags：将html原文本缩略，并删除所有标记。\n>> \n>> raw：记下每一篇文章或每一页的文字。\n\n\n\n## 修改主题Theme目录下_config.yml配置文件\n![](Snipaste_2023-04-25_11-15-46.jpg)\n\n## 启动Hexo\n![](Snipaste_2023-04-25_11-19-29.jpg)","categories":["技术博客","Hexo"],"tags":["hexo-generator-searchdb"]},{"title":"Hexo的cdn.jsdelivr.net访问CDN加速做本地处理","url":"/posts/64234.html","content":"\n问题描述：\n引用的npm依赖中，调用网址`cdn.jsdelivr.net`的CDN做加速处理，国内网络环境下存在访问慢情况！\n![](./Hexo的cdn-jsdelivr-net访问CDN加速做本地处理/Snipaste_2023-06-08_09-52-26.png)\n\n1. 找到引入npm的依赖\n![](./Hexo的cdn-jsdelivr-net访问CDN加速做本地处理/Snipaste_2023-06-08_09-54-14.png)\n\n1. 更新npm依赖中的js引用url地址\n\n在Hexo的`themes`主题目录下，所选择的主题文件`butterfly`(我这里是这个)下的`source`目录添加`npm_local_js`目录用来做本地化js资源文件\n![](./Hexo的cdn-jsdelivr-net访问CDN加速做本地处理/Snipaste_2023-06-08_10-00-19.png)\n\n原文件地址\n```\n${insertScript ? '<script src=\"https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js\"></script>' : ''}\n```\n修改文件地址\n```\n${insertScript ? '<script src=\"/custom/npm_local_js/echarts.min.js\"></script>' : ''}\n```\n![](./Hexo的cdn-jsdelivr-net访问CDN加速做本地处理/Snipaste_2023-06-08_10-04-23.png)\n\n3. 重新打包部署测试是否正常\n![](./Hexo的cdn-jsdelivr-net访问CDN加速做本地处理/Snipaste_2023-06-08_10-11-50.png)\n","categories":["技术博客","Hexo"],"tags":["cdn.jsdelivr.net","npm引用js进行本地化"]},{"title":"Hexo自用插件记录","url":"/posts/3085.html","content":"\n<!-- # 现安装插件截图 -->\n<!-- ![](./Hexo自用插件记录/Snipaste_2023-04-30_22-27-05.jpg) -->\n\n# TODO 待完善更新\n\n# 已启用插件\n\n## hexo-abbrlink  ⭐⭐⭐⭐⭐\n生成固定永久文章链接\n\n### 修改配置\n![](./Hexo自用插件记录/Snipaste_2023-04-30_22-58-03.jpg \"修改配置截图\")\n#### hexo配置修改\n```\n#permalink: :year/:month/:day/:title/ #hexo默认地址\npermalink: posts/:abbrlink.html\n```\n#### hexo-abbrlink 配置修改\n```\nabbrlink:\n  alg: crc16\n  rep: dec\n  drafts: false\n  auto_category:\n     enable: true\n     depth:      \n     over_write: false \n  auto_title: false \n  auto_date: false \n  force: false\n```\n### 效果预览\n#### 未修改前\n![](./Hexo自用插件记录/Snipaste_2023-04-30_23-20-34.jpg)\n#### 已修改后\n![](./Hexo自用插件记录/Snipaste_2023-04-30_23-18-00.jpg)\n\n\n\n## hexo-auto-category ⭐⭐⭐⭐⭐\n用途: 文章的自动分类插件\n\n## hexo-lazyload-image ⭐⭐⭐⭐\n用途: 图片懒加载\n\n## hexo-neat ⭐⭐⭐⭐\n用途: 资源文件压缩\n\n## hexo-renderer-markdown-it ⭐⭐⭐⭐\n用途: 更高级的markdown的渲染插件\n\n### markdown-it-imsize ⭐⭐⭐⭐\n> 属于 `hexo-renderer-markdown-it ` 额外插件\n> \n用途: 设置图片尺寸大小\n\n### markdown-it-expandable\n> 属于 `hexo-renderer-markdown-it ` 额外插件\n\n用途: 自动展开/隐藏\n\n## hexo-asset-image ⭐⭐⭐⭐⭐\n用途: 解决图片不显示问题\n\n修改 `_config.yml` 中 `post_asset_folder: true`\n\n![](./Hexo自用插件记录/Snipaste_2023-04-30_23-03-42.jpg)\n\n### md文件中引用图片方式\n\n```\n#引用图片格式\n## 方式1\n![](./Hexo自用插件记录/Snipaste_2023-04-30_23-06-10.jpg)\n## 方式2\n![](Snipaste_2023-04-30_23-06-10.jpg)\n```\n\n![](./Hexo自用插件记录/Snipaste_2023-04-30_23-06-10.jpg)\n\n\n## hexo-wordcount ⭐⭐⭐\n用途: 统计字数\n\n## hexo-generator-sitemap ⭐⭐\n用途: 生成站点地图(Google)\n\n## hexo-generator-baidu-sitemap ⭐⭐\n用途: 生成站点地图(Baidu)\n\n## hexo-generator-searchdb ⭐⭐⭐\n用途: 搜索插件\n\n## hexo-generator-index-custom ⭐⭐⭐⭐\n用途: 支持置顶/隐藏文章\n\n\n\n## hexo-blog-encrypt ⭐⭐⭐⭐\n用途: 文章加密\n\n\n# 已停用插件\n\n## hexo-generator-feed\n用途: 实现RSS订阅\n\n## hexo-generator-index-pin-top\n用途: 文章置顶展示\n\n### 缺点\n如果同时需要设置文章置顶与隐藏,功能缺失!\n\n## hexo-generator-index2\n用途: 文章主页隐藏\n\n### 缺点\n如果同时需要设置文章置顶与隐藏,功能缺失!\n\n## hexo-helper-live2d\n用途: 二次元看板娘\n\n### 模型\n`live2d-widget-model-shizuku`\n\n`live2d-widget-model-hijiki`\n\n### 缺点\n\n## hexo-tag-cloud\n用途: 标签云\n\n### 缺点","categories":["技术博客","Hexo"],"tags":["Hexo自用插件集合"]},{"title":"Hexo设置文章加密","url":"/posts/59357.html","content":"\n> [Hexo博客设置文章加密](https://blog.csdn.net/WwLK123/article/details/124436871)\n>\n\n## 安装插件\n```\nnpm install hexo-blog-encrypt\n```\n![](Snipaste_2023-04-26_11-01-29.jpg)\n\n## 增加`_config.yml`配置项\n```\nencrypt:\n  enable: true  \n```\n\n## 页面模板添加加密字段\n```\npassword: \nmessage: \n```\n![](Snipaste_2023-04-26_11-17-21.jpg)\n\n## 启动运行\n\n**文章首页展示-已加密**\n\n![](Snipaste_2023-04-26_11-19-08.jpg)\n\n**文章预览页-已加密**\n\n![](Snipaste_2023-04-26_11-21-03.jpg)","categories":["技术博客","Hexo"],"tags":["hexo-blog-encrypt"]},{"title":"Hexo通过windows的bat脚本联动","url":"/posts/15065.html","content":"\n## 想法初衷\n\n> 通过Windows的bat脚本一键化对hexo执行部署打包等相关命令\n\n---\n\n\n## 脚本代码\n\n### 一键运行`hexo n`\n> 在vscode中进行编辑，编辑完成后直接**处理图片前缀**后部署本地环境预览后发布\n```\n:: 防止中文乱码\nchcp 65001\n\n:: 不打印其他命令的回显(放在'@echo off'上此注释会被输出到控制台)\n@echo off\n\n:: 初始化参数配置\nset BlogPath=D:\\workSpace\\Hexo\\blog\necho 博客目录：%BlogPath%\n\nset CopyFrom=D:\\workSpace\\Hexo\\blog\\source\\_posts\\\necho 复制目录：%CopyFrom%\n\nset ParseTo=D:\\workSpace\\Vscode\\\necho 粘贴目录：%ParseTo%\n\n:: 配合'goto begin'回到此处重复执行操作\n:: :begin\n\n:: 获取输入\nset input=\nset /p input=请输入新增页面名称:\n\n:: 去除输入的所有空格（因为空格会导致hexo n创建新页面失败）\nset \"input=%input: =%\"\n\n:: 打印用户输入参数\necho %input%\n\n:: 执行cmd命令(cmd /c 表示执行完毕后关闭窗口)\nstart cmd /c \"cd/d %BlogPath% && hexo n '%input%' \"\n\n:: 等待最长5s继续往下执行操作（原因：需要等待 hexo n 的文件创建好，然后执行复制操作!）\n:: timeout /t 5 /nobreak > NUL\n\n:: 复制创建文件到vscode工作目录下\n:: copy  %CopyFrom%%input%.md  %ParseTo%\n\n:: 创建空文件夹\n:: md %ParseTo%%input%\n\n:: 可配合':begin'进行重复执行操作\n:: goto begin\n\n:: 暂停\n:: pause\n\n:: 退出关闭窗口\nexit\n```\n\n\n### 一键运行`hexo s`\n```\n:: 防止中文乱码\nchcp 65001\n\n@echo off\n\n:: 获取最新代码（关闭自动更新）\n:: start cmd /c \"cd/d D:\\workSpace\\Blog\\blog\\themes\\butterfly && git pull \"\n:: 清空public打包目录/打包资源/本地部署\nstart cmd /k \"cd/d D:\\workSpace\\Hexo\\blog && hexo clean && hexo g && hexo s\"\n```\n\n\n### 一键部署`github pages`\n> 原文件的编辑更新代码提交`giteee`信息规范即可，提交到`github pages`仓库部署的页面可随意。\n```\n:: 防止中文乱码\nchcp 65001\n\n@echo off\n\n:: 初始化参数配置\nset BlogDeployPath=D:\\workSpace\\Hexo\\blog\\.deploy\\ODUODUOKE.github.io\nset HexoPublicPath=D:\\workSpace\\Hexo\\blog\\public\nset delBatName=del.bat\n\n:: start cmd /c \"cd/d %BlogDeployPath% && call %delBatName%\"\n:: timeout /t 5 /nobreak \n\nstart cmd /c \"robocopy.exe %HexoPublicPath% %BlogDeployPath% /E /COPY:DAT /DCOPY:T\"\ntimeout /t 5 /nobreak \n\nstart cmd /c \"cd/d %BlogDeployPath% && git add . && git commit -m \"update\" && git push origin main && call %delBatName%\"\n```\n\n\n## 提交推送\n> vscode编辑的原文件及资源，我提交的`gitee`\n> hexo打包的部署页面这个提交是`github pages`\n\n### vscode下文件提交git\n> 安装git插件，直接在vscode中将相关文件提交至仓库\n\n### hexo下部署文件提交git\n> 通过脚本推送部署,不需要人工干预\n\n\n## TODO\n后续期望是通过一键脚本启动完服务后，通过`curl`监听到指定端口地址访问状态正常，然后启动浏览器（无需人工启动浏览器进行预览）。\n\n\n## 其他\n\n### 一键部署`github pages`注意事项\n\n\n![](Snipaste_2023-04-28_10-37-15.jpg)\n\n.gitgnore文件内容如下：\n```\ndel.bat\n```\n\n### del.bat 脚本命令代码\n```\n:: 防止中文乱码\nchcp 65001\n\n@echo off\n\n:: 设置保护目录、文件参数配置\nset defendDirName01=.git\nset defendBatSelf01=del.bat\nset defendBatSelf02=.gitignore\n\n\nfor /D %%i in (*) DO (\n\tif not %%i==%defendDirName01% (\n\t\tif not %%i==保留文件夹02（示例） (\n\t\t\trem echo 删文件夹：%%i \n\t\t\trd /S /Q %%i\n\t\t)\n\t)\n)\n\nfor %%i in (*) DO (\n\tif not %%i==%defendBatSelf01% (\n\t\tif not %%i==%defendBatSelf02% (\n\t\t\trem echo 删除文件：%%i \n\t\t\tdel %%i \n\t\t) \n\t)\n)\n```\n\n\n\n### 参考资料\n\n[bat批处理脚本中文乱码问题解决](https://blog.csdn.net/u012815136/article/details/101549751)\n\n[.Bat之批处理实现手动输入变量参数](https://blog.csdn.net/laozhuxinlu/article/details/52853787)\n\n[使用bat脚本自动打开cmd并执行命令](https://blog.csdn.net/s_y_w123/article/details/111353912)\n\n[写一个打开cmd窗口并执行cmd命令的Windows脚本（.bat文件）](https://blog.csdn.net/weixin_46909756/article/details/108726489)\n\n[bat文件命令行去除变量的空格](https://blog.csdn.net/sinat_16741503/article/details/72869123)\n\n[Bat 等待一段指定的时间](https://blog.csdn.net/l_o_s/article/details/103417243)\n\n[Windows copy命令](https://blog.csdn.net/JintGuo/article/details/77542490)\n\n[bat 复制文件和文件夹（目录](https://blog.csdn.net/weixin_40277264/article/details/121531320)\n\n[BAT ---- 删除部分文件和文件夹，仅保留指定文件、和文件夹](https://blog.csdn.net/shijianduan1/article/details/105718813)\n\n[curl http_code 状态码](https://www.cnblogs.com/wangyh702/p/11420287.html)\n\n[windows下bat脚本监听http服务](https://blog.csdn.net/zsx18273117003/article/details/93421783)\n\n[Curl学习日记2 - 在Windows CMD命令行中使用Curl](https://blog.csdn.net/weixin_42585386/article/details/106767065)\n\n---\n> 未使用，但是觉得以后会涉及，于是记录下来\n\n[在批处理(cmd，bat)下传递参数和获取参数](https://blog.csdn.net/Lvbey/article/details/118611287)\n\n---\n\n> robocopy 的使用教程忘记留存链接下来了。\n\n原本使用xcopy，经过测试发现复制过来的文件和原目录的文件里面多出来一个page文件夹和一个content.json （应该使我哪里步骤有问题导致的）。\n\n**备注： 如果复制到的目录下存在`.git`目录，文件会自动暂存区，导致我明明把目录下文件删除了，然后执行脚本复制好几次都失败！当时使用的`xcopy`，它输出日志100%copyied ，然后实际目录下是空的。**\n\n---\n\n\n\n","categories":["技术博客","Hexo"],"tags":["Windows系统bat脚本"]},{"title":"基于Hexo+GitHub Page搭建个人博客","url":"/posts/47912.html","content":"\n<br/>\n\n本次教程参考资料：\n> [手把手教你使用Hexo + Github Pages搭建个人独立博客](https://segmentfault.com/a/1190000004947261 \"来源:segmentfault\")\n> [我是如何利用Github Pages搭建起我的博客，细数一路的坑](https://zhuanlan.zhihu.com/p/334815426 \"来源：知乎\")\n>\n\n# 搭建Hexo博客\n___\n\n\n<br/>\n\n1. [Node.js下载安装](https://nodejs.org/en)\n   ![](nodejs.jpg)\n\n<br/>\n\n2. [Git下载安装](https://git-scm.com/)\n   ![](git.jpg)\n\n<br/>\n\n3. 安装Hexo\n\n    <br/>\n\n   3.1 Windows下用CMD命令窗口打开\n   ![](Snipaste_2023-04-23_09-35-00.jpg) \n\n   3.2 安装Hexo模块\n   ```\n   npm install hexo-cli -g #将模块全局安装\n   ```\n   > --save #将模块安装到项目目录下\n\n   3.3 初始化Hexo\n   ```\n   \n   hexo init blog #初始化博客目录（'blog'可修改其他名称）\n   cd blog\n   npm install #安装依赖配置\n   ```\n   ![](Snipaste_2023-04-23_09-38-35.jpg)\n\n   3.4 启动Hexo\n   ```\n   hexo g # 或者hexo generate\n   hexo s # 或者hexo server\n   ```\n        启动完成后，可以在[http://localhost:4000/](http://localhost:4000/) 进行查看\n    <br/>\n\n   ![](Snipaste_2023-04-23_09-40-24.jpg)\n\n    <br/>\n\n   命令解释：\n    - hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹\n   - hexo server (hexo s) 启动本地web服务，用于博客的预览\n   - hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）\n   - hexo new \"postName\" (hexo n) #新建文章  \n   - hexo new page \"pageName\" #新建页面\n\n    <br/>\n\n    3.5 常用组合命令\n    ```\n    hexo s -g #生成预览\n    hexo d -g #生成部署\n    ```\n\n\n---\n# Hexo主题设置\n\n1. 安装主题\n   ```\n   hexo clean\n   git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n   ```\n   ![](init_hexo_theme.jpg)\n\n<br/>\n\n2. 启用主题\n   > 修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia\n\n![](update_hexo_theme.jpg)\n\n<br/>\n\n3. 更新主题并启动Hexo\n   ```\n   cd themes/yilia\n   git pull\n   hexo g\n   hexo s\n   ```\n   ![](new_theme_yilia.jpg)\n\n---\n\n# Github Pages \n\n<br/>\n\n   1. 创建GitHub Page仓库\n   \n   <br/>\n\n   ![](Snipaste_2023-04-23_10-21-35.jpg \"图片来源：上述知乎博客\")\n\n   <br/>\n\n2. 开启GitHub Page仓库\n   \n    <br/>\n\n        进入设置\n   ![](Snipaste_2023-04-23_10-22-02.jpg \"图片来源：上述知乎博客\")\n\n    <br/>\n\n         确认仓库站点是否开通（一般是默认开通的）\n\n   ![](Snipaste_2023-04-23_10-22-13.jpg \"图片来源：上述知乎博客\")\n\n  <br/>\n\n  ---\n\n  # 部署Hexo到GitHub Page仓库\n  1. 使用Hexo deploy部署\n   \n```\n#需要安装扩展\nnpm install hexo-deployer-git --save\n```\n\n<br/>\n\n    \n修改_config.xml配置文件\n    \n    对应blog根目录：D:\\workSpace\\Test\\TestHexo\\blog\\_config.xml\n\n<br>\n\n    原配置文件截图:\n\n![](Snipaste_2023-04-23_10-33-56.jpg)\n\n\n\n    修改后配置文件截图：\n![](Snipaste_2023-04-23_10-35-37.jpg)\n\n执行部署命令\n\n```\nhexo d\n```\n\n<br/>\n\n2. 使用Git 命令部署\n\n<br/>\n   \n克隆当前仓库到目录\n\n```\ngit clone  xxxabc.git .deploy/xxxabc\n```\n\ndeply脚本\n> 用于Linux环境下一键部署发布Hexo到GitHub Page仓库\n\n```\nhexo generate\ncp -R public/* .deploy/xxxabc\ncd .deploy/xxxabc\ngit add .\ngit commit -m “update”\ngit push origin master\n```\n\n通过`hexo g`在public下生成新的待发布页面，通过命令`copy`到克隆下的仓库中，在通过`git`命令进行`push`到远端仓库进行发布","categories":["技术博客","Hexo"]},{"title":"Idea创建SpringBoot项目集成Mybatis","url":"/posts/62125.html","content":"\n\n## Idea初始化构建项目\n![](./Idea创建SpringBoot项目集成Mybatis/Snipaste_2023-06-13_21-32-36.png)\n\n![](./Idea创建SpringBoot项目集成Mybatis/Snipaste_2023-06-13_21-33-54.png)\n\n## SpringBoot-yml配置文件\n\n### DataSource\n```\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://192.168.136.180:3306/demo?characterEncoding=UTF-8\n    username: root\n    password: 123456\n```\n\n### Mybatis\n```\nmybatis:\n  #对应dao接口实现xml文件目录\n  mapper-locations: classpath:/mapper/*.xml\n  #对应实体类文件目录\n  type-aliases-package: org.mu.com.demo.entity\n```\n## SpringBoot-Application类\n启动类添加`MapperScan`自动扫描集成包\n```\n@MapperScan(basePackages = \"org.mu.com.demo.dao\")\n```\n\n![](./Idea创建SpringBoot项目集成Mybatis/Snipaste_2023-06-13_21-36-34.png)\n\n\n## Mybatis-Xml文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<!--mapper的命名空间-->\n<mapper namespace=\"org.mu.com.demo.dao.DemoMapper\">\n\n    <!--对应dao接口方法-->\n\n</mapper>\n```\n\n## 代码压缩包\n> 鼠标右键，从链接另存文件，直接点击是跳转！\n>\n> \n[demo.zip](./Idea%E5%88%9B%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Mybatis/demo.zip)\n","categories":["技术博客","Idea"],"tags":["Idea","SpringBoot 3.0","Mybatis"]},{"title":"Idea打包SpringBoot多模块项目以Docker镜像方式部署","url":"/posts/63317.html","content":"\n\n\n## 文档简述\n\n1. Linux环境下安装Docker，并且开启外部访问`2375`端口\n2. Idea项目的根目录编辑`DOCKERFILE`文件\n   1. 注意： FROM 引用的镜像，linux下docker需要pull拉取该镜像\n3. Idea项目配置war打包方式改为jar方式\n4. Idea配置Docker插件，并设置远程docker的服务地址\n\n\n## Docker\n### Linux下Docker的安装\n> 参考博客：[Linux docker 环境搭建](https://blog.csdn.net/qq_38951990/article/details/120831117)\n>> 配置Docker的镜像加速此处不予赘述\n\n安装依赖\n```\nyum install -y yum-utils device-mapper-persistent-data lvm2 \n```\n\n安装Docker-CE\n```\nyum install -y docker-ce \n```\n\n启动Docker\n```\nsystemctl enable docker\nsystemctl start docker\n```\n### Docker开放外部访问端口\n\n编辑配置文件`vim /usr/lib/systemd/system/docker.service\n`\n\n在`ExecStart`新增如下配置\n```\n-H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock\n```\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-27_15-48-01.jpg)\n\n防火墙开放2375端口\n```\nfirewall-cmd --zone=public --add-port=2375/tcp --permanent\n```\n\n重启docker\n```\nsystemctl restart docker\n```\n\n验证端口开启结果\n```\ntelnet 127.0.0.1 2375\n```\n\n\n## Idea\n\n### 安装Docker插件\n\n安装Docker插件\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-27_15-53-49.jpg)\n\n配置Docker远程地址\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-27_15-53-22.png)\n\n\n### 编辑DOCKERFILE文件\n```\n# 基础镜像使用Java\nFROM openjdk:8-jre-alpine\n# VOLUME 指定了临时文件目录为/tmp。\n# 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp\nVOLUME /tmp\n#日志文件目录\nVOLUME /usr/local/services/logs\n# 将jar包添加到容器中并更名为app.jar\nADD module_web/target/ylf_pay.jar app.jar\nENTRYPOINT [\"java\",\"-Xmx500m\",\"-jar\",\"-Dspring.profiles.active=dev\",\"app.jar\"]\n# 指定容器需要映射到主机的端口\nEXPOSE 9090\n```\n\n> 参考博客-扫盲： [Docker EXPOSE指令详解](https://blog.csdn.net/wang7376/article/details/130449568)\n\n#### 查看docker容器下的日志\n\n进入容器的命令模式\n```\ndocker exec -it `容器id` /bin/sh\n```\n\n退出\n```\nexit\n```\n\n### 打包部署镜像\n\n#### Idea打包项目为jar包\n\n在项目对外发布web模块的build需要指定application入口类\n```\n    <build>\n        <finalName>ylf_pay</finalName>\n\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <!--指定唯一入口类，也就是Application的位置-->\n                    <mainClass>org.jumutang.com.Application</mainClass>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <configuration>\n                    <skip>true</skip>\n                </configuration>\n            </plugin>\n\n        </plugins>\n\n    </build>\n```\n\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-27_15-58-28.jpg)\n\n\n#### Idea部署镜像\n\n> 需要先打包jar，在运行docker部署镜像。报错：找不到jar文件！！！\n\nIdea-Docker插件'>'启动时会默认创建容器启动（自行关闭后续通过命令指定参数启动）\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-27_16-01-59.jpg)\n\n\n部署执行完成后，可在linux下查看到镜像文件\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-28_08-36-45.jpg)\n\n## 部署运行\n\n### Linux下运行\nlinux下命令\n```\n docker run -d -p 8283:8283 --name ylfpay_docker ylfpay\n```\n\n> - -d 后台启动\n> - -p 暴露端口：内部端口\n> - --name 部署容器名称\n\n### 镜像打包推送远程服务\n例如：小程序云\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-28_09-10-38.jpg)\n\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-28_09-11-09.jpg)\n\n\n## 错误排查\n### Docker镜像启动失败查询日志\n```\ndocker logs 容器Id\n```\n![](./Idea打包SpringBoot多模块项目以Docker镜像方式部署/Snipaste_2023-05-27_16-04-51.jpg)\n\n","categories":["技术博客","Idea"],"tags":["Docker","Idea","SpringBoot"]},{"title":"@ConditionalOnBean和@ConditionalOnMissingBean两个注解","url":"/posts/5517.html","content":"\n\n[条件注解 ConditionalOnBean、ConditionalOnMissingBean、ConditionalOnClass、ConditionalOnMissingClass](https://blog.csdn.net/weixin_40910372/article/details/108204833)\n\n```\n@ConditionalOnBean         //\t当给定的在bean存在时,则实例化当前Bean\n@ConditionalOnMissingBean  //\t当给定的在bean不存在时,则实例化当前Bean\n@ConditionalOnClass        //\t当给定的类名在类路径上存在，则实例化当前Bean\n@ConditionalOnMissingClass //\t当给定的类名在类路径上不存在，则实例化当前Bean\n```\n","categories":["技术博客","Java"]},{"title":"Java中保证多线程的顺序执行","url":"/posts/39606.html","content":"\n> 参考博客：[保证多线程顺序执行，四种方案，你知道几种？](https://blog.csdn.net/o9109003234/article/details/118347488)\n\n常规操作-启动三个线程执行\n```\n    public static void main(String[] args) {\n\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"线程1\");\n            }\n        });\n\n        Thread thread2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"线程2\");\n            }\n        });\n\n        Thread thread3 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"线程3\");\n            }\n        });\n\n        thread.start();\n        thread2.start();\n        thread3.start();\n        \n    }\n\n```\n\n控制台\n```\n线程2\n线程3\n线程1\n```\n\n## 方案一\n`join()方法`\n\n使用`join()`方法改进后代码\n```\n    public static void main(String[] args) {\n\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"线程1\");\n            }\n        });\n\n        Thread thread2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                try {\n                    thread.join();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n\n                System.out.println(\"线程2\");\n            }\n        });\n\n        Thread thread3 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                try {\n                    thread2.join();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n\n                System.out.println(\"线程3\");\n            }\n        });\n\n        thread.start();\n        thread2.start();\n        thread3.start();\n\n    }\n```\n\n控制台\n```\n线程1\n线程2\n线程3\n```\n\n## 方案二\n\n`CountDownLatch`\n\n## 方案三\n单线程池\n\n```\n    public static void main(String[] args) {\n\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"线程1\");\n            }\n        });\n\n        Thread thread2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                try {\n                    thread.join();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n\n                System.out.println(\"线程2\");\n            }\n        });\n\n        Thread thread3 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n\n                try {\n                    thread2.join();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n\n                System.out.println(\"线程3\");\n            }\n        });\n\n\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.submit(thread);\n        executorService.submit(thread2);\n        executorService.submit(thread3);\n\n        executorService.shutdown();\n\n\n    }\n\n```\n\n控制台\n```\n线程1\n线程2\n线程3\n```\n\n\n## 方案四\n`CompletableFuture`\n\n```\n\n    public static void main(String[] args) {\n\n        Thread t1 = new Thread(new Work(),\"线程1\");\n        Thread t2 = new Thread(new Work(),\"线程2\");\n        Thread t3 = new Thread(new Work(),\"线程3\");\n\n        CompletableFuture.runAsync(()->t1.start()).thenRun(()->t2.start()).thenRun(()->t3.start());\n\n    }\n\n    static class Work implements  Runnable{\n        @Override\n        public void run() {\n            System.out.println(\"执行\"+Thread.currentThread().getName());\n        }\n    }\n```\n\n控制台\n```\n执行线程1\n执行线程2\n执行线程3\n```\n","categories":["技术博客","Java"]},{"title":"Java内存模型？volatile 关键字？synchronized 关键字和 volatile 关键字的区别?","url":"/posts/50822.html","content":"\n\n## Java内存模型\n> 参考博客：[一文看懂Java内存模型（JMM）](https://blog.csdn.net/c15158032319/article/details/117361782)\n\n## volatile 关键字\n> 参考博客：[Java种volatile关键字详解](https://www.cnblogs.com/zhengbin/p/5654805.html)\n\n## synchronized 关键字和 volatile 关键字的区别\n> 参考博客：[volatile和synchronized的区别](https://blog.csdn.net/suifeng3051/article/details/52611233)\n","categories":["技术博客","Java"]},{"title":"Java创建线程池7种方法","url":"/posts/10804.html","content":"\n\n> [Java创建线程池7种方法](https://blog.csdn.net/xhhhx_/article/details/124366229)\n\n> [面试突击：线程池有几种创建方式？推荐使用哪种？](https://blog.csdn.net/HongYu012/article/details/123331122)\n\n\n","categories":["技术博客","Java"]},{"title":"Java多线程-线程池有哪些参数、线程池工作原理、线程池各个参数干啥的","url":"/posts/21595.html","content":"\n[Java线程池详解](https://javaguide.cn/java/concurrent/java-thread-pool-summary.html)","categories":["技术博客","Java"]},{"title":"Java多线程","url":"/posts/58847.html","content":"\n\n> [java多线程使用详解与案例，超详细](https://blog.csdn.net/languageStudent/article/details/114794891)\n\n\n## Lambda表达式方式启动线程\n```\n  public static void main(String[] args) {\n        new Thread(()->{\n            System.out.println(\"开始了一个线程\"+new Date());\n        }).start();\n    }\n```\n\n## Java多线程使用的三种方式\n\n1. 继承Thread类，并重写run方法\n2. 实现Runnable接口，重写run方法\n3. 实现Callable<返回值>接口，重写call方法\n\n### 继承Thread类\n\n```\npublic class ThreadDemo02 extends  Thread{\n\n    @Override\n    public void run() {\n        System.out.println(\"你好呀\");\n    }\n\n    public static void main(String[] args) {\n        new ThreadDemo02().start();\n    }\n\n}\n```\n\n### 实现Runnable接口\n```\npublic class ThreadDemo03 implements  Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(\"你好呀\");\n    }\n\n    public static void main(String[] args) {\n        new Thread(new ThreadDemo03()).start();\n    }\n\n}\n```\n\n### 实现callable\n```\npublic class ThreadDemo04 implements Callable<Boolean> {\n\n    @Override\n    public Boolean call() throws Exception {\n        System.out.println(\"你好呀\");\n        return Thread.currentThread().isAlive();\n    }\n\n    public static void main(String[] args) {\n        \n        FutureTask<Boolean> task = new FutureTask<>(new ThreadDemo04());\n        new Thread(task).start();\n        System.out.println(\"线程执行结果:\"+task.get());\n\n    }\n}\n```\n\n控制台\n```\n你好呀\n线程执行结果:true\n```","categories":["技术博客","Java"]},{"title":"Java是引用传递还是值传递?","url":"/posts/7068.html","content":"\n> [Java中的参数传递，到底是值传递还是引用传递？](https://blog.csdn.net/weixin_43232955/article/details/106082129)\n\n答: 值传递","categories":["技术博客","Java"]},{"title":"Java秒杀系统设计","url":"/posts/37286.html","content":"\n> [《进大厂系列》系列-秒杀系统设计](https://zhuanlan.zhihu.com/p/92307325)\n>\n> [面试了十个应届生九个都是秒杀系统，你确定你们那是秒杀？](https://blog.csdn.net/qq_35190492/article/details/107833096)\n\n## Url动态化\n\n[秒杀系统中如何动态生成下单随机URL](https://blog.csdn.net/canot/article/details/53966987)\n\n个人理解：\n1. 前端调用下单接口之前先调用一个获取md5的接口\n   1. 未到秒杀时间开始不得响应\n   2. 接口不得重复提交，一个唯一标识的用户只能指定时间获取一次 \n2. 调用下单接口url地址pathValue拼接当前md5实现调用接口地址动态化\n\n目的：\n防止秒杀活动开始前，下单地址被提前获取进而造成利用脚本刷单情况发生。\n\n## 前端资源静态化\nCDN这种对前端资源缓存，加速访问\n\n## 前端按钮控制\n1. 默认置灰，不可按。调用时候调用接口查询北京时间然后开启\n2. 时间到了，也可以延时1秒左右按钮正常可点击\n\n## Redis\n1. 可以使用Redis集群\n2. 使用lua脚本实现redis的cas操作，避免redis库存更新在并发情况出现问题\n\n## 数据库乐观锁提高效率\n\n示例语句\n```\nupdate table set count = count -1,version = version +1  where goodsid=1 and count > 0 and version = xxx\n```\n\n### 悲观锁\n1. for update 行锁\n2. 储存过程\n\n## MQ进行消费\n通过MQ对秒杀订单进行处理消费","categories":["技术博客","Java"]},{"title":"Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程?","url":"/posts/50604.html","content":"\n\n\n> 参考博客：[Java线程池七个参数详解](https://blog.csdn.net/ye17186/article/details/89467919)\n>\n\n\n\n## Java线程池参数\n### 1. corePoolSize 线程池核心线程大小\n### 2. maximumPoolSize 线程池最大线程数量\n### 3. keepAliveTime 空闲线程存活时间\n### 4. unit 空闲线程存活时间单位\n### 5. workQueue 工作队列\n   1. ArrayBlockingQueue \n      > 基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。\n   2. LinkedBlockingQuene\n      > 基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。\n   3. SynchronousQuene\n      > 一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。\n    4. PriorityBlockingQueue\n        > 具有优先级的无界阻塞队列，优先级通过参数Comparator实现。 \n\n### 6. threadFactory 线程工厂\n### 7. handler 拒绝策略\n   1. CallerRunsPolicy\n      > 在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。\n   2. AbortPolicy\n       > 直接丢弃任务，并抛出RejectedExecutionException异常。\n   3. DiscardPolicy\n       > 直接丢弃任务，什么都不做。\n   4. DiscardOldestPolicy\n       > 抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\n\n## 阻塞队列一共有7种\n> 参考博客: [线程池中7种阻塞队列的介绍、区别与选择](https://blog.csdn.net/qq_40306697/article/details/119718820)\n>\n\n\n## 拒绝策略有4种\n\n## 新线程添加的流程?\n> 参考博客：[关于线程池的工作队列及新线程的流程顺序](https://www.cnblogs.com/liumz0323/p/11287037.html)\n\n","categories":["技术博客","Java"]},{"title":"Java线程的死锁","url":"/posts/58164.html","content":"\n线程的死锁\n> 代码来源于《并发编程之美》\n```\npublic class deadlock {\n\n\n    private static Object resources1 = new Object();\n\n    private static Object resources2 = new Object();\n \n\n    public static void main( String [] args ){\n\n        new Thread(()->{\n                    synchronized (resources1){\n                        System.out.println(Thread.currentThread()+\"get resources1\");\n\n                        try{\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            throw new RuntimeException(e);\n                        }\n\n                        System.out.println(Thread.currentThread()+\" waitting get resources2\");\n\n                        synchronized ( resources2 ){\n                            System.out.println(Thread.currentThread()+\"get resources2\");\n                        }\n                    }\n                },\"线程1\").start();\n\n        new Thread(()->{\n                    synchronized (resources2){\n                        System.out.println(Thread.currentThread()+\"get resources2\");\n\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            throw new RuntimeException(e);\n                        }\n\n                        System.out.println(Thread.currentThread()+\" waitting get resources1\");\n\n                        synchronized (resources1){\n                            System.out.println(Thread.currentThread()+\"get resources1\");\n                        }\n\n                    }\n                },\"线程2\").start();\n    }\n\n}\n```\n\n运行结果\n```\nThread[线程1,5,main]get resources1\nThread[线程2,5,main]get resources2\nThread[线程1,5,main] waitting get resources2\nThread[线程2,5,main] waitting get resources1\n```","categories":["技术博客","Java"]},{"title":"Jdk1.8新特性","url":"/posts/13923.html","content":"\n\n\n> 参考博客：[JDK1.8 新特性](https://blog.csdn.net/qq_29411737/article/details/80835658)\n>\n> 参考博客：[JDK1.8新特性实战](https://javaguide.cn/java/new-features/java8-common-new-features.html)\nJDK1.8新特性\n- Lambda表达式\n- 函数式接口\n- 方法引用和构造器调用\n- Stream API\n- 接口中默认方法和静态方法\n- 新时间日期API","categories":["技术博客","Java"]},{"title":"SpringBoot对Spring框架有什么优势?","url":"/posts/49304.html","content":"> [Spring和SpringBoot比较，解惑区别](https://www.jianshu.com/p/ffe5ebe17c3a)\n\n1. 创建独立的`spring`引用\n2. 嵌入式`Tomcat`、`Jetty`、 `Undertow`容器（无需部署war文件）\n3. 提供的`starters`简化构建配置\n4. 提供生产指标,例如: 指标\\健壮检查和外部化配置\n5. 没有代码生成和xml配置要求\n\n","categories":["技术博客","Java"]},{"title":"SpringBoot的依赖注入","url":"/posts/62919.html","content":"\n> 参考博客: [@Autowried和@Resource区别](https://blog.csdn.net/qq_45590494/article/details/114444371)\n>\n> 参考博客：[SpringBoot依赖注入](https://blog.csdn.net/cb2474600377/article/details/53740312)\n\n## Autowired\n\n- 默认注入方式`byType`根据类型匹配；\n- 当多个实现时，则通过`byName`注入；\n- 通过配合@Qualifier注解显式指定name，指明具体使用的实现类；\n\n\n## Resource\n\n- 默认通过`byName`注入，没有匹配则通过`byType`注入;\n\n### 重要属性 `name` 和 `type` \n`name`和`type`用来显式指定`byName`和`byType`方式注入\n\n对应4种情况\n```\n//1. 默认方式：byName\n@Resource\nprivate UserService userService;\n\n//2. 指定byName\n@Resource(name=\"userService\")\nprivate UserService userService;\n\n//3. 指定byType\n@Resource(type=\"UserService.class\")\nprivate UserService userService;\n\n//4. 指定byName和byType\n@Resource(name=\"userService\",type=\"UserService.class\")\nprivate UserService userService;\n\n```\n报错情况\n- 未指定name属性、未指定type属性：\n  - 默认通过byName，若匹配失败者通过byType方式注入\n- 指定name属性:\n  - 将变量名在IOC容器中id进行匹配，匹配失败则报错\n- 指定type属性：\n  - 将类型在IOC容器中进行匹配，匹配不到或匹配多个则报错\n- 指定name属性和type属性：\n  - 在IOC容器中匹配，名字和类型同时匹配则成功，否则失败\n\n## Qualifier和Autowired\nQualifier和Autowired配合使用，指定bean的名称\n\n## Service、Controller、Respository\n标记类是Service层类，Controller层类，数据存储层的类，spring扫描注解配置时，会标记这些类要生成bean。\n\n\n## Component\n是一种泛指，标记类是组件，spring扫描注解配置时，会标记这些类要生成bean。\n\n\n## 附录备注\n\n### SpringBoot的包未被扫描到问题解决\n1. 确认`Application`的入口类在目录位置最顶层，扫描规则从上往下。（主入口类：`org.xx.com`; 其他类: `org.xx.com.dao/controller/model/...`）\n2. 在springBoot的启动入口类上使用注解`@ComponentScan`注解,配置需要扫描的包。（例如：`@ComponentScan(basePackages={\"org.xx.com.conf\"})`）\n\n### 不能对`static`静态变量注入\n> 从配置文件*.yml获取参数给变量赋值\n```\n\n@Value(\"${xxx.xxx}\")\npublic void setDemo( String strs ){\n    this.demo = strs;\n}\npublic static String demo;\n\n```\n","categories":["技术博客","Java"]},{"title":"SpringBoot的自动装配原理","url":"/posts/12723.html","content":"\n\nhttps://blog.csdn.net/Object_de_Father/article/details/109392088","categories":["技术博客","Java"]},{"title":"Spring的两大特点是什么?","url":"/posts/50574.html","content":"\n- IOC 控制反转\n- AOP 面向切面编程\n\n## IOC \n作用: 不用开发者手动new创建对象,直接由Spring的容器进行管理,需要用的时候直接获取即可.\n\n### IOC的使用场景\n- 正常情况下我们使用一个对象时都是需要new Object() 的。而ioc是把需要使用的对象提前创建好，放到spring的容器里面。需要使用的时候直接使用就行，而且可以设置单例或多例，非常灵活。\n- 我们在service层想调用另外一个service的方法，不需要去new了，直接把它交给spring管理，然后用注解的方式引入就能使用\n\n## AOP\n> [什么是 AOP，AOP 的作用是什么？](https://blog.csdn.net/jjclove/article/details/124386972)\n\n### AOP的使用场景\n- 事务管理\n  - 访问数据库，而你不想管事务，所以，Spring在你访问数据库之前，自动帮你开启事务，当你访问数据库结束之后，自动帮你提交/回滚事务！\n- 权限检查\n  - 判断用户访问接口是否具有可执行权限(切自定义注解)\n- 日志记录\n  - 登录日志和操作日志就是通过aop+反射的方式实现的\n- ...\n\n### 常见通知\n- 前置通知 @Before\n- 后置通知 @After\n- 返回通知 @AfterReturning\n- 异常通知 @AfterThrowing\n- 环绕通知 @Around","categories":["技术博客","Java"]},{"title":"Windows下同时安装Jdk1.8和Jdk17方案","url":"/posts/37787.html","content":"\n> 相关文档链接： [Linux下安装JDK环境](/posts/59283.html)\n\n---\n\n## 单JDK版本配置JAVA环境变量\n> 参考博客：[JDK环境变量安装](https://blog.csdn.net/qing_gee/article/details/102795906)\n\n### JAVA_HOME 环境变量\n```\nC:\\Program Files\\Java\\jdk1.8.0_131\n```\n### PATH 环境变量\n```\n;%JAVA_HOME%\\bin;\n```\n\n### 验证JAVA环境配置是否成功\n```\njava --version\n```\n\n---\n\n\n## 多JDK版本配置JAVA环境变量\n>根据项目使用需要自行切换JDK1.7或JDK17的环境变量\n> \n![](./Windows下同时安装Jdk1-8和Jdk17方案/Snipaste_2023-06-13_21-47-02.png)","categories":["技术博客","Java"]},{"title":"为什么要有hashCode?","url":"/posts/42174.html","content":"\n## “ HashSet 如何检查重复”为例⼦来说明为什么要有 hashCode ？\n\n> 当你把对象加⼊ HashSet 时， HashSet 会先计算对象的 hashCode 值来判断对象加⼊的位置，同时也会与其他已经加⼊的对象的 hashCode 值作比较如果没有相符的hashCode ， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调⽤ equals() ⽅法来检查 hashCode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。这样我们就⼤⼤减少了 equals 的次数，相应就⼤⼤提⾼了执⾏速度。\n\nhashCode() 和 equals() 都是⽤于比较两个对象是否相等\n\n##  JDK 还要同时提供这两个⽅法?\n在⼀些容器（⽐如 HashMap 、 HashSet ）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更⾼（参考添加元素进 HashSet 的过程）！\n\n## 不只提供 hashCode() ⽅法呢？\n这是因为两个对象的 hashCode 值相等并不代表两个对象就相等。\n\n==哈希碰撞也就是指的是不同的对象得到相同的hashCode==\n\n## 总结\n- 如果两个对象的`hashCode`值相等,那么这两个对象不一定相等(哈希碰撞)\n- 两个对象的`hashCode`值想到并且`equals()`方法也返回`true`,这两个对象是相等的\n- 两个对象的`hashCode`值不相等,那么两个对象一定不相等\n\n\n## 拓展知识\n### 为什么重写equals()方法时,hashCode方法也必须重写?\n\n因为两个相等对象的hashCode值也必须相等.\n\n如果重写equals()时,没有重写hashCode方法,可能导致equals()方法判断两个值相等,hashCode()值却不相等.\n\n\n### 总结\n- `equals`方法判断两个对象是相等,那么两个对象的`hashCode`值一定相等\n- 两个对象有相同的`hashCode`,他们也不一定是相等的(哈希碰撞)\n\n","categories":["技术博客","Java"]},{"title":"单例模式用法","url":"/posts/44263.html","content":"\n> [Java设计模式单例模式(Singleton)用法解析_java](http://www.ay1.cc/article/1677293335290813180.html)\n\n## 懒汉式（线程不安全）\n\n当多个访问者同时访问的时候很有可能创建多个对象。之所以叫懒汉式，是因为这种写法是使用的时候才创建，起到了懒加载Lazy loading的作用，实际开发中不建议采用这种写法\n\n```\npublic class LazySingleton {\n\n    private static LazySingleton instance;\n\n    private LazySingleton(){\n\n    }\n\n    public static LazySingleton getInstance(){\n        if( instance!=null ){\n            instance = new LazySingleton();\n        }\n\n        return instance;\n    }\n\n}\n```\n\n## 线程安全的懒汉式(线程安全)\n```\npublic class LazySingleton {\n\n    private static LazySingleton instance;\n\n    private LazySingleton(){\n\n    }\n\n    public synchronized static LazySingleton getInstance(){\n        if( instance!=null ){\n            instance = new LazySingleton();\n        }\n\n        return instance;\n    }\n\n}\n```\n\n## 饿汉式（线程安全）\n\n直接在运行（加载）这个类的时候创建了对象，之后直接访问。显然这种方式没有起到Lazy loading的效果。但是是线程安全的，实际开发中还是比较常用。\n\n```\npublic class HungrySigleton {\n\n    public static final HungrySigleton instance = new HungrySigleton();\n\n    private HungrySigleton(){}\n\n    public static HungrySigleton getInstance(){\n        return instance;\n    }\n\n}\n```\n\n## 静态内部类（线程安全）\n```\npublic class StaticInnerClassSingleton {\n\n    //构造方法私有化\n    private StaticInnerClassSingleton(){};\n\n    private static class HolderInnerClass {\n        //需要提供单例对象的外部类作为静态属性加载的时候就初始化\n        private static StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n    }\n\n    //对外暴漏访问点\n    public static StaticInnerClassSingleton getInstance(){\n        return HolderInnerClass.instance;\n    }\n\n}\n```\n\n## 枚举方法单例（线程安全）\n> 暂时空\n\n## 双重检查法（通常线程安全、低概率线程不安全）\n```\npublic class DoubleCheckSingleton {\n\n    private static DoubleCheckSingleton instance;\n\n    private DoubleCheckSingleton(){};\n\n    public static DoubleCheckSingleton getInstance(){\n\n        if( instance == null ){\n            synchronized (DoubleCheckSingleton.class){\n                if( instance == null ){\n                    instance = new DoubleCheckSingleton();\n                }\n            }\n        }\n\n        return instance;\n    }\n\n}\n```\n\n### Double check(volatile) 双重检查法-升级版\n\nvolatile关键字的其中一个作用就是禁止指令重排序，把instance声明volatile后，对它的操作就会有一个内存屏障\n\n```\npublic class DoubleCheckSingleton {\n\n    private volatile static DoubleCheckSingleton instance;\n\n    private DoubleCheckSingleton(){};\n\n    public static DoubleCheckSingleton getInstance(){\n\n        if( instance == null ){\n            synchronized (DoubleCheckSingleton.class){\n                if( instance == null ){\n                    instance = new DoubleCheckSingleton();\n                }\n            }\n        }\n\n        return instance;\n    }\n\n}\n```\n\n## ThreadLocal实现单例模式（线程安全）\n```\npublic class ThreadLocalSingleton {\n\n    private static final ThreadLocal<ThreadLocalSingleton> threadLocal = new ThreadLocal (){\n        @Override\n        protected ThreadLocalSingleton initialValue() {\n            return new ThreadLocalSingleton();\n        }\n    };\n\n    private ThreadLocalSingleton(){};\n\n    public static ThreadLocalSingleton getInstance(){\n        return threadLocal.get();\n    }\n}\n```","categories":["技术博客","Java"]},{"title":"实现Runnable接口和Callable接口的区别","url":"/posts/54835.html","content":"\n\n\n> 参考博客：[Runnable 和 Callable 有什么区别](https://blog.csdn.net/meism5/article/details/90176922)\n\n\n主要区别\n- Runnable接口run方法无返回值；Callable接口call方法有返回值，支持泛型；\n- Runnable接口run方法只能抛出运行时异常，且无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息；\n\n\n拓展关联\n> [Java多线程](/posts/58847.html)","categories":["技术博客","Java"]},{"title":"成员变量和局部变量的区别?","url":"/posts/33408.html","content":"\n> [成员变量\\局部变量\\静态变量的区别](https://blog.csdn.net/haovip123/article/details/43883109)\n>\n> [Java全局变量和局部变量初始化问题](https://blog.csdn.net/qq_41936561/article/details/104402117)\n\n## 成员变量和局部变量和静态变量的区别\n\n<table style='width:100%;'>\n<tr>\n<td></td>\n<td>成员变量</td>\n<td>局部变量</td>\n<td>静态变量</td>\n</tr>\n<tr>\n<td>定义位置</td>\n<td>在类中,方法外</td>\n<td>在方法中,或者是方法的形式参数</td>\n<td>在类中,方法外</td>\n</tr>\n<tr>\n<td>初始化值</td>\n<td>有默认值</td>\n<td>无,先定义,赋值后才可以使用</td>\n<td>有默认值</td>\n</tr>\n<tr>\n<td>调用方式</td>\n<td>对象调用</td>\n<td> </td>\n<td>对象调用\\类名调用</td>\n</tr>\n<tr>\n<td>储存位置</td>\n<td>堆</td>\n<td>栈</td>\n<td>方法区</td>\n</tr>\n<tr>\n<td>生命周期</td>\n<td>与对象共存亡</td>\n<td>与方法共存亡</td>\n<td>与类共存亡</td>\n</tr>\n<tr>\n<td>别名</td>\n<td>实例变量</td>\n<td> </td>\n<td>类变量</td>\n</tr>\n</table>\n\n## 成员变量和局部变量的初始化值\n\n> 变量时需要遵循的原则为：就近原则 (局部范围找，有就使用；接着在成员位置找)\n\n### 成员变量和静态变量\n- 基本类型\n  - `byte/short/int/long` : 0\n  - `float/double` : 0.0\n  - `char` : '\\u0000'(null)\n- 引用类型\n  - 默认初始值`null`\n\n\n![](./成员变量和局部变量的区别/Snipaste_2023-05-09_09-17-51.jpg)\n\n\n### 局部变量\n> 局部变量若只定义未使用编译不会报错,一旦使用且为赋值编译阶段不通过\n\n![](./成员变量和局部变量的区别/Snipaste_2023-05-09_09-18-23.jpg)","categories":["技术博客","Java"]},{"title":"查看.class文件的字节码","url":"/posts/51115.html","content":"\n## 查看.class文件的字节码\n\n\n> [Java以及IDEA下查看字节码的五种方法#查看字节码的方法idea可以集成命令行使用javap](https://blog.csdn.net/21aspnet/article/details/88351875)\n\n\n## 打开编译.class文件位置\n![](./查看-class文件的字节码/20230507090051.png)\n\n## 执行命令\n```\njavap -v Test.class\n```\n\n### 对`.java编译为.class文件`命令\n```\njavac -encoding UTF-8 Test.java\n```\n\n## 控制台打印字节码\n![](./查看-class文件的字节码/Snipaste_2023-05-07_09-01-15.jpg)","categories":["技术博客","Java"]},{"title":"说说sleep()方法和wait()方法区别和共同点?","url":"/posts/31949.html","content":"\n> 参考博客：[sleep（）和wait（）的区别和共同点](https://blog.csdn.net/qq_38197844/article/details/109131330)\n\n## 共同点\n两者都可以暂停线程的执行\n\n## 区别\n1. `sleep()`方法没有释放锁、但`wait()`方法释放了锁；\n2. `wait()`方法调用后不会自动苏醒，需要别的线程调用同一对象的`notify()/notifyAll()`方法；而`sleep()`方式执行后会自动苏醒；\n3. `wait()`通常用于线程之间的通信，而`sleep()`一般用于暂停；\n\n","categories":["技术博客","Java"]},{"title":"静态变量用什么修饰呢?有什么作用?","url":"/posts/39404.html","content":"\n`static`关键字修饰\n","categories":["技术博客","Java"]},{"title":"Centos7关闭图形化界面","url":"/posts/46473.html","content":"\n> 参考博客：[Centos7怎么关闭图形化界面](https://jingyan.baidu.com/article/2d5afd693e2480c4a2e28ec2.html)\n\n## 永久关闭图形化界面\n\n查看当前启动模式\n```\nsystemctl get-default\n```\n\n设置多用户模式\n```\nsystemctl set-default multi-user.target\n```\n\n重启\n```\nreboot\n```\n\n## 临时关闭图形化界面\n\n命令行界面\n```\ninit 3\n```\n\n图形化界面\n```\ninit 5\n```","categories":["技术博客","Linux"]},{"title":"Linux下mkdir命令使用","url":"/posts/45857.html","content":"\n> 参考博客：[Linux技巧(三)： seq命令 / mkdir -p 批量创建/删除文件夹 详解](https://blog.csdn.net/succing/article/details/122286002)\n\n\n## 一次性级联创建多级+平级目录\n> 注：目录下有子目录，则各目录层级需用大括号括起来，中间用/分隔\n```\nmkdir -p src/{{main,test}/{java,resources},main/webapp}\n```\n\n![](./Linux下mkdir命令使用/Snipaste_2023-06-07_06-44-29.png)\n\n## 一次创建多个平级目录，下面都分别创建同一个文件夹\n```\nmkdir -p Project/{a,b,c,d}/src\n```\n![](./Linux下mkdir命令使用/Snipaste_2023-06-07_06-47-23.png)\n\n### 查看目录树形结构`tree`\n```\nyum install -y tree;\n```","categories":["技术博客","Linux"],"tags":["Linux","mkdir命令"]},{"title":"Linux下使用Docker安装部署Zookeeper","url":"/posts/49054.html","content":"\n> [Linux安装Docker|往期文章](/posts/63317.html)\n>\n> [centos安装docker显示 No package docker-ce available](https://blog.csdn.net/Dan1374219106/article/details/112484549)\n>\n> [Docker安装Zookeeper教程](https://blog.csdn.net/duyun0/article/details/128437451)\n>\n> [Docker使用常用命令](https://blog.csdn.net/qq_45926473/article/details/125657914)\n>\n> [docker搭建zookeeper集群](https://blog.csdn.net/u010080562/article/details/120620827)\n\n\n文档描述：\n\n基于单机实现zookeeper的部署安装实现，通过多台服务器以docker方式集群化部署zookeeper暂未成功实现该方案!\n\nzookeeper集群化部署两种方式\n- 单机docker多开容器实现伪zookeeper集群\n- 多服务器通过docker部署实现完全zookeeper集群\n\n## 基于Centos7安装Docker\n\n下载关于docker的依赖环境\n```\nyum -y install yum-utils device-mapper-persistent-data lvm2\n```\n设置Docker的镜像源(如果不设置，默认会从官网下载)\n```\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n刷新缓存\n```\nyum makecache fast\n```\n安装docker\n```\nyum -y install docker-ce\n```\n\n启动docker服务\n```\nsystemctl start docker\n```\n\n设置docker开机启动\n```\nsystemctl enable docker\n```\n\n验证安装结果\n```\ndocker info\n```\n\n打印hello-world\n```\ndocker run hello-world\n```\n\n\n## Docker下安装Zookeeper\n查看本地镜像\n```\ndocker images;\n```\n\n查询docker镜像\n```\ndocker search zookeeper;\n```\n\n拉取镜像\n- 拉取最新docker镜像命令\n ```\n docker pull zookeeper:latest\n ```\n- 拉取指定版本docker镜像命令\n```\ndocker pull zookeeper:3.5.7\n```\n\n---\n\n创建ZooKeeper 挂载目录\n\n\n创建多个挂载目录命令\n- data：数据挂载目录\n- conf：配置挂载目录\n- logs：日志挂载目录\n```\nmkdir -p /mydata/zookeeper/{data,conf,logs}\n```\n\n启动zookeeper容器\n```\ndocker run -d --name zookeeper --privileged=true -p2181:2181 -p2888:2888 -p3888:3888  -v /mydata/zookeeper/data:/data -v /mydata/zookeeper/conf:/conf -v /mydata/zookeeper/logs:/datalog zookeeper:3.5.7\n```\n\n参数说明\n```\n-e TZ=\"Asia/Shanghai\" # 指定上海时区 \n-d # 表示在一直在后台运行容器\n-p 2181:2181 # 对端口进行映射，将本地2181端口映射到容器内部的2181端口\n--name # 设置创建的容器名称\n-v # 将本地目录(文件)挂载到容器指定目录；\n--restart always #始终重新启动zookeeper，看需求设置不设置自启动\n```\n> [docker --privileged=true 参数作用](https://blog.csdn.net/wangxuelei036/article/details/107457712)\n\n\n- 添加ZooKeeper配置文件\n> 在挂载配置文件目录(/mydata/zookeeper/conf)下，新增zoo.cfg 配置文件\n\n新增配置\n```\nclientPort=2181\n```\n修改后配置文件\n```\ndataDir=/data  # 保存zookeeper中的数据\nclientPort=2181 # 客户端连接端口，通常不做修改\ndataLogDir=/datalog\ntickTime=2000  # 通信心跳时间\ninitLimit=5    # LF(leader - follower)初始通信时限\nsyncLimit=2    # LF 同步通信时限\nautopurge.snapRetainCount=3\nautopurge.purgeInterval=0\nmaxClientCnxns=60\nstandaloneEnabled=true\nadmin.enableServer=true\nserver.1=localhost:2888:3888;2181\n```\n\n进入容器内部，验证容器状态\n\n进入zookeeper 容器内部\n\n```\ndocker exec -it zookeeper /bin/bash\n```\n\n检查容器状态\n```\ndocker exec -it zookeeper /bin/bash ./bin/zkServer.sh status\n```\n进入控制台\n```\ndocker exec -it zookeeper zkCli.sh\n```\n\n安装ZooInspector客户端连接\n> 【未实际测试起来】\n命令\n```\njava -jar zookeeper-dev-ZooInspector.jar\n```\n\n文件下载地址\n```\nhttps://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip\n```\n\n> 问题：WARNING: IPv4 forwarding is disabled. Networking will not work\n\n```\n解决办法：\n# vi /etc/sysctl.conf\n或者\n# vi /usr/lib/sysctl.d/00-system.conf\n添加如下代码：\nnet.ipv4.ip_forward=1\n重启network服务\n# systemctl restart network\n```\n\n\nDocker安装Zookeeper集群\n> 【未实际测试起来-集群部署zookeeper】\n\n- 准备三台机器互相ping通\n- 配置文件zoo.cfg\n\n```\ncd  /mydata/zookeeper/conf\nvim zoo.cfg\n```\n\n三台机器分别执行添加 \n```\nserver.1=192.168.136.140:2888:3888;2181\nserver.2=192.168.136.141:2888:3888;2181\nserver.3=192.168.136.142:2888:3888;2181\n```\n> - 2181: 客户端端口\n> - 2888：zookeeper容器间通信的端口\n> - 3888：zookeeper选举投票的端口\n\n设置myid标识\n> zookeeper选举也会根据myid的大小进行投票master\n\nzookeep01\n```\necho 1 > /mydata/zookeeper/conf/myid\n```\n\nzookeep02\n```\necho 2 > /mydata/zookeeper/conf/myid\n```\n\nzookeep03\n```\necho 3 > /mydata/zookeeper/conf/myid\n```\n\n","categories":["技术博客","Linux"]},{"title":"Linux下安装JDK环境","url":"/posts/59283.html","content":"\n解压到目录\n```\ntar -zxvf jdk-8u151-linux-x64.tar.gz\n```\n\nJDK环境变量\n```\nexport JAVA_HOME=/opt/jdk/jdk1.8.0_151\nexport JRE_HOME=/opt/jdk/jdk1.8.0_151/jre\nexport CLASS_PATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n```\n\n刷新配置\n```\nsource /etc/profile\n```\n\n测试输出\n```\njava -version\n```","categories":["技术博客","Linux"],"tags":["Linux","JDK"]},{"title":"Linux中VIM使用技巧","url":"/posts/9930.html","content":"\n## VIM命令行模式跳转首位/末尾\n> [vim命令行模式跳至行首/行尾](https://blog.csdn.net/m0_38068876/article/details/115393229)\n\n跳转首位\n```\n$ 或者 0\n```\n跳转末尾\n```\nA\n```\n","categories":["技术博客","Linux"]},{"title":"Linux系统修改主机名hostName","url":"/posts/24783.html","content":"\n\n\n\n \n\n\n## 临时修改主机名（重启后失效）\n### 命令修改主机名\n```\nhostname newhostname\n```\n### 修改主机名报错\n\n> 错误信息：hostname： the specified hostname is invalid\n> \n![](./Linux系统修改主机名hostName/Snipaste_2023-05-12_12-35-53.jpg)\n\n#### 解决方式\n```\nhostnamectl set-hostname newhostname\n```\n\n## 永久修改主机名（重启后生效）\n### 修改配置文件 <font color='red'>/etc/sysconfig/network</font>\n\n```\n#修改/增加hostname主机名\nhostname=newhostname\n```\n\n### 修改配置文件 <font color='red'>/etc/hosts</font>\n\n> 一般是不用修改hosts文件，可见原博客详解。\n\n```\n#添加对应主机名的ip地址\n127.0.0.1 newhostname\n```\n\n## 参考博客\n> [Linux下如何永久修改主机名](https://blog.csdn.net/qq_39629343/article/details/80253121)\n>\n> [在Linux系统中使用hostname命令修改主机名报错“the specified hostname is invalid“](https://blog.csdn.net/cnds123321/article/details/123673882)\n\n","categories":["技术博客","Linux"]},{"title":"Linux设置时间并开启自动同步校准","url":"/posts/24138.html","content":"\n\n> 来源：为知笔记|个人转存\n\n## 设置时区\n设置时区亚洲.上海\n```\ntimedatectl set-timezone Asia/Shanghai\n```\n## 设置时间\n\n1. 将系统日期设置为2017年11月3日\n```\ndate -s 11/03/17\n```\n\n\n2. 将系统时间设置为14点20分50秒\n```\ndate -s 14:20:50\n```\n\n3. 系统时间自动系统同步\n```\nyum install -y ntpdate;\n```\n> 清华大学时间：ntp.tuna.tsinghua.edu.cn\n```\nntpdate time.windows.com\n```\n\n\n4. 定时同步系统时间 \n\n编辑定时任务\n```\ncrontab -e\n```\n每天的5点10分crontab运行一次命令，自动同步系统时间，并且同步到硬件时间\n```\n10 5 * * * root (/usr/sbin/ntpdate  time.windows.com && /sbin/hwclock -w) &> /var/log/ntpdate.log\n```\n\n## 查看系统硬件时钟\n```\nhwclock  --show\n```","categories":["技术博客","Linux"],"tags":["Linux","Linux重装后必做事项"]},{"title":"VM虚拟机中固定Linux系统IP地址","url":"/posts/10212.html","content":"\n## 设置DNS和GATE网关地址\n\n下载工具\n```\nyum install -y bind-utils\n```\n\n解析www.baidu.com域名地址，获取DNS配置\n```\nnslookup www.baidu.com\n```\n![](./VM虚拟机中固定Linux系统IP地址/p0JRHOCDl9DtsT4mV24OV6UGvmvQpYtLHhTCASC7AbY.png)\n\n配置更新到`ifcfg-ens33`配置文件中\n```\nvim /etc/sysconfig/network-scripts/ifcfg-ens33\n```\n\n```\nGATEWAY=192.168.119.2\nDNS1=114.114.114.114\n```\n\n![](./VM虚拟机中固定Linux系统IP地址/tot7P5Sdo35ZY2BDmYkPMWChUQN9IRhVI8k951TVPO4.png)\n\n## 固定虚拟机下IP地址\n> 步骤01解决问题是：固定IP地址后可能出现无法上网问题\n \n跳转到指定目录地址\n```\ncd /etc/sysconfig/network-scripts/\n```\n\n修改网络配置文件\n```\nvim ifcfg-ens33\n```\n\n修改配置项\n```\nBOOTPROTO=\"none\"\nIPADDR=192.168.0.118\n```\n\n重启网络服务\n```\nservice network restart\n```","categories":["技术博客","Linux"],"tags":["Linux","Centos7","VM","IP"]},{"title":"隐藏SSH版本号","url":"/posts/61156.html","content":"\n\n> [隐藏SSH版本信息](https://www.cnblogs.com/Hi-blog/p/How-To-Hide-SSH-Version.html)\n\n\n## 查看SSH的版本信息\n```\nsshd -v\n```\n![](./隐藏SSH版本号/Snipaste_2023-05-23_10-54-48.jpg)\n\n### 使用nmap外部扫描\n```\n#安装\nyum install -y nmap;\n```\n\n```\n#扫描指定ip的22端口\nnmap -p 22 -sV -v -n 192.168.116.129\n```\n\n![](./隐藏SSH版本号/Snipaste_2023-05-23_10-57-39.jpg)\n截图中是已修改后SSH版本信息 `X.X`\n\n## 备份文件、修改SSH版本信息\n\n查看sshd的文件位置\n```\nwhich sshd\n```\n\n备份\n```\ncp /usr/sbin/sshd /usr/sbin/sshd.bak\n```\n\n替换\n#格式语法：sed 's/原字符串/替换字符串/g'\n```\nsed -i 's/OpenSSH_7.4/OpenSSH_x.x/g' /usr/sbin/sshd\n```\n\n## 查看修改后的SSH的版本信息\n\n![](./隐藏SSH版本号/Snipaste_2023-05-23_11-05-17.jpg)\n\n【注】在替换版本的时候，如果替换为任意字符，可能会导致 core dump， 具体原因不明，可以参考上面的做法，隐藏具体版本信息即可。","categories":["技术博客","Linux"]},{"title":"MacBookPro2017安装win11系统","url":"/posts/54799.html","content":"\n\n>\n> 参考博客：[macOS 安装 Win11 常见问题及解决方案](https://www.bilibili.com/read/cv16325309)\n>\n> 关联文章：[Win11绕过TPM升级](/posts/30832.html)\n> \n> [Rufus工具官网](http://rufus.ie/zh/)\n\n\n## 流程简要记录\n1. mac下boot camp安装win10（最高支持win10）\n2. 使用`rufus`工具刷入Win11镜像到U盘\n3. mac开机进入win10系统，然后插入U盘升级系统\n\n## 先装win10在升级win11目的\n保留win10下的驱动，保证win11安装后系统驱动不缺失。\n\n## 踩坑记录\nmac开机option按住，选择`rufus`刷写的U盘，安装win11后，系统存在问题。\n\n系统问题\n- 无线网卡驱动缺失，有线网卡驱动正常（通过拓展坞外接网线方式）\n- 键盘驱动缺失，键盘失灵\n- 触摸板驱动缺失，触摸板失灵\n\n","categories":["技术博客","Mac"]},{"title":"MySQL事务隔离级别？默认是什么级别？","url":"/posts/30299.html","content":"\n\n> 参考博客：[MySQL事务隔离级别和实现原理](https://zhuanlan.zhihu.com/p/117476959)\n\n\n## 四种事务隔离级别\n- 读未提交 READ UNCOMMITTED\n- 读提交 READ COMMITTED\n- 可重复读 REPEATABLE READ\n- 串行化 SERIALIZABLE\n\n### MySQL的默认事务隔离级别\n`可重复读 REPEATABLE READ`\n\n## 不同事务隔离级别对脏读、不可重复读、幻读解决程度\n\n<table>\n<tr>\n<td>隔离级别</td><td>脏读</td><td>不可重复读</td><td>幻读</td>\n</tr>\n<tr>\n<td>读未提交</td><td>可能</td><td>可能</td><td>可能</td>\n</tr>\n<tr>\n<td>读提交</td><td>不可能</td><td>可能</td><td>可能</td>\n</tr>\n<tr>\n<td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td>\n</tr>\n<tr>\n<td>串行化</td><td>不可能</td><td>不可能</td><td>不可能</td>\n</tr>\n</table>\n","categories":["技术博客","MySQL"]},{"title":"MySQL数据库两种存储引擎的区别?","url":"/posts/65022.html","content":"\n> 参考博客：[Mysql的两种引擎的区别](https://blog.csdn.net/printwsl/article/details/80058841)\n\n\n\n简单区别介绍\n1. MyISAM是非事务安全的，而InnoDB是事务安全的\n2. MyISAM锁的粒度是表级的，而InnoDB支持行级锁\n3. MyISAM支持全文类型索引，而InnoDB不支持全文索引\n4. MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM\n5. MyISAM表保存成文件形式，跨平台使用更加方便\n\n应用场景\n1. MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM\n2. InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB","categories":["技术博客","MySQL"]},{"title":"MySQL数据库事务","url":"/posts/51105.html","content":"\n## 事务必须满足4个条件\n\n- A 原子性\n- C 一致性\n- I 隔离性\n- D 持久性\n\n### 原子性\n一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n### 一致性\n在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n\n### 隔离性 \n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n\n### 持久性\n事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n\n## MYSQL 事务处理主要有两种方法\n\n### 用 BEGIN, ROLLBACK, COMMIT来实现\n- BEGIN 开始一个事务\n- ROLLBACK 事务回滚\n- COMMIT 事务确认\n\n### 直接用 SET 来改变 MySQL 的自动提交模式\n- SET AUTOCOMMIT=0 禁止自动提交\n- SET AUTOCOMMIT=1 开启自动提交\n\n","categories":["技术博客","MySQL"]},{"title":"MySQL的那几个事务级别","url":"/posts/32391.html","content":"\n[MySQL 四种事务隔离级别详解介绍](https://blog.csdn.net/justlpf/article/details/106835122  )\n\nMySQL一共有4种事务隔离级别\n1. 读未提交 Read Uncommitted\n2. 读已提交 Read Committed\n3. 可重复读 Repeatable Read\n4. 可串行化 Serializable\n\n\n<table style='width:100%;'>\n<tr>\n<td>隔离级别</td><td>脏读</td><td>不可重复读</td><td>幻读</td>\n</tr>\n<tr>\n<td>Read Uncommitted</td><td> ✔️ </td><td>✔️</td><td>✔️</td>\n</tr>\n<tr>\n<td>Read Committed</td><td>❌</td><td>✔️</td><td>✔️</td>\n</tr>\n<tr>\n<td>Repeatable Read</td><td>❌</td><td>❌</td><td>✔️</td>\n</tr>\n<tr>\n<td>Serializable</td><td>❌</td><td>❌</td><td>❌</td>\n</tr>\n</table>\n","categories":["技术博客","MySQL"]},{"title":"Mysql的引擎","url":"/posts/56579.html","content":"\n> [MySQL常用的四种引擎的介绍](https://blog.csdn.net/ademoa/article/details/79900187)\n>\n> [MySQL常见的三种存储引擎](https://blog.csdn.net/liuyunshengsir/article/details/119387178)\n\n\n\n![](./Mysql的引擎/储存引擎对别.png) \n\n![](./Mysql的引擎/MyISAM和InnoDB对比.png)\n","categories":["技术博客","MySQL"]},{"title":"分库分表了解吗?","url":"/posts/42625.html","content":"\n> [Mysql分库分表实战（一）——一文搞懂Mysql数据库分库分表](https://blog.csdn.net/wdcl2468/article/details/102911160)\n\n## 数据拆分的方式\n- 垂直拆分\n  - 根据业务的维度，将原本一个库中的表拆分多个表，每个库中表与原有的结构不同\n- 水平拆分\n  -  根据分片算法，将一个库拆分成多个库，每个库依旧保留原有的结构\n\n\n## 分库分表方案\n### 客户端分片\n![](./分库分表了解吗/客户端分片.png)\n\n#### 客户端分片方式\n\n##### 在应用层直接实现\n这是一种非常通用的解决方案，直接在应用层读取分片规则，解析分片规则，根据分片规则实现切分的路由逻辑，从应用层直接决定每次操作应该使用哪个数据库实例中的对应的数据库\n\n优点:\n- 实现简单\n- 切片逻辑使自己开发的,遇到问题可以快速定位\n\n缺点:\n- 代码具有一定侵入性\n- 代码耦合度比较高\n- 数据库保持的连接会比较多\n\n##### 通过定制JDBC协议实现\n\n解决[方案一](#在应用层直接实现)中的代码耦合，通过定制JDBC协议来实现（主要是针对业务逻辑层提供与JDBC一致的接口），让分库分表在JDBC的内部实现\n\n目前当当网开源的框架：Sharding JDBC 就是使用这种解决方案来实现的\n\n##### 通过定制ORM框架实现\n通过定制ORM框架来实现分库分表方案，常见的有基于Mybatis的分库分表方案的解决\n\n```\n<select id=\"selectUser\" parameterType=\"java.util.Map\" resultType=\"User\">\n      select user_id as userId,user_name as userName\n      from user_#{index}\n      where user_id = #{userId}\n</select>\n```\n\n### 代理端分片\n代理分片就是在应用层和数据库层之间添加一个代理层，把分片的路由规则配置在代理层，代理层对外提供与JDBC兼容的接口给应用层，在业务实现之后，在代理层配置路由规则即可；\n\n![](./分库分表了解吗/代理分片.png)\n\n优点:\n- 开发人员专注业务逻辑实现,分库分表配置留给代理层处理\n\n缺点:\n- 增加代理层,数据库操作多了一层网络传输,一定的性能影响\n- 维护代理层,增加硬件成本\n- 线上环境出现问题,不能及时定位,需要一定技术专家处理\n\n\n### 支持事务的分布式数据库\n\n支持分布式事务的框架，目前有OceanBase、TiDB框架，这些框架将可伸缩特定和分布式事务的实现包装到了分布式数据库内部实现，对使用者透明，使用者不需要直接控制这些特性，但是对事务的支持不如关系型数据，适合大数据日志系统、统计系统、查询系统、社交网站等\n\n## 分库分表架构设计\n<table>\n<tr>\n  <td>拆分方式</td>\n  <td>优点</td>\n  <td>缺点</td>\n</tr>\n<tr>\n  <td>垂直拆分</td>\n  <td>\n  1. 拆分后业务清晰，拆分规则明确 <br/>\n  2. 系统之间进行整合或扩展容易 <br/>\n  3. 按照成本、应用等级、应用的类型等将表放到不同的机器上，便于管理 <br/>\n  4. 便于实现动静分离、冷热分离的数据库表的设计模式 <br/>\n  5. 数据维护简单\n  </td>\n  <td>\n  1. 部分业务表无法进行关联、只能通过接口的方式来解决，提高了系统的复杂度  <br/>\n  2. 受每种业务不同的限制，存在单库性能瓶颈，对数据扩展和性能提升不友好  <br/>\n  3. 事务处理复杂 <br/>  \n  </td>\n</tr>\n<tr>\n  <td>水平拆分</td>\n  <td>\n  1. 单库单表的数据保持一定的量级，有助于性能的提高 <br/>\n  2. 切分的表的结构相同，应用层改造较少，只需要增加路由规则即可 <br/>\n  3. 提高了系统的稳定性和负载能力 <br/>  \n  </td>\n  <td>\n  1. 切分后数据是分散的，很难利用数据库的关联查询，跨库查询性能较差  <br/>\n  2. 拆分规则难以抽象  <br/>\n  3. 分片数据的一致性难以解决  <br/> \n  4. 数据扩容的难度和维护量极大  <br/> \n  </td>\n</tr>\n</table>\n\n### 垂直拆分和水平拆分具有共同点\n- 存在分布式事务问题\n- 存在跨节点join的问题\n- 存在跨节点合并排序、分页的问题\n- 存在多数据源管理的问题\n\n垂直拆分更偏向于业务拆分的过程，在技术上我们更倾向于水平切分的方案；\n\n> TODO \n","categories":["技术博客","MySQL"]},{"title":"常见的SQL优化","url":"/posts/5829.html","content":"\n> [SQL优化常用的几种方法](https://blog.csdn.net/wangzheweini/article/details/107019426)\n\n## Mysql的SQL优化关键字\n`Explain`\n\n## 常见SQL优化规则\n1. 查询优化,尽量避免全表扫描.考虑`where`及`group by`建议索引\n2. 避免在`where`的语句中使用`!=`或`<>`操作符,否则引擎将放弃索引进行全表扫描\n3. 避免在`where`的语句中进行`null`值判断,否则引擎将放弃索引进行全表扫描\n```\n#例如:\nselect id from t where num is null\n```\n4. 避免在`where`的语句中使用`or`来连接条件,否则引擎将放弃索引进行全表扫描\n  \n```\n#例如: \nselect id from t where num=10 or num=20\n#优化:\nselect id from t where num=10 union all  select id from t where num=20\n```\n\n5. 避免在`where`的语句中使用`like`关键字, 否则引擎将放弃索引进行全表扫描\n```\n#例如:\nselect id from t where name like '%abc%'\n```  \n6. 避免在`where`的语句中使用`in`或者`not in`关键字,否则引擎将放弃索引进行全表扫描\n```\n#例如:\nselect id from t where num in(1,2,3)\n\n#优化:\n#查询的数值为连续值,可以使用`between`进行优化\nselect id from t where num between 1 and 3 \n```\n\n7. 避免在`where`的语句中进行表达式操作,否则引擎将放弃索引进行全表扫描\n```\n#例如:\nselect id from t where num/2=100\n#优化: \nselect id from t where num=100*2    \n```\n   \n8. 避免在`where`的语句中对字段进行函数操作,否则引擎将放弃索引进行全表扫描\n\n```\n#例如: \nselect id from t where substring(name,1,3)='abc'  \n#优化: \nselect id from t where name like 'abc%'    \n\n#例如: \nselect id from t where datediff(day,createdate,'2005-11-30')=0    \n#优化: \nselect id from t where createdate>='2005-11-30' and createdate<'2005-12-1'\n```\n   \n\n9. 很多时候用 exists 代替 in 是一个好的选择：\n```\n#例如: \nselect num from a where num in(select num from b)\n#优化: \nselect num from a where exists(select 1 from b where num=a.num)\n```\n\n10. 任何地方都不要使用 `select * from t` ，用具体的字段列表代替`*`，不要返回用不到的任何字段  \n\n\n## 其他补充:\n\n1. **并不是所有索引对查询都有效**\nSQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引\n\n2. **索引并不是越多越好**\n索引固然可以提高相应的`select`的效率，但同时也降低了`insert`及`update`的效率，因为`insert`或`update`时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过`6`个，若太多则应考虑一些不常使用到的列上建的索引是否有必要\n\n3. **不要在 `where` 子句中的`=`左边进行函数、算术运算或其他表达式运算**\n否则系统将可能无法正确使用索引\n   \n\n4. **使用复合索引注意**   \n必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致","categories":["技术博客","MySQL"]},{"title":"强制sql使用一个索引","url":"/posts/31049.html","content":"\n> [强制sql使用一个索引](https://blog.csdn.net/muskter/article/details/79052884)\n\n## use index 建议使用索引\n> 最后到底是用不用, 还是由MySQL来决定\n>\n```\nexplain \nselect count(*) from vipshop_finance_account use INDEX(idx_user_id) \n```\n\n\n## ignore  index 忽略使用索引\n```\nexplain \nselect count(*) from vipshop_finance_account IGNORE INDEX( idx_open_wpb_status);\n```\n\n## force index 强制使用索引\n> 强制MySQL去使用这个索引. 如果用不上, 就全表. \n> \n> 如果能用上, 就一定会使用该索引\n\n```\nSELECT * from vipshop_trade_log FORCE INDEX (idx_related_tradeid) where related_tradeId>'004201509151046563846447';\n```","categories":["技术博客","MySQL"]},{"title":"我一个亿的订单数据，我要去怎么去设计这个表?","url":"/posts/28159.html","content":"","categories":["技术博客","MySQL"]},{"title":"Nginx漏扫响应头缺失问题处理","url":"/posts/42494.html","content":"\n> 主要参考博客（部分其他内容其他来源）： [nginx漏扫响应头缺失](https://blog.csdn.net/haoqi9999/article/details/123271036)\n\n## 检测到目标X-Content-Type-Options响应头缺失\n\n```\nadd_header X-Content-Type-Options nosniff;\n```\n\n## 检测到目标X-XSS-Protection响应头缺失\n\n```\nadd_header X-XSS-Protection \"1; mode=block\";\n```\n## 检测到目标Content-Security-Policy响应头缺失\n\n> [由“Content-Security-Policy“头缺失引起的总结](https://blog.csdn.net/guo15890025019/article/details/123179250)\n>\n> [HTTP Content-Security-Policy缺失，快速解决](https://blog.csdn.net/kzhzhang/article/details/116451031)\n\n**暂时不予处理、未正确配置可能导致线上js/css等资源访问异常情况发生**\n\n\n## 检测到目标服务器启用了OPTIONS方法\n\n> [OPTIONS 漏洞修复](https://blog.csdn.net/achi010/article/details/125137940)\n>\n\n```\n    location / {\n        ##### 只增加这里的配置，其他配置为默认 #####\n        ##### 增加支持 OPTIONS 方法 #####\n        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n        ##### 增加 OPTIONS 方法的返回结果 #####\n        if ($request_method = 'OPTIONS') {\n            return 204;\n        }\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n```\n\n## 检测到目标Strict-Transport-Security响应头缺失\n\n```\nadd_header Strict-Transport-Security \"max-age=63072000; includeSubdomains; preload\";\n```\n\n## 检测到目标Referrer-Policy响应头缺失\n\n```\nadd_header 'Referrer-Policy' 'origin'; \n```\n\n## 检测到目标X-Permitted-Cross-Domain-Policies响应头缺失\n\n```\nadd_header X-Permitted-Cross-Domain-Policies master-only;\n```\n\n## 检测到目标X-Download-Options响应头缺失\n\n```\nadd_header X-Download-Options \"noopen\" always;\n```\n## 点击劫持：X-Frame-Options未配置\n\n```\nadd_header X-Frame-Options SAMEORIGIN;\n```\n","categories":["技术博客","Nginx"],"tags":["Nginx"]},{"title":"Docker下安装Redis并持久化设置","url":"/posts/25512.html","content":"\n\n\n> [Docker安装redis，并设置持久化详细教程](https://blog.csdn.net/qq_44697728/article/details/114577248)\n>\n> [docker安装指定版本TAG的镜像](https://www.cnblogs.com/wztone/p/10557486.html)\n>\n> [Redis的历史版本下载](http://download.redis.io/releases/)\n>\n> [docker安装redis](https://blog.csdn.net/m0_55070913/article/details/126628271)\n>\n> [Docker安装最新Redis6（redis-6.2.7）（参考官方文档）](https://blog.csdn.net/u014282578/article/details/128223953)\n\n---\n\n# 镜像下载\n## 拉取镜像\n\n拉取最新版本镜像\n```\ndocker pull redis;\n```\n\n拉取指定版本镜像\n```\ndocker pull redis:6.2.0;\n```\n\n## 已拉取镜像\n```\ndocker images;\n```\n\n\n+++ **获取指定版本TAG镜像**\n[hub.docker.com](https://hub.docker.com/)\n\n![](./Docker下安装Redis并持久化设置/Snipaste_2023-06-18_08-37-38.png)\n\n![](./Docker下安装Redis并持久化设置/Snipaste_2023-06-18_08-38-40.png)\n+++\n\n\n\n# 创建实例并启动\n\n\n\n创建配置文件目录\n```\nmkdir -p /home/docker/redis/conf\n```\n\n按`redis`版本下载对应`redis.conf`配置文件\n```\nhttps://redis.io/docs/management/config/\n```\n![](./Docker下安装Redis并持久化设置/Snipaste_2023-06-18_09-23-32.png)\n\n修改配置\n```\nvi /home/docker/redis/conf/redis.conf\n```\n\n> 大坑注意：\n> > daemonize no #不要修改，否则启动失败且无日志可查 \n\n推荐修改配置\n```\n#bind 127.0.0.1 -::1 #注释，解除本地连接限制\nprotected-mode no    #保护模式，限制为本地访问，修改后解除保护模式\nrequirepass 123456   #设置访问密码\nappendonly yes       #开启持久化\n```\n\n\n持久化配置参数\n> [博客内链|Reids持久化详解](/posts/6387.html)\n- appendfilename \"appendonly.aof\" #生成文件名称 (默认)\n- appendfsync everysec #日志追加频率-每秒 (默认)\n\n\n\n\n## 启动容器\n\n```\ndocker run -d \\\n-p 6379:6379 \\\n--name redis \\\n--privileged=true \\\n--restart=always  \\\n-v /home/docker/redis/data:/data \\\n-v /home/docker/redis/conf/redis.conf:/etc/redis/redis.conf \\\nredis:6.2.0 \\\nredis-server /etc/redis/redis.conf\n```\n\n\n## 移除容器\n```\ndocker rm 名称or镜像id;\n```\n\n# 实例启动成功\n\n## 命令查看\n```\ndocker ps ; #查看成功运行的容器\ndocker ps -a ; #查看所有容器\n```\n![](./Docker下安装Redis并持久化设置/Snipaste_2023-05-05_08-21-33.jpg)\n\n\n \n\n  \n# 错误记录\n\n## 错误01\n解决方案:\n> [docker 报错 /usr/bin/docker-current: Error response from daemon: driver failed programming external](https://blog.csdn.net/whatday/article/details/103929867)\n\n解决命令:\n```\n#重启docker进程\nsystemctl restart docker\n```\n\n错误信息:\n```\n/usr/bin/docker-current: Error response from daemon: driver failed programming external connectivity on endpoint redis (72144e08d14644cf8b86282112928608afcbfa1feff8ab1450a784e2c504ab2c):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 6379 -j DNAT --to-destination 172.17.0.2:6379 ! -i docker0: iptables: No chain/target/match by that name.\n```\n\n![](./Docker下安装Redis并持久化设置/Snipaste_2023-05-05_08-03-22.jpg)\n\n\n问题原因(我确实有关闭firewall进程这一步操作):\n![](./Docker下安装Redis并持久化设置/Snipaste_2023-05-05_08-10-45.jpg)\n\n\n## 错误02\n\n> redis.conf文件要与redis的版本一致，如果下载不对应的配置文件时，部分属性会报错。\n\n\n```\n>>> 'repl-diskless-sync-max-replicas 0'\nBad directive or wrong number of arguments\n```\n\n\n\ndocker下查看容器的redis版本号信息\n\n```\ndocker exec -it 容器名称 redis-server -v\n```\n\n打印如下信息：\nRedis `server v=6.2.6` sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=b61f37314a089f19\n\n指定redis版本配置文件下载：\n官方地址：https://redis.io/topics/config/\n","categories":["技术博客","Redis"],"tags":["Docker","Redis"]},{"title":"Redis实现分布式锁","url":"/posts/2567.html","content":"\n\n> 参考博客：[Redis实现分布式锁](https://blog.csdn.net/weixin_46129192/article/details/126010250)\n>\n> 参考博客：[Redlock（redis分布式锁）原理分析](https://blog.csdn.net/lisheng19870305/article/details/122464924)\n\nRedis的常用部署方式：单节点模式、主从模式、哨兵模式、集群模式；\n\n\n","categories":["技术博客","Redis"]},{"title":"Redis的缓存击穿、穿透、雪崩","url":"/posts/17397.html","content":"\n> [Redis详解（十二）------ 缓存穿透、缓存击穿、缓存雪崩](https://zhuanlan.zhihu.com/p/148837265)\n>\n\n\n## 缓存穿透\n缓存和数据库中都没有的数据，可用户还是源源不断的发起请求，导致每次请求都会到数据库，从而压垮数据库。\n\n解决方式：\n1. 业务层校验： 对于参数明显错误的直接拒绝；\n2. 查询不存在数据设置短时间过期；\n3. 布隆过滤器；\n\n## 缓存击穿\nRedis中一个热点key在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。\n\n解决方式：\n1. 热点key 永不过期；\n2. 定时更新；热点key过期时间1h，设置59分钟时进行更新；\n3. 互斥锁\n\n## 缓存雪崩\n\nRedis中缓存的数据大面积同时失效，或者Redis宕机，从而会导致大量请求直接到数据库，压垮数据库。\n\n解决方式：\n1. 单机环境，防止redis宕机可使用redis集群（哨兵、集群）；\n2. 设置key过期时间的有效均匀分布；\n3. 数据预热，提前将可能使用数据保存缓存中；\n","categories":["技术博客","Redis"]},{"title":"Reids的持久化详解","url":"/posts/6387.html","content":"\n\n> [redis持久化详解](https://blog.csdn.net/qq_45722267/article/details/124525345)\n\n\n## Redis持久化机制\n- RDB (默认机制)\n- AOF\n\n## RDB (快照)\n按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。\n\n### 生成快照方式\n- 客户端方式\n  - BGSAVE 和 SAVE指令\n- 服务端方式\n  - 服务器配置自动触发 和 shutdown\n\n#### 客户端方式\n1. **BGSAVE**\n   客户端可以使用BGSAVE命令来创建一个快照，当接收到客户端的BGSAVE命令时，redis会创建一个子进程，子进程负责将快照写入磁盘中，而父进程继续处理命令请求。（在子进程创建之初，父子进程共享相同内存，知道父进程或子进程对内存进行了写之后，对于被写入的内存的共享就会结束服务）\n2. **SAVE**\n   客户端使用SAVE命令创建一个快照，接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令。\n\n#### 服务端方式\n1. 配置文件持久化\n   服务器通过配置方式来满足自动触发快照进行持久化，管理员需要在redis.conf中设置save配置选项，redis会在save选项条件满足之后自动触发一次BGSAVE命令，如果管理员设置了多个save配置选项，当任意save条件被满足，redis都会触发一次BGSAVE命令。\n2. shutdown指令\n    当redis通过shutdown指令接受到关闭服务器的请求时，会触发一次SAVE命令，阻塞所有的客户端，不再执行客户端发送的任何命令，在SAVE命令执行完毕后关闭服务器。\n\n### 优缺点\n#### 优点\n1. **文件单一**: 只有一个dump.rdb文件，方便持久化\n2. **容灾性好**: 一个文件可以保存到安全的磁盘中。\n3. **性能最大化**: 子进程来完成写操作，主进程可以继续处理命令，实现IO最大化（使用单独的子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能）。\n4. **启动效率高**: 相对于数据集大时，比AOF的启动效率更高。\n\n#### 缺点\n1. **数据安全性低**: RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。\n2. **版本兼容问题**: dump.rdb文件是一个redis中特制的二进制文件，涉及到不同的redis版本，可能会发生版本不兼容问题。\n\n\n## AOF (追加日志文件)\n将redis执行的所有写命令记录到日志文件中，将被执行的写命令写到AOF的文件末尾。\n\n当redis重启时，redis会从头到尾执行一次AOF文件所包含的所有写命令，以此恢复AOF文件的记录的数据集。\n\n\n### 开启AOF持久化\nredis默认配置中AOF持久化机制是不开启的，需要在配置中开启。\n\n修改redis.conf配置文件:\n```\n#开启持久化\nappendonly yes \n#指定生成文件名称\nappendfilename \"appendonly.aof\"\n```\n\n#### 设置日志追加频率\n\n**修改redis.conf配置文件同步频率**\n```\nappendfsync everysec\n```\n\n同步频率包括:\n- always \n- everysec (推荐)\n- no\n\n**always**\n说明: 每个redis写命令都要同步写入硬盘，严重降低redis速度\n解释: 如果用户使用了always选项，会将发生系统崩溃时出现的数据丢失减到最少，但因为这种同步策略需要对硬盘进行大量的写入操作，所以redis处理命令的速度会受到硬盘性能的限制。\n注意: 使用固态硬盘（SSD）时需谨慎使用always选项，这种模式不断写入少量数据，可能会引发严重的写入放大问题，导致固态硬盘的寿命从原来的几年降低为几个月。\n\n**everysec**\n说明：每秒执行一次的同步显示，将多个写命令同步到磁盘\n解释：同时保障了数据安全和写入性能，redis每秒一次对AOF文件进行同步，此时AOF文件性能和不使用任何持久化特性时的性能基本相同；通过每秒同步一次AOF文件，redis可以保证，即使系统崩溃，最多丢失一秒之内产生的数据。\n\n**no**\n说明：由操作系统决定何时同步\n解释：这个选项不好对redis性能带来影响，但是当系统宕机时，丢失的数据量具有不确定性；另外，如果用户硬盘处理写入操作不够快，当缓冲区被等待写入硬盘数据填满时，redis会处于阻塞状态，导致redis的处理命令请求速度变慢。\n\n#### AOF重写\nAOF文件是以追加的方式记录接收到的写命令的，不断的追加会导致AOF文件过大。\n\n**文件过大导致的问题：**\n1. **文件系统的限制**：文件系统本身对文件的大小有限制，无法保存过大文件，如果超出限制，会导致 redis 宕机，redis 执行命令速度会降低。\n2. **追加效率降低**：AOF文件采用追加的方式写入文件，每次要遍历寻找到文件尾部，如果文件过大，追加效率会大幅度降低。\n3. **执行效率降低**：如果服务器发生宕机，AOF文件命令要逐一执行，文件过大导致执行内容过多，影响效率。\n\n**AOF重写：用来一定程度上减小AOF文件的体积，解决文件过大的问题。**\n\n#### 触发重写方式\n- 客户端方式\n- 服务器配置文件自动触发方式\n \n\n**客户端方式:**\n```\n执行BGREWRITEAOF命令 不会阻塞redis服务\n```\n\n**服务器配置文件自动方式:**\n\n修改redis.conf配置文件:\n```\n#表示AOF写入文件大小大于64m才能触发重写操作。\nauto-aof-rewrite-min-size 64mb \n#100表示百分比，表示AOF文件的体积比上一次重写之后体积至少大了 “100%” 时会自动触发。\nauto-aof-rewrite-percentage 100\n```\n\n##### 重写原理\n1. 重写AOF的时候，创建一个重写子进程，然后读取旧的AOF文件，压缩并写入到一个临时AOF。\n2. 在此期间，主进程一边将接收到的指令累计到一个缓冲区中，一边将指令写入到旧的AOF。\n3. 子进程写完后，向主进程发送一个信号量，主进程就将缓冲区中的指令追加到新AOF。\n4. 用新的AOF替换旧的AOF，之后的新指令就追加到新的AOF。\n\n\n### 优缺点\n\n#### 优点\n1. **数据安全**: AOF持久化可以通过配置appendfsync属性，设置其记录频率。\n2. **数据一致**: 通过append模式写文件，即使服务器宕机，也可以通过redis-check-aof工具解决数据一致问题。\n3. **灵活**。AOF机制的 rewrite 模式，AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令。\n\n#### 缺点\n1. **恢复速度慢**: AOF文件比RDB文件更大，且恢复速度更慢。\n2. **效率低**: 数据集大时，AOF比RDB启动效率低。\n\n\n**当RDB和AOF同时开启时，redis数据恢复会优先选中 <font color = 'red'>AOF</font> 恢复。**\n\n\n","categories":["技术博客","Redis"],"tags":["AOF","RDB"]},{"title":"redis是线程安全的吗?","url":"/posts/9984.html","content":"\n> [Redis线程安全问题](https://blog.csdn.net/diweikang/article/details/90264993)\n\n## Redis线程使安全的吗?\n> redis是单线程程序,线程是安全的\n\n## Redis单线程为什么这么快?\n- Redis是基于内存,内存的读写速度快\n- Redis是单线程,避免了不必要的上下文切换和竞争条件\n- Redis使用多路复用技术，可以处理并发的连接\n\n## Redis可能存在的瓶颈?\n- 机器内存大小或网络宽带","categories":["技术博客","Redis"]},{"title":"redis的常用数据结构及使用场景?","url":"/posts/31486.html","content":"\n> [redis的常用数据结构及使用场景](https://blog.csdn.net/qq_45076180/article/details/109458668)\n\n## String的使用场景\n- 普通数据/对象缓存\n- 分布式锁\n- 计数器\n- 分布式系统全局序列号\n\n![](./redis的常用数据结构及使用场景/redis-string应用场景.png)\n\n## Hash的使用场景\n> [Redis数据结构Hash应用场景-存储商品、购物车、淘宝短链接、分布式Session、用户注册、发微博功能](https://blog.csdn.net/yaoyaochengxian/article/details/120234850#_417)\n- 购物车\n  - 用户id为key\n  - 商品id为field\n  - 商品count为value\n\n### 示例\n#### 往购物车加入2件商品\n> key = cart:user:用户id\n```\nvm01:0>hset cart:user:1000 101 1\n\"1\"\nvm01:0>hset cart:user:1000 102 1\n\"1\"\nvm01:0>hgetall cart:user:1000 \n 1)  \"101\"\n 2)  \"1\"\n 3)  \"102\"\n 4)  \"1\"\nvm01:0>\n```\n#### 修改购物车数据,增加商品数量\n```\nvm01:0>hincrby cart:user:1000 101 1\n\"2\"\nvm01:0>hincrby cart:user:1000 102 10\n\"11\"\nvm01:0>hgetall cart:user:1000\n 1)  \"101\"\n 2)  \"2\"\n 3)  \"102\"\n 4)  \"11\"\nvm01:0>\n```\n#### 统计购物车商品\n```\nvm01:0>hlen cart:user:1000\n\"2\"\nvm01:0>\n``` \n\n#### 删除购物车商品\n```\nvm01:0>hdel cart:user:1000 101\n\"1\"\nvm01:0>hgetall cart:user:1000\n 1)  \"102\"\n 2)  \"11\"\nvm01:0>\n```\n\n## List的使用场景\n> [Redis的List的应用场景](https://blog.csdn.net/weixin_42119753/article/details/102422068)\n- 消息队列\n  - `lpush` + `brpop`命令组合即可实现阻塞队列，生产者客户端使用`lpush`从列表左侧插入元素，多个消费者客户端使用`brpop`命令阻塞式的争抢列表尾部的元素，多个客户端保证了消费的负载均衡和高可用\n- 朋友圈点赞列表\\评论列表\n  - `lpush`命令和`lrange`命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过`lrange`命令读取最新的元素列表\n- 栈\n  - 通过(`lpush` `lpop`左边进左边出，或`rpush` `rpop` 右边进右边出），先进后出原则\n\n### 消息队列\n\n生产者: 消息队列中新增数据\n```\nvm01:0>lpush list 1\n\"1\"\nvm01:0>llen list\n\"1\"\nvm01:0>\n```\n\n消费者: 从消息队列中消费数据\n```\nvm01:0>brpop list 0 #超时时间0表示一直等待,直到争抢到尾部元素\n 1)  \"list\"\n 2)  \"1\"\nvm01:0>\n```\n生产者: 查询队列中数据\n```\nvm01:0>llen list\n\"0\"\nvm01:0>\n```\n\n\n### 朋友圈点赞/评论列表\n\n点赞/评论数据新增:\n```\nvm01:0>lpush list 1\n\"1\"\nvm01:0>lpush list 2\n\"2\"\nvm01:0>lpush list 3\n\"3\"\nvm01:0>lpush list 4\n\"4\"\nvm01:0>llen list\n\"4\"\nvm01:0>\n```\n\n获取最新的点赞/评论数据:\n```\nvm01:0>lrange list 0 10\n 1)  \"4\"\n 2)  \"3\"\n 3)  \"2\"\n 4)  \"1\"\nvm01:0>\n```\n\n### 栈\n> 用朋友圈点赞/评论数据\n\n**满足FIFO(先进先出\\后进后出)顺序**\n\n栈-入:\n```\nvm01:0>lpush list 1\n\"1\"\nvm01:0>lpush list 2\n\"2\"\nvm01:0>lpush list 3\n\"3\"\nvm01:0>lpush list 4\n\"4\"\nvm01:0>llen list\n\"4\"\nvm01:0>\n```\n\n栈-出:\n```\nvm01:0>lrange list 0 10\n 1)  \"4\"\n 2)  \"3\"\n 3)  \"2\"\n 4)  \"1\"\nvm01:0>lpop list\n\"4\"\nvm01:0>lpop list\n\"3\"\nvm01:0>lpop list\n\"2\"\nvm01:0>lpop list\n\"1\"\nvm01:0>\n```\n\n## Set的使用场景\n- 点赞\n- 抽奖\n- 关注模型(共同好友\\推荐好友)\n\n### 点赞\n\n> key = prize:{消息id}\n\n点赞数据新增:\n```\nvm01:0>sadd prize:id_1 小王\n\"1\"\nvm01:0>sadd prize:id_1 小李\n\"1\"\nvm01:0>sadd prize:id_1 小赵\n\"1\"\nvm01:0>\n```\n\n获取点赞人数统计:\n```\nvm01:0>scard prize:id_1\n\"3\"\nvm01:0>\n\n```\n\n### 抽奖\n\n抽奖用户数据新增\n```\nvm01:0>SADD prize 小王\n\"1\"\nvm01:0>SADD prize 小李\n\"1\"\nvm01:0>SADD prize 小黑\n\"1\"\nvm01:0>\n```\n\n获取参与抽奖所有用户\n```\nvm01:0>smembers prize\n 1)  \"小李\"\n 2)  \"小王\"\n 3)  \"小黑\"\nvm01:0>\n```\n\n随机获取两个抽奖用户\n```\nvm01:0>srandmember prize 2\n 1)  \"小李\"\n 2)  \"小黑\"\nvm01:0>\n```\n随机获取一个抽奖用户并删除记录\n```\nvm01:0>smembers prize\n 1)  \"小李\"\n 2)  \"小王\"\n 3)  \"小黑\"\nvm01:0>spop prize \n\"小李\"\nvm01:0>smembers prize\n 1)  \"小王\"\n 2)  \"小黑\"\nvm01:0>\n```\n\n\n### 关注模型\n\n新增用户好友数据:\n```\nvm01:0>sadd A 小李 小王 小赵\n\"3\"\nvm01:0>sadd B 小李 小白 小黑\n\"3\"\nvm01:0>\n```\n\n#### 共同好友\n```\nvm01:0>sinter A B\n 1)  \"小李\"\nvm01:0>\n```\n\n#### 推荐好友\n```\nvm01:0>sdiff A B\n 1)  \"小王\"\n 2)  \"小赵\"\n vm01:0>\n```\n\n\n\n## Zset使用场景\n\n- 实现热搜排行榜\n\n> key 不能重复, score 可以重复\n\n添加热搜数据\n```\nvm01:0>zadd hot 1 redis\n\"1\"\nvm01:0>zadd hot 1 mongodb\n\"1\"\nvm01:0>\n```\n\n模拟点击热搜提升数值\n```\nvm01:0>ZINCRBY hot 1 mongodb\n\"2\"\nvm01:0>\n```\n\n根据热搜数值排行榜0-10区间 -> 大>小 (热搜排行榜)\n```\nvm01:0>zrevrange hot 0 10 \n 1)  \"mongodb\"\n 2)  \"redis\"\nvm01:0>zrevrange hot 0 10 withscores\n 1)  \"mongodb\"\n 2)  \"2\"\n 3)  \"redis\"\n 4)  \"1\"\nvm01:0>\n```\n+++ **点击显示/隐藏(小>大)**\n根据热搜数值排行榜0-10区间 -> 小>大\n```\nvm01:0>zrange hot 0 10\n 1)  \"redis\"\n 2)  \"mongodb\"\nvm01:0>zrange hot 0 10 withscores\n 1)  \"redis\"\n 2)  \"1\"\n 3)  \"mongodb\"\n 4)  \"2\"\nvm01:0>\n```\n+++\n\n补充-指定区间范围的热搜:\n![](./redis的常用数据结构及使用场景/Snipaste_2023-05-08_21-45-55.jpg \"https://blog.csdn.net/qq_22075913/article/details/106868900\")\n\n","categories":["技术博客","Redis"]},{"title":"redis的数据结构您知道都有哪些?","url":"/posts/13537.html","content":"\n## Redis的数据结构\n- String\n- List\n- Hash\n- Set\n- ZSet\n","categories":["技术博客","Redis"]},{"title":"Tomcat安装部署常规配置","url":"/posts/19881.html","content":"\n## Tomcat配置优化\n\n### 修改`server.xml`\n\n> [Tomcat 8.5 安全配置与高并发优化](https://www.cnblogs.com/opma/p/11712314.html)\n\n默认配置\n```\n\n<Connector \n   port=\"8080\" \n   protocol=\"HTTP/1.1\" \n   connectionTimeout=\"20000\" \n   redirectPort=\"8443\" \n/>\n\n```\n\n优化配置\n```\n # 用此项配置 protocol=\"org.apache.coyote.http11.Http11Nio2Protocol\"启动时会有警告\n # 警告 [main] org.apache.tomcat.util.net.Nio2Endpoint.bind The NIO2 connector requires an exclusive executor to operate properly on shutdown\n\n<Connector \n  executor=\"tomcatThreadPool\"\n  port=\"8080\" \n  protocol=\"org.apache.coyote.http11.Http11NioProtocol\" \n  connectionTimeout=\"40000\" \n  maxConnections=\"10000\" \n  redirectPort=\"8443\" \n  enableLookups=\"false\" \n  acceptCount=\"100\" \n  maxPostSize=\"10485760\" \n  compression=\"on\" \n  disableUploadTimeout=\"true\" \n  compressionMinSize=\"2048\" \n  acceptorThreadCount=\"2\" \n  compressableMimeType=\"text/html,text/xml,text/plain,text/css,text/javascript,application/javascript\" \n  maxHttpHeaderSize=\"8192\"\n  processorCache=\"20000\"\n  tcpNoDelay=\"true\"\n  connectionLinger=\"5\"\n  server=\"Server Version 11.0\"\n  URIEncoding=\"utf-8\"\n/>\n```\n\n优化配置升级(连接池)\n> 未配置`APR`可使用`org.apache.coyote.http11.Http11NioProtocol`\n\n```\n\n<Executor name=\"tomcatThreadPool\" \n                namePrefix=\"catalina-exec-\" \n                maxThreads=\"800\" \n                minSpareThreads=\"100\"\n                maxSpareThreads=\"500\"\n                prestartminSpareThreads=\"true\"\n                maxQueueSize=\"200\" \n                maxIdleTime=\"30000\"\n        />\n\t\t\n\t\t<Connector  executor=\"tomcatThreadPool\"\n               port=\"8081\" \n               URIEncoding=\"UTF-8\"\n               protocol=\"org.apache.coyote.http11.Http11AprProtocol\"\n               connectionTimeout=\"10000\"\n               acceptCount=\"200\"\n               acceptorThreadCount=\"2\"         \n               maxConnections=\"8192\"          \n               enableLookups=\"false\"\n               redirectPort=\"8443\"\n               server=\" \"\n               compression=\"on\" \n               compressableMimeType=\"text/html,text/xml,text/plain,text/css,text/javascript,application/javascript\"\n        />\n```\n\n\n#### 配置对照\n```\nprotocol，Tomcat 8 设置 nio2 更好：org.apache.coyote.http11.Http11Nio2Protocol（如果这个用不了，就用下面那个）\nprotocol，Tomcat 6、7 设置 nio 更好：org.apache.coyote.http11.Http11NioProtocol\nenableLookups，禁用DNS查询\nacceptCount，指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认设置 100\nmaxPostSize，以 FORM URL 参数方式的 POST 提交方式，限制提交最大的大小，默认是 2097152(2兆)，它使用的单位是字节。10485760 为 10M。如果要禁用限制，则可以设置为 -1。\nmaxPostSize：设置由容器解析的URL参数的最大长度，-1(小于0)为禁用这个属性，默认为2097152(2M) 请注意， FailedRequestFilter 过滤器可以用来拒绝达到了极限值的请求。\nacceptorThreadCount，用于接收连接的线程的数量，默认值是1。一般这个指需要改动的时候是因为该服务器是一个多核CPU，如果是多核 CPU 一般配置为 2.\nacceptorThreadCount：用于接受连接的线程数量。增加这个值在多CPU的机器上,尽管你永远不会真正需要超过2。 也有很多非维持连接,您可能希望增加这个值。默认值是1。\nconnectionTimeout：Connector接受一个连接后等待的时间(milliseconds)，默认值是60000。\nmaxConnections：这个值表示最多可以有多少个socket连接到tomcat上\nmaxHttpHeaderSize：http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。\ncompression：是否启用GZIP压缩 on为启用（文本数据压缩） off为不启用， force 压缩所有数据\ndisableUploadTimeout：这个标志允许servlet容器使用一个不同的,通常长在数据上传连接超时。 如果不指定,这个属性被设置为true,表示禁用该时间超时。\ncompressionMinSize：当超过最小数据大小才进行压缩\ncompressableMimeType：配置想压缩的数据类型\nURIEncoding：网站一般采用UTF-8作为默认编码。\nprocessorCache：协议处理器缓存的处理器对象来提高性能。 该设置决定多少这些对象的缓存。-1意味着无限的,默认是200。 如果不使用Servlet 3.0异步处理,默认是使用一样的maxThreads设置。                 如果使用Servlet 3.0异步处理,默认是使用大maxThreads和预期的并发请求的最大数量(同步和异步)。\ntcpNoDelay：如果设置为true,TCP_NO_DELAY选项将被设置在服务器套接字,而在大多数情况下提高性能。这是默认设置为true。\nconnectionLinger：秒数在这个连接器将持续使用的套接字时关闭。默认值是 -1,禁用socket 延迟时间。\nserver：隐藏Tomcat版本信息，首先隐藏HTTP头中的版本信息\n```\n\n\n### 禁用 AJP\n> Tomcat8.5.88 当前教程版本中是默认关闭`AJP`的\n\n```\n<!-- <Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /> -->\n```\n\n### 隐藏 Tomcat 版本号\n\n```\ncd /usr/local/tomcat/lib/\n```\n\n```\nunzip catalina.jar\n```\n\n```\ncd org/apache/catalina/util\n```\n\n```\nvim ServerInfo.properties\n```\n\n``` \n#server.info=Apache Tomcat/8.5.16\n#server.number=8.5.16.0\n#server.built=Jun 21 2017 17:01:09 UTC\n\nserver.info=\nserver.number=\nserver.built=\n```\n\n## 设置环境`setenv.sh`\n\n> 注意：若配置一台服务器多个Tomcat，其他Tomcat的`setenv.sh`中'$CATALINA_BASE'也需要修改!\n\n```\n#Java环境（如果存在多个jdk环境需要指定、默认可以不配置）\n#JAVA_HOME=/usr/local/jdk1.8.0_181\n\n#配置tomcat启动后将进程号保存至 ./bin/tomcat.pid 文件\nCATALINA_PID=\"$CATALINA_BASE/tomcat.pid\"\n\n#添加JAVA启动变量配置\n### 末尾可添加针对开启jspAgent配置： -javaagent:/usr/local/services/tomcat_8.5.88/8084/jspAgent/JSPAgent.jar ###\n\n##默认一般jdk启动配置参数\n##JAVA_OPTS=\"-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m\"\n##修改后的jdk启动配置参数（APR模式）\n##JAVA_OPTS=\"-Djava.io.tmpdir=/tmp -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -XX:+TieredCompilation -Xms8192m -Xmx8192m -XX:NewSize=6144m -XX:MaxNewSize=6144m -XX:PermSize=512m -XX:MaxPermSize=512m -XX:ReservedCodeCacheSize=512M -XX:SurvivorRatio=8 -XX:ParallelGCThreads=8 -XX:+UseAdaptiveSizePolicy -XX:+UseCompressedOops -XX:+UseBiasedLocking -XX:+UseParNewGC  -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -XX:+CMSParallelRemarkEnabled -XX:+CMSParallelInitialMarkEnabled -XX:CMSInitiatingOccupancyFraction=70  -XX:+PrintCommandLineFlags -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -Xloggc:/root/gc.$$.log -Djava.library.path=/usr/local/apr/lib\"\n##修改后的jdk启动配置参数（非APR模式）\nJAVA_OPTS=\"-Djava.io.tmpdir=/tmp -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -XX:+TieredCompilation -Xms8192m -Xmx8192m -XX:NewSize=6144m -XX:MaxNewSize=6144m -XX:PermSize=512m -XX:MaxPermSize=512m -XX:ReservedCodeCacheSize=512M -XX:SurvivorRatio=8 -XX:ParallelGCThreads=8 -XX:+UseAdaptiveSizePolicy -XX:+UseCompressedOops -XX:+UseBiasedLocking -XX:+UseParNewGC  -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -XX:+CMSParallelRemarkEnabled -XX:+CMSParallelInitialMarkEnabled -XX:CMSInitiatingOccupancyFraction=70  -XX:+PrintCommandLineFlags -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -Xloggc:../logs/gclogs/gc.$$.log\"\n```\n\n## 日志按日分割\n\n在`bin`目录下创建`back_catalina_out.sh`\n\n```\nvim back_catalina_out.sh\n```\n\n脚本内容\n```\n#!/bin/bash\n#tomcat日志目录\nlog_path=/usr/local/services/tomcat_8.5.88/8081/logs\nd=`date +%Y-%m-%d`\nd30=`date -d'30 day ago' +%Y-%m-%d`\ncd ${log_path} && cp catalina.out $log_path/catalina.out.$d.log\necho > catalina.out\nrm -rf $log_path/catalina.out.${d30}.log\n```\n\n赋予执行权限\n```\nchmod u+x back_catalina_out.sh\n```\n\n添加`corn`系统定时任务\n```\n0 0 * * * /usr/local/services/tomcat_8.5.88/8081/bin/back_catalina_out.sh\n```\n\n## 配置Tomcat随系统启动\n\n新增配置文件\n```\nvi /usr/lib/systemd/system/tomcat8.service\n```\n\n文件内容\n```\n[Unit]\nDescription=Tomcat\nAfter=syslog.target network.target remote-fs.target nss-lookup.target\n\n[Service]\nType=oneshot\n#Tomcat的目录地址\nExecStart=/usr/local/services/tomcat_8.5.88/8081/bin/startup.sh \nExecStop=/usr/local/services/tomcat_8.5.88/8081/bin/shutdown.sh\nExecReload=/bin/kill -s HUP $MAINPID\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\n设置开机启动\n```\nsystemctl enable tomcat8\n```\n\n常见命令\n```\n#启动tomcat\nsystemctl start tomcat8_8082.service\n#关闭tomcat\nsystemctl stop tomcat8_8082.service\n#重启tomcat \nsystemctl restart tomcat8_8082.service\n#查看状态tomcat\nsystemctl status tomcat8_8082.service\n```\n\n\n## Linux配置多个Tomcat容器\n\n复制已配置好Tomcat目录`8081`\n```\ncp -rf 8081 8082\ncp -rf 8081 8083\ncp -rf 8081 8084\n```\n\n### 配置多Tomcat环境变量\n\n修改`/etc/profile`配置文件\n> 命名规则：CATALINA-{序号}-BASE-{版本号}\n```\n##########first tomcat###########\nCATALINA_1_BASE_8_5_88=/usr/local/services/tomcat_8.5.88/8081\nCATALINA_1_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8081\nTOMCAT_1_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8081\nexport CATALINA_1_BASE_8_5_88 CATALINA_1_HOME_8_5_88 TOMCAT_1_HOME_8_5_88\n##########first tomcat###########\n\n##########second tomcat##########\nCATALINA_2_BASE_8_5_88=/usr/local/services/tomcat_8.5.88/8082\nCATALINA_2_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8082\nTOMCAT_2_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8082\nexport CATALINA_2_BASE_8_5_88 CATALINA_2_HOME_8_5_88 TOMCAT_2_HOME_8_5_88\n##########second tomcat##########\n\n##########third tomcat##########\nCATALINA_3_BASE_8_5_88=/usr/local/services/tomcat_8.5.88/8083\nCATALINA_3_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8083\nTOMCAT_3_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8083\nexport CATALINA_3_BASE_8_5_88 CATALINA_3_HOME_8_5_88 TOMCAT_3_HOME_8_5_88\n##########third tomcat##########\n\n##########fourth tomcat##########\nCATALINA_4_BASE_8_5_88=/usr/local/services/tomcat_8.5.88/8084\nCATALINA_4_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8084\nTOMCAT_4_HOME_8_5_88=/usr/local/services/tomcat_8.5.88/8084\nexport CATALINA_4_BASE_8_5_88 CATALINA_4_HOME_8_5_88 TOMCAT_4_HOME_8_5_88\n##########fourth tomcat##########\n```\n\n使配置文件生效\n```\nsource /etc/profile\n```\n\n验证配置文件\n```\necho $CATALINA_1_BASE_8_5_88\n```\n\n修改Tomcat配置项\n> 如果新服务器中从未安装过Tomcat则第一个8081不需要修改\n>\n> 如果新服务器中已存在旧Tomcat，则为了避免CataLina的环境变量冲突，8081也需要进行修改\n\n\n\n`vim`打开`catalina.sh`文件执行以下命令全局替换\n\n8081\n```\n:%s/CATALINA_BASE/CATALINA_1_BASE_8_5_88/g\n:%s/CATALINA_HOME/CATALINA_1_BASE_8_5_88/g\n```\n\n8082\n```\n:%s/CATALINA_BASE/CATALINA_2_BASE_8_5_88/g\n:%s/CATALINA_HOME/CATALINA_2_BASE_8_5_88/g\n```\n\n8083\n```\n:%s/CATALINA_BASE/CATALINA_3_BASE_8_5_88/g\n:%s/CATALINA_HOME/CATALINA_3_BASE_8_5_88/g\n```\n\n8084\n```\n:%s/CATALINA_BASE/CATALINA_4_BASE_8_5_88/g\n:%s/CATALINA_HOME/CATALINA_4_BASE_8_5_88/g\n```\n\n### 配置多Tomcat的`setenv.sh`\n修改`setenv.sh`\n\n8081\n```\nCATALINA_PID=\"$CATALINA_1_BASE_8_5_88/tomcat.pid\"\n```\n8082\n```\nCATALINA_PID=\"$CATALINA_2_BASE_8_5_88/tomcat.pid\"\n```\n8083\n```\nCATALINA_PID=\"$CATALINA_3_BASE_8_5_88/tomcat.pid\"\n```\n8084\n```\nCATALINA_PID=\"$CATALINA_4_BASE_8_5_88/tomcat.pid\"\n```\n\n### 配置多Tomcat的端口\n修改端口\n```\n### 示例：8082 修改端口 ###\n#修改关闭端口(原8015)：\n<Server port=\"8025\" shutdown=\"SHUTDOWN\"  ... > \n#修改访问端口(原8081)：\n<Connector port=\"8082\" ... > \n#修改监听端口（AJP默认是注释关闭的、不用修改）：\n#<Connector port=\"8011\" protocol=\"AJP/1.3\"  ... >\n```\n \n\n## 迁移部署新环境\n> 搭建环境VM虚拟机中，需要迁移已配置好到生产环境部署\n\n### 迁移Tomcat旧环境准备\n压缩`Tomcat`环境\n```\ntar -zvcf tomcat_8.5.88.tar.gz tomcat_8.5.88\n```\n\n解压缩\n```\ntar -zxvf tomcat_8.5.88.tar.gz (-C 指定目录 )\n```\n\n上传至新服务器环境\n> [scp命令传文件](https://blog.csdn.net/a545812327/article/details/111313810)\n\n```\n#scp【本地文件的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】\nscp tomcat_8.5.88.tar.gz  root@192.168.116.129:/root/\n```\n\n### 迁移Tomcat新环境部署\n\n创建部署目录`service`\n```\nmkdir -p /usr/local/services/\n```\n\n移动tomcat环境压缩包并解压\n```\n#移动\nmv /root/tomcat_8.5.88.tar.gz ./\n#解压\ntar -zxvf tomcat_8.5.88.tar.gz\n```\n\n检查目录是否与原tomcat服务器环境一致\n```\n#pwd\n/usr/local/services/tomcat_8.5.88\n```\n\n配置Tomcat的环境变量\n[点击跳转](#Linux配置多个Tomcat容器)\n \n### 配置日志分割\n[点击这里跳转指定位置](#日志按日分割)\n\n\n\n### 配置系统启动\n[点击这里跳转指定位置](#配置Tomcat随系统启动)\n \n\n## 注意事项\n### 自动部署已关闭\n```\n <Host name=\"localhost\"  appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"false\">\n```\n\n\n### 创建gcLog日志目录\n\n> setenv.sh的配置gclog的路径可修改\n\n```\n#示例：Tomcat8081\nmkdir -p /usr/local/services/tomcat_8.5.88/8081/logs/gclogs\n```\n\n","categories":["技术博客","Tomcat"]},{"title":"Windows下Tomcat控制台中文乱码","url":"/posts/22134.html","content":"\n> [tomcat控制台乱码问题](https://blog.csdn.net/qq_41639347/article/details/90550249)\n\n\nTomcat目录下日志配置文件\n```\ntomcat/conf/logging.properties\n```\n\n\n添加命令\n```\njava.util.logging.ConsoleHandler.encoding = GBK\n```\n\n重启Tomcat运行","categories":["技术博客","Tomcat"]},{"title":"科学上网V2ray搭建教程","url":"/posts/306267.html","content":"\n> [参考博客](https://liuzhengwei127.github.io/2020/11/12/v2ray/)\n\n\n## 部署v2ray服务\n\n```\nbash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)\n```\n\n安装成功截图\n![](./科学上网V2ray搭建教程/Snipaste_2023-05-20_16-07-07.jpg)\n\n### 配置v2ray文件\n```\nvi /usr/local/etc/v2ray/config.json\n```\n\n添加如下内容：\n> 注意：port与id均为自定义的\n```\n{\n    \"inbounds\": [\n        {\n            \"port\": 10086, //服务器监听端口\n            \"protocol\": \"vmess\",\n            \"settings\": {\n                \"clients\": [\n                    {\n                        \"id\": \"5ac211e0-5183-454b-9521-836db728310b\" //唯一标识符uuid\n                    }\n                ]\n            }\n        }\n    ],\n    \"outbounds\": [\n        {\n            \"protocol\": \"freedom\"\n        }\n    ]\n}\n```\n\nport：\n建议使用5位数的端口，不易与系统本身使用的端口冲突\n\nid：\nuuid随机生成器:\nhttps://www.uuidgenerator.net/\nhttps://www.v2fly.org/awesome/tools.html\n\n\n### 启动v2ray服务\n```\nsystemctl enable v2ray\nsystemctl start v2ray\n```\n\n## 客户端使用\n\n### MAC\nhttps://github.com/yanue/V2rayU/releases\n\n### WINDOWS \nhttps://github.com/2dust/v2rayN/releases\n\n\n## 使用截图\n\n\n谷歌搜索IP定位：日本（服务器实例为某里云-日本节点）\n![](./科学上网V2ray搭建教程/Snipaste_2023-05-20_16-48-04.jpg)\n\n系统代理：自动配置系统代理\n路由：全局\n![](./科学上网V2ray搭建教程/Snipaste_2023-05-20_16-47-42.jpg)\n\n","categories":["技术博客","VPN"]},{"title":"VsCode相关集合","url":"/posts/36128.html","content":"\n# 仅以此记录相关`VsCode`使用内容\n> 整理个人使用vscode编辑器过程中相关内容集合\n>\n\n# 已安装插件\n\n## 环境语言包\n### Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code\n![](Snipaste_2023-04-29_09-53-06.jpg)\n\n## MD文件编辑相关插件\n### Markdown All in One \n![](Snipaste_2023-04-29_09-49-46.jpg)\n### Markdown PDF\n![](Snipaste_2023-04-29_09-50-41.jpg)\n### Markdown Preview Enhanced\n![](Snipaste_2023-04-29_09-51-05.jpg)\n### markdownlint\n![](Snipaste_2023-04-29_09-51-26.jpg)\n### GitHub Markdown Preview\n![](Snipaste_2023-04-29_09-51-57.jpg)\n\n## 代码提交相关插件\n### Git History\n![](Snipaste_2023-04-29_09-52-22.jpg)\n### git-commit-plugins\n![](Snipaste_2023-04-29_09-52-42.jpg)\n\n## 代码格式化\n### Prettier - Code formatter\n![](Snipaste_2023-04-29_09-53-28.jpg)\n\n## VsCode主题\n### GitHub Theme\n![](Snipaste_2023-04-29_09-53-47.jpg)\n### Theme ⭐⭐⭐\n![](Snipaste_2023-04-30_22-20-39.jpg)\n\n\n## VsCodew icon主题\n### Material Icon Theme ⭐⭐⭐⭐\n\n![](./VsCode相关集合/Snipaste_2023-05-01_11-09-54.jpg)\n\n\n","categories":["技术博客","VsCode"],"tags":["vscode插件"]},{"title":"Win11绕过TPM升级","url":"/posts/30832.html","content":"\n\n> [ Windows 11 绕过 TPM 方法总结，通用无 TPM 镜像下载 (2023 年 1 月更新)](https://www.cnblogs.com/sysin/p/17127862.html#_label1_4)\n\n记录:\n我通过win10系统升级到win11(保留应用及个人数据情况),使用的是[Rufus 创建 USB 启动盘](https://www.cnblogs.com/sysin/p/17127862.html#_label1_4)这个方法.\n\n![](./Win11绕过TPM升级/Snipaste_2023-05-06_07-29-59.jpg)\n\n补充:\nRufus安装win11会提供绕过TPM检测的功能,然后安装界面会显示win10等字样,实际安装的是win11.","categories":["技术博客","Win11"],"tags":["Win11","TPM"]},{"title":"解决windows的zip压缩包在linux下解压后中文乱码","url":"/posts/50390.html","content":"\n> [解决windows的zip压缩包在linux下解压后中文乱码问题](https://blog.csdn.net/suiyueruge1314/article/details/90766185)\n\n## 最简单便捷的方法\n`CP936`是最早的`GBK`编码\n```\nunzip -O CP936 xxx.zip\n```\n\n## 其他方法\n\n> 备注: 我没有测试此方法,仅以此作记录!\n\n### 安装7zip和convmv\n```\n# centos\nyum install 7zip convmv\n# ubuntu\nsudo apt-get install 7zip convmv\n```\n### 解压缩命令\n```\n# 使用7z解压缩\nLANG=C 7za x your-zip-file.zip\n# 递归转码，从GBK转为UTF-8\nconvmv -f GBK -t utf8 --notest -r .\n```\n\n","categories":["技术博客","Win11"]},{"title":"SpringCloud基础教程-Eureka-Client","url":"/posts/34343.html","content":"\n\n> 参考博客: [Springboot 整合 SpringCloud组件-Eureka 微服务 EurekaClient（二）](https://blog.csdn.net/qq_35387940/article/details/94562280)\n\n---\n## Eureka注册中心\nEureka注册中心服务-发现Client端截图\n![](./SpringCloud基础教程-Eureka-Client/Snipaste_2023-06-19_08-51-09.png)\n\n---\n\n## 相关配置项\n\n### 入口启动类\n\n`@EnableEurekaClient`是Eureka客户端的核心注解\n```\npackage com.mumu.springcloud_eureka_client;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n@EnableEurekaClient\n@SpringBootApplication\npublic class SpringcloudEurekaClientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudEurekaClientApplication.class, args);\n    }\n\n}\n\n```\n\n### yml配置文件\n\n`application.yml`配置文件\n```\nserver:\n  port: 8762\n\nspring:\n  application:\n    name: client-01\neureka:\n  instance:\n    #以IP地址注册到服务中心，相互注册使用IP地址\n    preferIpAddress: true\n    instance-id: ${spring.cloud.client.ip-address}:${server.port}\n  client:\n    #eureka server注册中心的地址\n    serviceUrl:\n      defaultZone: http://localhost:8080/eureka/\n```\n\n### pom配置文件\n\n核心pom配置项\n```\n<dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n完整pom配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.7.12</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <groupId>com.mumu</groupId>\n    <artifactId>springcloud_eureka_client</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>springcloud_eureka_client</name>\n    <description>springcloud_eureka_client</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>2021.0.7</spring-cloud.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n\n## 附件\n\n[SpringCloud-Eureka-Client.zip](./SpringCloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Eureka-Client/springcloud_eureka_client.zip)","categories":["教程集合","SpringCloud基础教程"],"tags":["SpringCloud","Eureka-Client"]},{"title":"SpringCloud基础教程-Eureka","url":"/posts/41405.html","content":"\n> 参考博客: [Springboot 整合 SpringCloud组件-Eureka 注册中心 EurekaServer (一)](https://blog.csdn.net/qq_35387940/article/details/94559369)\n\n---\n## Eureka注册中心\nEureka注册中心服务启动截图\n![](./SpringCloud基础教程-Eureka/Snipaste_2023-06-19_08-22-55.png)\n\n---\n\n## 相关配置项\n\n### 入口启动类\n\n`@EnableEurekaServer`是Eureka注册中心的核心注解\n```\npackage com.mumu.springcloud_eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@EnableEurekaServer\n@SpringBootApplication\npublic class SpringcloudEurekaApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudEurekaApplication.class, args);\n    }\n\n}\n```\n\n### yml配置文件\n\n`application.yml`配置文件\n```\nserver:\n  port: 8080\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    #是否注册自身到eureka服务器\n    register-with-eureka: false\n    #是否从eureka服务器获取注册信息\n    fetch-registry: false\n    #设置eureka服务器所在的地址，查询服务和注册服务都需要依赖这个地址\n    service-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n#  server:\n#    #关闭注册中心自我保护机制\n#    enable-self-preservation: false\n#    #注册中心清理间隔（单位毫秒，默认60*1000）\n#    eviction-interval-timer-in-ms: 10000\n\nspring:\n  application:\n    name: eureka-server\n\n```\n\n### pom配置文件\n\n核心pom配置项\n```\n<dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n完整pom配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.7.12</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    \n    <groupId>com.mumu</groupId>\n    <artifactId>springcloud_eureka</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>springcloud_eureka</name>\n    <description>springcloud_eureka</description>\n    \n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>2021.0.7</spring-cloud.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n\n\n## 附件\n\n[SpringCloud-Eureka.zip](./SpringCloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-Eureka/springcloud_eureka.zip)","categories":["教程集合","SpringCloud基础教程"],"tags":["SpringCloud","Eureka"]},{"title":"SpringCloud基础教程-Feign","url":"/posts/22804.html","content":"\n> 参考博客: [Springboot 整合 SpringCloud组件-Feign(Ribbon/Hystrix) （三）](https://blog.csdn.net/qq_35387940/article/details/94569189)\n>> 由于SpringCloud版本不同，上述文档中`feign`开启`hystrix`失效!\n>\n> 参考博客: [Spring Cloud 之五：Feign使用Hystrix](https://blog.csdn.net/caitianzhen2/article/details/130174670)\n\n---\n\n## 相关配置项\n\n### 入口启动类\n```\npackage com.mumu.springcloud_feign;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\nimport org.springframework.cloud.netflix.hystrix.EnableHystrix;\nimport org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n@EnableEurekaClient\n@EnableDiscoveryClient\n@EnableHystrix\n@EnableHystrixDashboard\n@EnableFeignClients\n@SpringBootApplication\npublic class SpringcloudFeignApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudFeignApplication.class, args);\n    }\n\n}\n```\n\n### yml配置文件\n\n```\neureka:\n  instance:\n    preferIpAddress: true\n    instance-id: ${spring.cloud.client.ip-address}:${server.port}\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8080/eureka/\nserver:\n  port: 8765\n\nspring:\n  application:\n    name: feign\nfeign:\n#  hystrix的配置此处不生效！可能由于springCloud版本的原因，启用`circuitbreaker`开启熔断\n#  hystrix:\n#    enabled: true\n  circuitbreaker:\n    enabled: true\n\n\n```\n\n### pom配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.7.12</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.mumu</groupId>\n    <artifactId>springcloud_feign</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>springcloud_feign</name>\n    <description>springcloud_feign</description>\n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>2021.0.7</spring-cloud.version>\n    </properties>\n    <dependencies>\n\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n            <version>2.2.1.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n            <version>2.2.1.RELEASE</version>\n        </dependency>\n\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n---\n\n## 代码相关类\n\n### Feign - Service方法接口\n```\npackage com.mumu.springcloud_feign.service;\n\n\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n//@FeignClient(value = \"client-01\",fallback = SchedualServiceHiHystric.class)\n@FeignClient(value = \"client-01\",fallbackFactory = SchedualServiceHiHystricFacotry.class)\n@Component\npublic interface SchedualServiceHi {\n\n    @RequestMapping(value = \"/haveatry\",method = RequestMethod.GET)\n    String sayHiFromClientOne(@RequestParam(value = \"name\") String name);\n\n}\n```\n\n### Feign - Hystrix\n\n#### @FeignClient(fallback=…)\n```\npackage com.mumu.springcloud_feign.service;\n\nimport com.mumu.springcloud_feign.service.SchedualServiceHi;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class SchedualServiceHiHystric implements SchedualServiceHi {\n\n    @Override\n    public String sayHiFromClientOne(String name) {\n        return \"Fallback | sorry! 网络异常，服务暂时无法访问。 请求的name为:\"+name;\n    }\n}\n\n```\n#### @FeignClient(fallbackFactory=…)\n> 支持打印出异常日志（推荐）\n\n```\npackage com.mumu.springcloud_feign.service;\n\nimport org.springframework.cloud.openfeign.FallbackFactory;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class SchedualServiceHiHystricFacotry implements FallbackFactory<SchedualServiceHi> {\n\n    @Override\n    public SchedualServiceHi create(Throwable cause) {\n        return new SchedualServiceHi() {\n            @Override\n            public String sayHiFromClientOne(String name) {\n                System.out.println(\"异常日志error:\"+cause);\n                return \"FallbackFactory | sorry! 网络异常，服务暂时无法访问。 请求的name为:\"+name;\n            }\n        };\n    }\n}\n\n```\n\n## 问题记录\n1. 错误日志: `Could not find artifact org.springframework.cloud:spring-cloud-starter-netflix-hystrix:pom:unknown in central (https://repo.maven.apache.org/maven2)`\n\n> 参考博客解决方式: [Could not find artifact org.springframework.cloud:spring-cloud-starter-netflix-eureka-client:pom](https://blog.csdn.net/weixin_44670952/article/details/104626578)\n\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n    <version>2.2.1.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n    <version>2.2.1.RELEASE</version>\n</dependency>\n```\n\n","categories":["教程集合","SpringCloud基础教程"],"tags":["SpringCloud","Feign"]},{"title":"JavaGuide面试突击版-Java基础","url":"/posts/58856.html","content":"\n[JavaGuide面试突击版-学习-0506](/posts/40038.html)\n\n[JavaGuide面试突击版-学习-0507](/posts/23719.html)","categories":["面试准备","JavaGuide面试突击-PDF"],"tags":["JavaGuide面试突击","Java基础"]},{"title":"Java面试题2023","url":"/posts/33730.html","content":"\n\n# 复习进度总览\n\n> [Java面试常见问题总结（2023最新版）- Guide哥](https://articles.zsxq.com/id_7mcfhuacmhzs.html)\n> \n\n\n## JAVA\n### Java - 基础\n- [x] [Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？](/posts/59036.html)\n- [x] [String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?](/posts/21142.html)\n- [x] [String s1 = new String(\"abc\");这段代码创建了几个字符串对象？](/posts/10949.html)\n- [x] [== 与 equals?hashCode 与 equals ?](/posts/33636.html)\n- [x] [包装类型的缓存机制了解么？](/posts/48309.html)\n- [x] [自动装箱与拆箱了解吗？原理是什么？](/posts/13955.html)\n- [x] [深拷贝和浅拷贝区别了解吗？什么是引用拷贝？](/posts/30985.html)\n- [ ] 谈谈对 Java 注解的理解，解决了什么问题？\n- [x] [Exception 和 Error 有什么区别？](/posts/60744.html)\n- [x] [Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？](/posts/43267.html)\n- [x] [Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？](/posts/47052.html)\n- [x] [内部类了解吗？匿名内部类了解吗？](/posts/19656.html)\n- [x] [BIO,NIO,AIO 有什么区别?](/posts/59996.html)\n\n### Java - 集合框架\n- [x] [说说 List,Set,Map 三者的区别？三者底层的数据结构？](/posts/50957.html)\n- [x] [有哪些集合是线程不安全的？怎么解决呢？](/posts/62981.html)\n- [x] [比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同](/posts/18392.html)\n- [x] [HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？](/posts/3318.html)\n- [x] [HashMap 的底层实现](/posts/34725.html)\n- [x] [HashMap 的长度为什么是 2 的幂次方](/posts/23150.html)\n- [x] [ConcurrentHashMap 和 Hashtable 的区别？](/posts/12495.html)\n- [x] [ConcurrentHashMap 线程安全的具体实现方式/底层具体实现](/posts/19235.html)\n\n### Java - JVM\n- [x] [jvm 内存结构](/posts/62546.html)\n- [x] [jvm 调优参数](/posts/7617.html)\n- [x] [什么是类加载？何时类加载？类加载流程？](/posts/26747.html)\n- [ ] 知道哪些类加载器。类加载器之间的关系？\n- [ ] 类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？...）。\n- [ ] 为什么需要双亲委派\n- [ ] Java 内存模型\n- [ ] 栈中存放什么数据，堆中呢？\n- [ ] 大对象放在哪个内存区域\n- [ ] 堆区如何分类\n- [ ] 垃圾回收有哪些算法\n- [ ] GC 的全流程\n- [ ] GC 中老年代用什么回收方法？\n\n### Java - 多线程\n- [ ] 线程和进程的区别。\n- [ ] 什么是上下文切换?\n- [x] [什么是线程死锁?如何避免死锁?](/posts/58164.html)\n- [x] [说说 sleep() 方法和 wait() 方法区别和共同点?](/posts/31949.html)\n- [x] [Java 线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程?](/posts/50604.html)\n- [x] [实现 Runnable 接口和 Callable 接口的区别](/posts/54835.html)\n- [x] [讲一下 JMM(Java 内存模型)。volatile 关键字解决了什么问题？说说 synchronized 关键字和 volatile 关键字的区别。](/posts/50822.html)\n- [ ] AQS 原理了解么？AQS 组件有哪些？\n- [x] [用过 CountDownLatch 么？什么场景下用的？](https://zhuanlan.zhihu.com/p/148231820)\n\n## 数据库\n### Mysql\n#### Mysql - 基础\n\n- [x] [非关系型数据库和关系型数据库的区别？](/posts/27108.html)\n- [ ] 事务的四大特性了解么?\n- [x] [MySQL 事务隔离级别？默认是什么级别？](/posts/30299.html)\n- [x] [乐观锁和悲观锁了解么？](https://blog.csdn.net/SnailMann/article/details/88388829)\n- [x] [MySQL 数据库两种存储引擎的区别?](/posts/65022.html)\n\n#### Mysql - 索引\n- [ ] 为什么索引能提高查询速度?\n- [ ] 聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?\n- [ ] 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗?)\n- [ ] 索引底层的数据结构了解么？Hash 索引和 B+树索引优劣分析\n- [ ] B+树做索引比红黑树好在哪里？\n- [ ] 最左前缀匹配原则了解么？\n- [ ] 什么是覆盖索引\n\n#### Mysql - 进阶\n- [ ] 一条 SQL 语句在 MySQL 中如何执行的？\n- [ ] explain 命令了解么？\n- [ ] 简单说一下 SQL 调优思路。\n- [ ] 简单说一下大表优化的思路。\n- [ ] 分库分表了解么？为什么要分库分表？有哪些常见的分库分表工具(sharding-jdbc、TSharding、MyCAT...)？\n\n### Redis\n\n- [ ] 分布式缓存常见的技术选型方案有哪些？说一下 Redis 和 Memcached 的区别和共同点\n- [ ] 说一下有缓存情况下查询数据和修改数据的流程。\n- [ ] Redis 有哪些数据结构？SDS 了解么？\n- [ ] Redis 内存满了怎么办？\n- [ ] Redis 内存淘汰算法除了 LRU 还有哪些？\n- [ ] Redis 给缓存数据设置过期时间有啥用？ Redis 是如何判断数据是否过期的呢？\n- [ ] Redis 事务了解么？(Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务功能)\n- [ ] Redis 批量操作的方式有哪些？\n- [ ] 缓存穿透和缓存雪崩问题了解么？有哪些解决办法？\n- [ ] 如何基于 Redis 实现分布式锁？\n- [ ] 什么是 Sentinel？ 有什么用？\n- [ ] Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?\n- [ ] Sentinel 是如何实现故障转移的？\n- [ ] Sentinel 如何选择出新的 master（选举机制）?\n- [ ] 如何从 Sentinel 集群中选择出 Leader ？\n- [ ] Sentinel 可以防止脑裂吗？\n- [ ] 为什么需要 Redis Cluster？解决了什么问题？有什么优势？\n- [ ] Redis Cluster 是如何分片的？\n- [ ] 为什么 Redis Cluster 的哈希槽是 16384 个?\n- [ ] 如何确定给定 key 的应该分布到哪个哈希槽中？\n- [ ] Redis Cluster 支持重新分配哈希槽吗？\n- [ ] Redis Cluster 扩容缩容期间可以提供服务吗？\n- [ ] Redis Cluster 中的节点是怎么进行通信的？  \n\n## 网络\n\n### 网络分层模型 \n- [ ] OSI 与 TCP/IP 各层的结构与功能。\n- [ ] 为什么网络要分层？\n- [ ] OSI 与 TCP/IP 各层都有哪些协议?\n\n### TCP 与 UDP \n- [ ] TCP 的三次握手与四次挥手的内容？ TCP 为什么连接是三次握手而断开是四次握手？\n- [ ] TCP 与 UDP 的区别及使用场景\n- [ ] TCP 是如何保证传输的可靠性？\n- [ ] HTTP 基于 TCP 还是 UDP？\n\n### HTTP\n- [ ] HTTP 状态码有哪些？\n- [ ] 一次完整的 HTTP 请求所经的步骤\n- [ ] HTTP 协议了解么？HTTP 是基于 TCP 还是 UDP 的？\n- [ ] HTTP 报文的内容简单说一下！ HTTP 请求报文和响应报文中有哪些数据？\n- [ ] HTTP 和 HTTPS 的区别了解么？\n- [ ] HTTP/1.0 和 HTTP/1.1 有什么区别？\n- [ ] HTTP/1.1 和 HTTP/2.0 有什么区别？\n- [ ] HTTP/2.0 和 HTTP/3.0 有什么区别？\n- [ ] HTTP 请求有哪些常见的状态码？\n- [ ] HTTP 长连接和短连接了解么？\n- [ ] Cookie 和 Session 的关系\n- [ ] URI 和 URL 的区别是什么?\n\n### PING\n- [ ] PING 命令的作用是什么？\n- [ ] PING 命令的工作原理是什么？\n\n### IP\n- [ ] IP 协议的作用是什么？\n- [ ] 什么是 IP 地址？IP 寻址如何工作？\n- [ ] IPv4 和 IPv6 有什么区别？\n\n## 操作系统\n- [ ] 进程和线程的区别\n- [ ] 进程有哪几种状态?\n- [ ] 进程间的通信方式\n- [ ] 线程间的同步的方式\n- [ ] PCB\n- [ ] 进程的调度算法\n- [ ] 什么是死锁？死锁的四个必要条件，解决死锁的方法\n- [ ] 常见的内存管理机制\n- [ ] 内存碎片\n- [ ] 分段机制和分页机制的区别和共同点\n- [ ] 分段机制和分页机制下的地址翻译过程分别是怎样的\n- [ ] 单级页表有什么问题？为什么需要多级页表？\n- [ ] TLB 有什么用？使用 TLB 之后的地址翻译流程是怎样的？\n- [ ] 页缺失，常见的页面置换算法有哪些?\n- [ ] 硬链接和软链接有什么区别？\n- [ ] 常见的磁盘调度算法有哪些？\n\n## 算法和数据结构\n\n### 算法\n- [ ] LRU 算法了解吗？你能实现一个吗？\n- [x] [写排序算法（快排、堆排）](https://blog.csdn.net/shujuelin/article/details/82423852)\n- [ ] 使用数组实现一个栈\n- [ ] 使用数组实现一个队列\n- [ ] 实现一个链表、反转链表、\n\n### 数据结构\n- [ ] 数组 vs 链表\n- [ ] 栈的应用场景\n- [ ] 队列的分类、应用场景\n- [ ] 红黑树的特点、红黑树 vs 二叉查找树\n- [ ] 哈希表、哈希表应用场景\n- [ ] 布隆过滤器了解吗？\n\n## 系统设计\n### 设计模式\n- [ ] 何为设计模式？有哪些常见的设计模式？\n- [x] [单例模式了解么？说一下单例模式的使用场景。手写一个单例模式的实现。](/posts/44263.html)\n- [ ] 观察者模式了解么？说一下观察者模式的使用场景。\n- [ ] 工厂模式了解么？说一下工厂模式的使用场景。\n- [ ] 责任链模式了解么？哪些开源项目（Netty、MyBatis ...）中用到了责任链模式？怎么用的？\n- [ ] SOLID 原则了解么？简单谈谈自己对于单一职责原则和开闭原则的理解。\n- [ ] 阅读 Spring 源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？\n\n### 常见框架\n#### Spring\n- [x] [什么是 Spring 框架?](/posts/28206.html)\n- [x] [列举一些重要的 Spring 模块？](/posts/34910.html)\n- [x] [谈谈自己对于 Spring IoC 和 AOP 的理解](/posts/5393.html)\n- [x] [Spring Bean 的生命周期说一下](/posts/44604.html)\n- [x] [Spring 中的 bean 的作用域有哪些?](/posts/63647.html)\n- [x] [拦截器和过滤器了解么？](/posts/48331.html)\n- [x] [Spring 动态代理默认用哪一种](/posts/21371.html)\n- [x] [hibernate 和 mybatis 区别](/posts/64579.html)\n- [x] [Spring Boot 和 Spring 的区别](/posts/9789.html)\n- [x] [说出使用 Spring Boot 的主要优点](/posts/1453.html)\n- [x] [什么是 Spring Boot Starter?](/posts/15195.html)\n- [x] [介绍一下@SpringBootApplication 注解](/posts/59082.html)\n- [x] [Spring Boot 的自动配置是如何实现的?](/posts/6677.html)\n- [x] [Spring Boot 支持哪些嵌入式 web 容器？](/posts/24826.html)\n\n#### Netty\n- [x] [BIO,NIO 和 AIO 有啥区别？](/posts/59996.html)\n- [ ] Netty 是什么？为啥不直接用 NIO 呢?\n- [ ] 为什么要用 Netty？Netty 应用场景了解么？\n- [ ] 介绍一下 Netty 的核心组件？\n- [ ] Bootstrap 和 ServerBootstrap 了解么？\n- [ ] NioEventLoopGroup 默认的构造函数会起多少线程？\n- [ ] Netty 线程模型了解么？\n- [ ] 什么是 TCP 粘包/拆包?有什么解决办法呢？\n- [ ] Netty 长连接、心跳机制了解么？\n\n### 权限认证\n- [ ] 认证 (Authentication) 和授权 (Authorization)的区别是什么？\n- [ ] 什么是 Cookie ? Cookie 的作用是什么?如何在服务端使用 Cookie ?\n- [ ] Cookie 和 Session 有什么区别？如何使用 Session 进行身份验证？\n- [ ] 如果没有 Cookie 的话 Session 还能用吗？\n- [ ] 为什么 Cookie 无法防止 CSRF 攻击，而 token 可以？\n- [ ] 什么是 Token?什么是 JWT?如何基于 Token 进行身份验证？\n- [ ] 什么是 OAuth 2.0？\n- [ ] 什么是 SSO(单点登录)？\n\n## 分布式\n### 分布式理论\n- [ ] [CAP & BASE 理论详解](https://javaguide.cn/distributed-system/theorem&algorithm&protocol/cap&base-theorem.html) \n- [ ] [Paxos 算法详解](https://javaguide.cn/distributed-system/theorem&algorithm&protocol/paxos-algorithm.html)\n- [ ] [Raft 算法详解](https://javaguide.cn/distributed-system/theorem&algorithm&protocol/raft-algorithm.html)\n\n### RPC\n#### RPC 基础\n- [ ] 了解 RPC 吗？有哪些常见的 RPC 框架？\n- [ ] 如果让你自己设计 RPC 框架你会如何设计？\n- [ ] 服务之间的调用为啥不直接用 HTTP 而用 RPC？\n\n#### Dubbo\n- [ ] Dubbo 了解吗？\n- [ ] Dubbo 的工作原理了解么？注册中心扮演了什么角色？注册中心挂了可以继续通信吗？\n- [ ] Dubbo 的负载均衡策略了解么？\n- [ ] Dubbo 的 spi 机制了解么？带来了啥好处？\n\n### 分布式 ID\n- [ ] 何为 ID？\n- [ ] 何为分布式 ID？\n- [ ] 一个合格的分布式 ID 需要满足什么要求?\n- [ ] 分布式 ID 常见的生成方法有哪些？（数据库主键自增、数据库的号段模式、UUID、SNOWFLAKE 等等）\n\n### API 网关\n- [ ] 什么是网关？\n- [ ] 网关能提供哪些功能？\n- [ ] 有哪些常见的网关系统？\n\n### 分布式锁\n#### 基于 Redis 实现分布式锁：\n- [ ] 如何基于 Redis 实现一个最简易的分布式锁？ \n- [ ] 为什么要给锁设置一个过期时间？\n- [ ] 如何实现锁的优雅续期？\n- [ ] 如何实现可重入锁？\n- [ ] Redis 如何解决集群情况下分布式锁的可靠性？\n\n#### 基于 ZooKeeper 实现分布式锁：\n- [ ] 如何基于 ZooKeeper 实现分布式锁？\n- [ ] 为什么要用临时顺序节点？\n- [ ] 为什么要设置对前一个节点的监听？\n- [ ] 如何实现可重入锁？\n\n## 高并发\n### 消息队列\n- [ ] 为什么要用消息队列?\n- [ ] 对比一下常见的消息队列?\n- [ ] 如何保证消息不被重复消费?\n- [ ] 如何保证消息消费的顺序性?\n\n### CDN（内容分发网络）\n- [ ] 什么是 CDN ？\n- [ ] CDN 的工作原理是什么？\n\n### 读写分离和分库分表\n- [ ] 什么是读写分离？\n- [ ] 主库和从库的数据存在延迟的问题如何解决？\n- [ ] 如何实现读写分离？主从复制原理是什么？\n- [ ] 什么是分库？什么是分表？什么情况下需要分库分表？\n- [ ] 常见的分片算法有哪些？\n- [ ] 分库分表会带来什么问题呢？\n- [ ] 分库分表后，数据怎么迁移呢？\n\n## 系统设计/场景题\n- [ ] 假如有 10 亿个数，只有一个重复，内存只能放下 5 亿个数，怎么找到这个重复的数字？\n- [ ] 如何设计一个秒杀系统（服务端、数据库、分布式）？分布式系统的设计？\n- [ ] 有一个服务器专门接收大量请求，怎么设计？\n- [ ] 如果让你自己设计 RPC 框架你会如何设计？\n- [ ] 怎么快速出现一个 stackoverflow 错误？\n- [ ] 如何设计一个秒杀系统？\n- [ ] 如何设计一个微博 Feed 流/信息流系统？\n- [ ] 如何设计一个短链系统？\n\n## 项目经历\n- [ ] 说说你的项目中的亮点有哪些？\n- [ ] 项目用户人数有多少？最大在线人数多少？\n- [ ] 画一下你的项目的架构图。\n- [ ] 项目中遇到的困难有哪些？怎么解决的？\n- [ ] xx 某块的数据库表是如何设计的？\n\n## HR面\n- [ ] 个人介绍\n- [ ] 平时的兴趣爱好\n- [ ] 对我们公司的了解\n- [ ] 三个词形容自己\n- [ ] 职业规划\n- [ ] 平时的学习方式\n- [ ] 大学里做过比较有意义的事情\n- [ ] 手里还有哪些 offer\n- [ ] 选择工作的理由排序（薪资、加班情况之类的）。\n\n\n\n\n\n","categories":["面试准备","Java面试题2023"]},{"title":"面试准备-多线程","url":"/posts/8310.html","content":"\n# 多线程\n\n## 线程和进程的区别\n> [进程和线程的区别(超详细)](https://blog.csdn.net/ThinkWon/article/details/102021274)\n\n### 进程\n一个在内存中运行的应用程序. 每一个进程都有自己独立的内存空间,一个进程可以有多个线程,比如在Windows系统中,一个运行的xxx.exe就是一个进程.\n\n### 线程\n进程中一个执行任务控制单元,负责当前进程中程序的执行.一个进程至少有一个线程,一个进程可以运行多个线程,多个线程共享数据.\n\n与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源,但每个线程有自己的**程序计数器**,**虚拟机栈**,**本地方法栈**,所以系统在产生一个线程或是各个线程间作切换工作时,负担要比进程小得多.线程也被称为**轻量级进程**.\n\n### 进程与线程的区别总结\n- 根本区别: 进程是操作系统资源分配的基本单位,而线程是处理器任务调度和执行的基本单位.\n- 资源开销:\n  - 进程: 每个进程都有独立的代码和数据空间(程序上下文),程序将的切换会有较大的开销.\n  - 线程: 看作轻量级的进程,同一线程共享代码和数据空间,每个线程都有自己独立的运行栈和程序计数器,线程之间切换开销较小.\n- 包含关系: 如果一个进程内有多个线程,则执行过程不是一条线程,而是多条线程共同完成的;线程是进程的一部分,所以线程也被称为轻权进程或轻量级进程.\n- 内存分配: 同一个进程的线程共享本进程的地址空间和资源,而进程之间的空间和资源是相互独立的.\n- 影响关系: 一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都会死掉.所以多进程比多线程健壮.\n- 执行过程: 每个独立的进程有程序的入口\\顺序执行序列\\程序出口.但是线程不能独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制,两者均可并发执行.\n\n\n## 什么是上下文切换?\n上下文切换是指操作系统在多任务处理中，暂停当前任务的执行并保存它的状态信息，然后加载下一个任务的状态信息，使得下一个任务能够继续执行。在任务执行完毕或者发生中断时，操作系统会再次进行上下文切换，将之前保存的任务的状态信息恢复到处理器中并继续执行。上下文切换是实现多任务处理的重要技术，但频繁的上下文切换会带来性能开销。\n\n\n## 什么是线程死锁?如何避免死锁?\n\n## 乐观锁和悲观锁了解么？\n> [【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？](https://www.cnblogs.com/kismetv/p/10787228.html)\n\n## 说说 sleep() 方法和 wait() 方法区别和共同点?\n> [Java中sleep()方法和wait()方法的异同点](https://blog.csdn.net/x541211190/article/details/109545132)\n\n## Java 线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程?\n> [Java线程池七个参数详解：核心线程数、最大线程数、空闲线程存活时间、时间单位、工作队列、线程工厂、拒绝策略](https://blog.csdn.net/Anenan/article/details/115603481)\n>\n> [Java-五种线程池，四种拒绝策略，三类阻塞队列](https://blog.csdn.net/xxj_jing/article/details/84835476)\n\n## \n\n\n\n","categories":["面试准备","待归纳整理"]},{"title":"面试复盘-网友分享-20230508","url":"/posts/10254.html","content":"\n## 网友面试复盘分享\n- [x] [自我介绍](/posts/40232.html)\n- [x] [SpringBoot对Spring框架有什么优势?](/posts/49304.html)\n- [x] [Spring的两大特点是什么?](/posts/50574.html)\n- [x] [常见的SQL优化](/posts/5829.html)\n- [x] [Mysql的引擎](/posts/56579.html)\n- [ ] [我一个亿的订单数据，我要去怎么去设计这个表?](/posts/28159.html)\n- [x] [分库分表了解吗?](/posts/42625.html)\n- [x] [redis的数据结构您知道都有哪些?](/posts/13537.html)\n- [x] [redis是线程安全的吗?](/posts/9984.html)\n- [ ] 什么面向对象?\n- [x] [对集合有了解吗?](/posts/23720.html)\n- [x] [Arraylist和Linklist有啥区别?](/posts/23720.html)\n- [x] [Arraylist是线程安全的吗?](/posts/23720.html)\n- [ ] hashmap原理讲一下吗?\n- [ ] hashmap是线程安全吗?\n- [ ] 指针碰撞或者哈希冲突知道吗?\n- [x] [==号和equal的区别?](/posts/33636.html)\n- [x] [成员变量和局部变量有什么区别?](/posts/33408.html)\n- [x] [java中是引用传递还是值传递?](/posts/7068.html)\n- [x] [静态变量用什么修饰呢? 有什么作用?](/posts/39404.html)\n- [x] [StringBuffer和StringBuild有啥区别?](/posts/21142.html)\n- [x] [java中的常见的异常有哪些?](/posts/60744.html)\n- [ ] 线程的生命周期您了解吗?\n- [ ] 常见的线程池有了解过吗?\n- [ ] 使用线程池过程中需要try catch吗?\n- [x] [你会在finally里面去做资源释放吗?](/posts/45288.html)\n- [ ] 成员变量\\局部变量\\静态变量他们在线程安全上的区别?\n\n\n## 自我列举\n- [x] [强制使SQL执行索引](/posts/31049.html)\n- [x] [redis的常用数据结构及使用场景](/posts/31486.html)\n","categories":["面试准备","面试复盘-网友分享"]},{"title":"面试复盘-网友分享-20230513","url":"/posts/32590.html","content":"\n## 网友面试复盘分享-20230513\n- [x] [SpringBoot 和 Spring的区别？](/posts/49304.html)\n- [x] [SpringBoot 的自动装配原理？](/posts/12723.html)\n- [x] [@ConditionalOnBean和@ConditionalOnMissingBean两个注解](/posts/5517.html)\n- [ ] [MySQL索引？]()\n- [ ] [Redis怎么使用的？结合项目说一下]()\n- [ ] Docker用过吗？\n- [ ] K8s了解吗？\n- [x] [Java多线程-线程池有哪些参数、线程池工作原理、线程池各个参数干啥的](/posts/21595.html)\n- [x] [MySQL的分库分表](/posts/42625.html)\n\n---\n\n- [x] [SpringBoot中的@SpringBootApplication注解作用是什么？](https://blog.csdn.net/weixin_45617512/article/details/107942565)\n- [x] [SpringBoot中是如何加载配置信息的？](https://blog.csdn.net/weixin_45617512/article/details/107942565)\n- [x] [RabbitMQ如何保证消息不丢失的？](https://www.cnblogs.com/cnndevelop/p/12091348.html)\n- [ ] 如果消费者消费到一般宕机了怎么办？\n- [x] [RabbitMQ如何保证消息没有被重复消费](https://blog.csdn.net/qq_43206800/article/details/114884758)？\n- [ ] [JVM运行时区域有几块？](/posts/62546.html)\n- [ ] JVM的垃圾回收算法了解吗？有哪几种？\n- [ ] JVM是怎么判断一个一个对象是否可以被回收了?\n- [ ] 为什么HotShot虚拟机最终选择了可达性分析而没有选择引用计数法？\n- [ ] 哪你说说那些对象可以作为可达性分析中的GC ROOT？\n- [x] [Linux中查询一个进程的进程号？](https://www.cnblogs.com/mohou/p/15917845.html)\n- [ ] Linux怎么查看正在运行Java程序的日志？\n- [x] [Linux怎么修改文件权限？](https://blog.csdn.net/qq_28114615/article/details/89173550)\n- [x] [一个7就可以代表读写执行权限，为什么有3个7？](https://zhuanlan.zhihu.com/p/23891592)\n\n---\n- [x] [Linux如何查看进程id](https://blog.csdn.net/apple198942/article/details/116156022)\n- [x] [如何查看固定端口的java进程](https://www.cnblogs.com/mohou/p/15917845.html)\n- [x] [kill -9 是啥意思](https://blog.csdn.net/qq_37450814/article/details/114695322)\n- [ ] grep | 是啥？\n- [ ] docker一些命令？\n- [ ] Mysq的索引优化场景\n- [x] [最左匹配问题](https://blog.csdn.net/yuanchangliang/article/details/107798724)\n- [x] [MVCC的详细介绍](https://juejin.cn/post/7016165148020703246)\n- [x] [数据库事务](/posts/51105.html)\n- [x] [MySQL的那几个事务级别](/posts/32391.html)\n- [x] [脏读是啥](/posts/32391.html)\n- [x] [幻读是啥](/posts/32391.html)\n- [x] 为什么不使用串行化\n- [ ] 怎么解决行锁、间隙锁\n- [x] [单例模式用法](/posts/44263.html)\n- [ ] 工厂、抽象模式具体场景","categories":["面试准备","面试复盘-网友分享"]},{"title":"面试复盘-网友分享-20230517","url":"/posts/48208.html","content":"\n## 某手国际化-后端开发面经\n- [ ] [JVM的内存模型]()\n- [ ] 堆怎么管理内存\n- [ ] 垃圾回收算法\n- [ ] 跨代引用问题怎么解决\n- [ ] 每次回收都要从GC ROOTS开始吗？\n- [ ] 垃圾回收器\n- [ ] CMS回收过程\n- [ ] G1和CMS区别\n- [ ] Redis用的什么数据类型\n- [ ] Hash底层结构\n- [ ] JVM垃圾回收\n- [ ] MySQL索引模型\n- [ ] 为什么用B+树\n- [ ] 联合索引在B+树如何构造的\n- [ ] 覆盖索引知道吗？\n\n## 某康威视\n- [ ] Redis的架构\n- [ ] Reids的线程模型\n- [ ] 堆Syncchronize的理解\n- [ ] 锁升级\n\n\n## 某节\n- [ ] 进程和线程的通信方式\n- [ ] 进程和线程的区别\n- [ ] Java事项多线程的方式\n- [ ] Java的ThreadLocal\n- [ ] Volatile和锁是什么？\n- [ ] Thread中用过锁吗？\n- [ ] Volatile不保证原子性的原理？\n- [ ] Java异常体系怎么设计的？异常分类？\n- [ ] Spring框架是为了解决什么问题？IOC和AOP是什么？\n- [ ] Spring里的事务用过吗？原理？\n- [ ] 事务的传递？\n- [ ] Session和Cookie的区别？\n- [ ] 网站安全问题？\n- [ ] Session的生命周期如何管理？\n- [ ] 登录如何实现？JWT?\n- [ ] Token怎么生成？\n- [ ] MySQL的储存引擎？Innodb的特性？\n- [ ] 聚簇索引的原理？\n- [ ] 用过索引吗？联合索引？\n- [ ] 数据库的日志有哪几种？分别有什么用？\n- [ ] 数据库容灾怎么处理的？\n- [ ] 基于内存的缓存数据库如何共享？\n- [ ] Redis高性能的原因？\n- [ ] 设计模式、设计线程安全和单例的例子？\n- [ ] 冒泡和快排的平均时间复杂度和稳定性？\n- [ ] 联表有哪几种方式？\n\n\n\n\n","categories":["面试准备","面试复盘-网友分享"]},{"title":"Java面试复盘","url":"/posts/62634.html","content":"\n---\n\n## 2023.06.09\n### 满阳科技（现场面）\n- 已拿offer（周一入职）\n--- \n\n## 2023.06.08\n\n### 享连信息科技 （线上）\n- 由于电信面试6点才结束（包括笔试、机试），被错过时间\n\n### 电信（现场面）\n下午 15：00 - 18:00 多结束\n- 下周才有初步结果\n\n### 大自然（外包）\n\n- 技术栈\n  - SpringCloud + Vue\n- 项目周期\n  - 短期 （2个月）\n- 工作情况\n  - 无试用期、薪资全额\n---\n\n## 2023.06.07\n### 医耕天下（外包）\n\n\n  - 技术栈\n    - SpringBoot+jsp\n  - 确认时间\n    - 大概1天，有消息会进行二面\n  - 工作地点\n    - 重庆西南医院驻场开发\n  - 原本期待\n    - 永川区域内工作\n\n面试回顾：\n- [x] Docker的容器是否可以导出: [可以的](https://jld5.cn/wenda/201909191578.html)\n- [x] SpringBoot的外置配置文件有哪几种导入方式\n  - 我只回答出一个： import 导入\n- [ ] SpringBoot的配置文件优先级最高的是那种  \n- [x] [消息队列使用如何保证消息的不丢失](https://www.cnblogs.com/cnndevelop/p/12091348.html)\n\n---\n\n## 英之豪（外包）\n\n- [x] [JDK1.8的新特性](/posts/13923.html)\n- [ ] SpringMvc的循环依赖怎么解决\n- [x] [SpringBoot的依赖注入](/posts/62919.html)\n- [x] [Autowrite和Resource区别](/posts/62919.html)\n- [x] [线程池的使用](/posts/10804.html)\n- [ ] 如何增加线程\n- [X] [Mysql的如何判断走没有走索引](https://blog.csdn.net/weixin_52690231/article/details/124925897)\n- [X] Mysql的引擎是-Innodb\n- [ ] JVM的调优\n- [x] [Redis的分布式锁如何实现的](/posts/2567.html)\n- [x] [什么是AOP、IOC](https://blog.csdn.net/weixin_43824520/article/details/108266157)\n- [ ] 分布式事务\n\n ","categories":["面试准备","面试复盘-自我整理"],"tags":["个人相关"]},{"title":"酸奶购买小常识","url":"/posts/14124.html","content":"\n## 酸奶里的科技与狠活\n\n购买酸奶认准`三个字`，避免`两个字`\n\n<font color='green' size=100px > 👍发酵乳  </font> \n\n<font color='red' size=50px  >😒  风味 </font> \n\n \n>参考来源： 4.10 ipq:/ 复制打开抖音，看看【中国食品网的作品】酸奶里的科技狠活购买时认准3个字、避开2个字# 食... https://v.douyin.com/URkQwSc/","categories":["个人博客","生活常识"],"tags":["酸奶"]},{"title":"合同定金还是订金？","url":"/posts/26288.html","content":"\n> 参考： 1.23 DuF:/ 复制打开抖音，看看【樱小桃的作品】到底是定金还是订金 写错了很容易被骗 # 我要上热... https://v.douyin.com/UN8c8ps/\n>\n> \n\n## 定\n> **具有担保性质**\n\n买方交钱不买，卖方可以不退\n\n 卖方收钱不卖，卖方双倍赔偿 \n\n## 订\n> **不具备担保性质**\n \n双方不买或者不卖都得退钱\n","categories":["个人博客","生活常识"],"tags":["合同"]},{"title":"ICMPtimestamp请求响应漏洞处理(CVE-1999-0524)","url":"/posts/12224.html","content":"\n> 参考博客：[ICMP timestamp请求响应漏洞处理(CVE-1999-0524)](https://blog.csdn.net/ximenjianxue/article/details/123114342)\n\n\n## Iptables\n\n```\nvi /etc/sysconfig/iptables\n```\n\n```\n-A INPUT -p icmp -m icmp --icmp-type timestamp-request -j DROP\n-A OUTPUT -p icmp -m icmp --icmp-type timestamp-reply -j DROP\n```\n\n重启防火墙\n```\nservice iptables restart\n```\n\n## Firewalld\n\n\n\n添加防火墙规则\n```\nfirewall-cmd --permanent --zone=public --add-icmp-block=timestamp-reply\nfirewall-cmd --permanent --zone=public --add-icmp-block=timestamp-request\nfirewall-cmd --reload\n```\n   \n","categories":["技术博客","Linux"]},{"title":"允许Traceroute探测漏洞处理","url":"/posts/57813.html","content":"\n\n> 参考博客-Firewalld：[允许Traceroute探测漏洞解决方法](https://blog.csdn.net/hryzxjh/article/details/130572697)\n>\n> 参考博客-iptables：[允许Traceroute探测](https://blog.csdn.net/weixin_45760327/article/details/121207276)\n>\n>[漏洞解决](https://blog.csdn.net/tktttt/article/details/112048829)\n\n\n\n## 关闭Traceroute探测的方法\n\n### Firewalld防火墙\n\n```\nfirewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 0 -p ICMP --icmp-type 0 -m comment --comment \"deny traceroute\" -j DROP\n```\n\n```\nfirewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 0 -p ICMP --icmp-type 3 -m comment --comment \"deny traceroute\" -j DROP\n```\n\n```\nfirewall-cmd --permanent --direct --add-rule ipv4 filter OUTPUT 0 -p ICMP --icmp-type 11 -m comment --comment \"deny traceroute\" -j DROP\n```\n\n防火墙重新载入\n```\nfirewall-cmd --reload\n```\n\n查看防火墙规则\n```\nfirewall-cmd --direct --get-all-rules\n```\n\n### Iptables\n\n添加防火墙规则\n\n#### 重启失效\n```\niptables -A INPUT -p ICMP --icmp-type time-exceeded -j DROP\n```\n\n```\niptables -A OUTPUT -p ICMP --icmp-type time-exceeded -j DROP\n```\n\n保存规则\n```\nservice iptables save\n```\n\n#### 永久生效\nvi /etc/sysconfig/iptables\n```\n-A INPUT -p icmp -m icmp --icmp-type timestamp-request -j DROP\n-A OUTPUT -p icmp -m icmp --icmp-type timestamp-reply -j DROP\n```\n\n重启防火墙\n```\nservice iptables restart\n```\n\n检查新添加的规则是否有效\n```\niptables -L -n\n```","categories":["技术博客","Linux"]},{"title":"JavaGuide面试突击版-学习-0506-Java基础","url":"/posts/40038.html","content":"\n## JVM&JDK&JRE\n\n### JVM\nJava 虚拟机（JVM）是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM 实现是 Java 语⾔“⼀次编译，随处可以运⾏”的关键所在。\n\n==**JVM** 并不是只有⼀种！只要满⾜ JVM 规范，每个公司、组织或者个⼈都可以开发⾃⼰的专属JVM。==\n\n### JDK和JRE\n`JDK 是 Java Development Kit 缩写，它是功能⻬全的 Java SDK。`它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。\n\n`JRE 是 Java 运⾏时环境`。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它==不能⽤于创建新程序==。\n\n## 字节码\n`JVM` 可以理解的代码就叫做`字节码`（即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。\n\nJava 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。\n\n字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。\n\n### Java 是编译与解释共存的语⾔?\n\nJava程序从代码到运行: \n`.java -> javac编译 -> .class -> 解释器&JIT (编译器) -> 机器码 -> 运行`\n\n `JIT` 属于运⾏时编译。当 `JIT` 编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使⽤。机器码的运⾏效率肯定是⾼于 Java 解释器的。\n\n > `JDK 9` 引⼊了⼀种新的编译模式 `AOT`(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各⽅⾯的开销。\n\n\n## [Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？](/posts/59036.html)\n\n\n## 自增自减运算符\n```\n\nint a=0,b=1;\n\na = b++;\na = ++b;\n\n```\n==符号在前先加减;符号在后后加减==\n\n## 字符型常量和字符串常量的区别\n\n- 形式:\n  - 字符型常量: 单引号引起的⼀个字符\n  - 字符串常量: 双引号引起的 0 个或若⼲个字符\n- 含义:\n  - 字符型常量: ⼀个整型值( ASCII 值),可以参加表达式运算\n  - 字符串常量: ⼀个地址值(该字符串在内存中存放位置)\n- 内存:\n  - 字符型常量: 只占 2 个字节\n  - 字符串常量: 占若⼲个字节\n\n\n## 静态方法与实例方法区别?\n\n**1.调用方式:**\n\n**静态方法:**\n类名.方法名 / 对象.方法名\n\n**实例方法:**\n对象.方法名\n\n总结: ==**调⽤静态⽅法可以⽆需创建对象**==\n\n**2.访问类成员是否存在限制**\n\n**静态方法:**\n只允许访问`静态成员变量`和`静态方法`\n\n**实例方法:**\n没有限制\n\n## 重载和重写的区别?\n\n### 重载\n发生在同一个类中(或父类与之类之间),**方法名必须相同**,参数类型\\个数\\顺序不同,方法返回值和修饰符可以不同.\n\n==**重载**就是同⼀个类中多个同名⽅法根据不同的传参来执⾏不同的逻辑处理==\n\n\n### 重写\n\n[**⽅法的重写要遵循\"两同两⼩⼀⼤\"**](https://github.com/Snailclimb/JavaGuide/issues/892)\n- 必须相同\n  - 方法名\n  - 参数列表\n- 小于等于\n  - 子类方法返回值比父类方法返回值\n  - 抛出异常范围\n- 大于等于\n  - 访问修饰符\n\n\n**不能重写情况**\n- 父类方法修饰符`private\\final\\static`,但是通过`static`修饰的方法可以再次声明![](./JavaGuide面试突击版-学习-0506/Snipaste_2023-05-06_10-23-38.jpg \"截图来源: https://blog.csdn.net/YoaMy/article/details/51275388\")\n- 构造方法不能重写\n \n ==重写就是⼦类对⽗类⽅法的重新改造，外部样⼦不能改变，内部逻辑可以改变==\n\n### ⭐重写的返回值类型\n- 引用类型\n  - 可以返回引用类型的子类\n- void和基本数据类型\n  - ==**返回值重写时不可修改**==\n\n\n## 可变⻓参数\n> 可变长参数只能作为方法的最后一个参数,前面也可以没有任何参数!\n\n\n```\npublic static void method1( String ... args ){\n    // ...\n}\n\npublic static void method2( String a , String ... args ){\n    // ...\n}\n```\n\n**遇到⽅法重载的情况怎么办呢？**\n\n优先匹配固定参数的⽅法，因为固定参数的⽅法匹配度更⾼\n\n\n## 基本类型和包装类型的区别\n- 成员变量包装类型不赋值就是null,而基本类型有默认值且不是null\n- 包装类型可以用于泛型,而基本类型不可以\n- 相比对象类型,基本数据类型占用空间小\n- 存放位置\n  - 基础类型\n    - `局部变量`存在Java虚拟机的`栈`\n    - `成员变量`存在Java虚拟机的`堆`\n  - 包装类型\n    - 存在Java虚拟机的`堆` (包装类型属于对象类型)\n\n### 补充内容\n**三区介绍截图:**\n![](./JavaGuide面试突击版-学习-0506/Snipaste_2023-05-06_13-22-21.jpg \"截图来源: https://blog.csdn.net/YXXXYX/article/details/120126269\")\n\n基本介绍:\n> 成员变量是在  `类`  中定义的变量\n> \n> 局部变量是在  `方法`  中定义的变量\n> \n\n## 包装类的缓存机制\n\nByte\\Short\\Integer\\Long 包装类型默认数字[-128,127]相应类型缓存数据;\n\nCharacter 创建[0,127]范围的缓存数据;\n\nBoolean 直接返回`True`或`False`;\n\nFloat和Double 没有实现缓存机制;\n\n### Integer 源码\n```\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static {\n     // high value may be configured by property\n        int h = 127;\n    }\n}\n```\n\n问题-输出结果True还是False :\n```\nInteger i1 = 40;\nInteger i2 = new Integer(40);\nSystem.out.println(i1==i2);\n```\n\n结果是: False\n\n> `Integer i1 = 40`发生装箱,代码等价于` Integer i1 = Integer.valueOf(40) `, `i1` 使用的是缓存,而`Integer i2 = new Integer(40)`创建了一个新对象.\n\n#### 装箱拆箱何时发生\n> [Java中的装箱和拆箱—这一篇全了解](https://blog.csdn.net/w372426096/article/details/81909792)\n\n```\nInteger i = 10;  //装箱: 自动根据数值创建对应的 Integer对象，这就是装箱\nint n = i;   //拆箱: 自动将包装器类型转换为基本数据类型\n```\n\n==所有整型包装类对象之间值的⽐较，全部使⽤ equals ⽅法⽐较==\n\n![](./JavaGuide面试突击版-学习-0506/Snipaste_2023-05-06_13-43-09.jpg)\n\n\n## ⼀个类没有声明构造⽅法，该程序是否能正确\n\n答: ⼀个类没有声明构造⽅法，也可以执⾏\n\n> 一个类即使没有声明构造方法也会有默认的不带参数的构造方法.\n>\n> 如果重载了有参的构造方法,需要把无参的构造方法写出来,无论是否用到,因为一旦添加自己的构造方法,Java就不会在默认添加无参的构造方法.\n\n## 构造方法特点,是否可以Override\n构造方法特点:\n- 名字与类名相同\n- 没有返回值,不能使用void声明构造方法\n- 生成类的对象自动执行\n\n构造方法不能override(重写),但是可以overload(重载).\n\n## 面向对象的三大特征\n- 封装\n- 继承\n- 多态\n\n## 接口和抽象类的共同特点及区别\n\n### 共同特点\n- 不能实例化\n- 可以包含抽象方法\n- 可以默认实现方法(jdk8 之后可以用`default`关键字定义默认方法)\n\n### 区别\n- 接口用作对类行为的约束,实现了某个接口具有对应的行为;抽象类主要用户代码复用,强调所属关系.\n- 一个类只能继承一个类,但可以实现多个接口\n- 接口中的成员变量只能`public static final`类型的,不能修改且必须有初始值;抽象类中成员变量默认`default`,可在子类中重新定义,也可以重新赋值.\n\n## 引用拷贝和浅拷贝区别\n> [深拷贝和浅拷贝区别了解吗？什么是引用拷贝？·](/posts/30985.html)\n\n![](./JavaGuide面试突击版-学习-0506/Snipaste_2023-05-06_14-13-50.jpg)\n\n## == 和 equals() 区别\n> [==与equals?hashCode与equals?](/posts/33636.html)","categories":["整理归纳","面试问题解析汇总"],"tags":["Java基础"]},{"title":"JavaGuide面试突击版-学习-0507-Java基础","url":"/posts/23719.html","content":"\n\n---\n\n##  [String ,StringBuffer ,StringBuilder的区别?](/posts/21142.html)\n\n---\n\n## 字符串拼接用`+`还是`StringBuilder`\n\n\n\n [查看.class文件的字节码](/posts/51115.html)\n > 示例截图: 用的就是 `+` 拼接字符串示例\n\n 字符串对象通过`+`的字符串拼接⽅式，实际上是通过`StringBuilder`调⽤`append()`⽅法实现的，拼接完成之后调⽤`toString()`得到⼀个 `String`对象 。 \n\n\n **注意事项 :** \n 在循环内使⽤`+`进⾏字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 `StringBuilder` 以复⽤，会导致创建过多的 `StringBuilder`对象。\n\n---\n\n## String#equals() 和 Object#equals() 有何区别\n\nString : 比较的是值是否相等;\nObject : 比较的是对象的内存地址是否相等;\n\n---\n\n## 字符串常量池的作⽤\n\n**字符串常量池** 是 `JVM` 为了提升性能和减少内存消耗针对字符串（String 类）专⻔开辟的⼀块区域，主要⽬的是为了`避免字符串的重复创建`\n\n![](./JavaGuide面试突击版-学习-0507/Snipaste_2023-05-07_09-16-50.jpg)\n\n--- \n\n## 创建了⼏个字符串对象? `String s1 = new String(\"abc\");` \n\n> [String s1 = new String(“abc”) 这段代码创建了几个字符串对象？](/posts/10949.html)\n\n---\n\n## `String`类型的变量和常量做`+`运算时发生了什么?\n\n+++ **点击展开/隐藏**\n\n\n\n### 字符串不加`final`关键字拼接的情况\n```\nString str1 = \"str\"; //编译器确定常量字符串,jvm将其加入`字符串常量池`\nString str2 = \"ing\"; //编译器确定常量字符串,jvm将其加入`字符串常量池`\nString str3 = \"str\" + \"ing\"; //常量折叠: String str3 = \"string\"\nString str4 = str1 + str2; //引用的值在编译器无法确定,jvm无法将其优化\nString str5 = \"string\";\nSystem.out.println(str3 == str4);//false\nSystem.out.println(str3 == str5);//true\nSystem.out.println(str4 == str5);//false\n```\n\n**编译器的优化:**\n1. `编译期`可以确定的值的字符串,也就是`常量字符串`,`jvm`会将其存入`字符串常量池`.\n2. `字符串常量`拼接可以得到的`字符串常量`在`编译阶段`就`已经`被存放`字符串常量池`.\n\n编译器优化: **常量折叠**\n> 常量折叠会把常量表达式的值求出来作为常量嵌在最终⽣成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之⼀(代码优化⼏乎都在即时编译器中进⾏)。\n>\n> 例如: 对于 String str3 = \"str\" + \"ing\"; 编译器会给你优化成 String str3 = \"string\";\n\n常量折叠的条件:\n- `final`修饰 / 无`final`修饰的基本数据类型(byte,short,int,long,double,float,chat,boolean)及字符串常量\n- 运算关系\n  - 字符串通过`+`拼接得到的字符串\n  - 基本数据类型之间的算数运算(加减乘除),位运算(<<,>>,>>>)  \n\n#### 引⽤的值在程序编译期是⽆法确定的，编译器⽆法对其进⾏优化\n对象引⽤和“+”的字符串拼接⽅式，实际上是通过 StringBuilder 调⽤ append() ⽅法实现的，拼接完成之后调⽤ toString() 得到⼀个 String 对象\n```\nString str4 = new StringBuilder().append(str1).append(str2).toString();\n```\n### 声明`final`关键字之后,可以让编译器当作常量处理\n```\nfinal String str1 = \"str\";\nfinal String str2 = \"ing\";\n// 下⾯两个表达式其实是等价的\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 常量池中的对象\nSystem.out.println(c == d);// true\n```\n被 final 关键字修改之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。\n\n**截图参考**\n![](./JavaGuide面试突击版-学习-0507-Java基础/Snipaste_2023-05-08_07-18-41.jpg)\n\n没有`final`关键字修饰的字符串,字节码中通过`StringBuilder`拼接(属于新的对象,`==`用来比较`引用类型`是比较的内存地址是否相等)\n![](./JavaGuide面试突击版-学习-0507-Java基础/Snipaste_2023-05-08_07-23-31.jpg)\n\n#### 编译器在运⾏时才能知道其确切值的话，就⽆法对其优化\n```\nfinal String str1 = \"str\";\nfinal String str2 = getStr();\nString c = \"str\" + \"ing\";// 常量池中的对象\nString d = str1 + str2; // 在堆上创建的新的对象\nSystem.out.println(c == d);// false\npublic static String getStr() {\nreturn \"ing\";\n}\n```\n\n+++\n\n---\n\n## [Exception 和 Error 有什么区别？](/posts/60744.html)\n\n---\n\n## `try-catch-finally` 的使⽤\n\n**注意事项:**\n\n不要在`finally`语句块中使用`return`!\n> 当 try 语句和 finally 语句中都有 return 语句时，try 语句\n块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在⼀个本地变量中，当执⾏到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。\n\n代码示例:\n```\npublic static void main(String[] args) {\n    System.out.println(f(2));\n}\n\npublic static int f(int value) {\n    try {\n        return value * value;\n    } finally {\n        if (value == 2) {\n            return 0;\n        }\n    }\n}\n```\n\n输出:\n```\n0\n```\n\n### finally 中的代码是否⼀定会执⾏\n\n==不⼀定的！==\n\n不会执行`finally`中的代码情况如下:\n-  `finally` 之前虚拟机被终⽌运⾏的话\n-  程序所在线程死亡\n-  关闭CPU\n\n\n### try-catch-finally关闭资源?\n> [try-catch-finally关闭资源?](/posts/45288.html)\n\n --- \n\n\n\n## 什么是SPI\nSPI 即 Service Provider Interface ，字⾯意思就是: `服务提供者的接⼝`\n\n### API 和 API 的区别\n![](./JavaGuide面试突击版-学习-0507/Snipaste_2023-05-07_11-03-24.jpg)\n\n![](./JavaGuide面试突击版-学习-0507/Snipaste_2023-05-07_11-03-38.jpg)\n\nSPI : 由接口调用方确定规则,不同的接口实现方去根据这个接口进行实现,从而提供方服务.\n\n![](./JavaGuide面试突击版-学习-0507/Snipaste_2023-05-07_11-10-09.jpg)\n\n### SPI 的优缺点\n\n- 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对᫾低的\n- 当多个 `ServiceLoader` 同时 `load` 时，会有并发问题\n\n\n## 什么是序列化?什么是反序列化?\n\n**序列化:** 将数据结构或对象转换成⼆进制字节流的过程\n**反序列化:** 将在序列化过程中所⽣成的⼆进制字节流转换成数据结构或者对象的过程\n\n**序列化目的:** 序列化的主要⽬的是通过⽹络传输对象或者说是将对象存储到⽂件系统、数据库、内存中\n\n![](./JavaGuide面试突击版-学习-0507/Snipaste_2023-05-07_11-13-49.jpg)\n\n### 部分字段不想进⾏序列化处理\n`transient` 关键字的作⽤是：阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。\n\n注意事项:\n- 修饰变量，不能修饰类和⽅法\n- 在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int类型，那么反序列后结果就是 0 。\n- `static` 变量因为不属于任何`对象(Object)`，所以⽆论有没有 `transient` 关键字修饰，均不会被序列化。\n\n\n## Java IO 流\n- InputStream\\OutputStream 字节输入流\\字节输出流\n- Reader\\Writer 字符输入流\\字符输出流\n\n---\n\n## Java中设计模式\n> [JavaGuide|Java IO 设计模式总结](https://javaguide.cn/java/io/io-design-patterns.html)\n\n---\n\n## [BIO、NIO 和 AIO 的区别？](/posts/59996.html)\n","categories":["整理归纳","面试问题解析汇总"],"tags":["Java基础"]},{"title":"JavaGuide面试突击版-学习-0507-Java集合","url":"/posts/23720.html","content":"\n## List, Set, Queue, Map 四者的区别\n\n| 集合        |              | 是否顺序      | 是否重复 |\n| ----------- | -----------  | ----------- | ----------- |\n| List        |              |有序          |可\n| Set         |              |无序          |不可\n| Queue       |              |有序(按特定规则实现顺序)|可\n| Map         |     key      |无序          |不可重复\n| Map         |     value    |无序          |可\n\n---\n\n## 集合框架底层数据结构总结\n\n+++ **点击展开/隐藏**\n\n### List\n- ArrayList: Object[] 数组\n- Vector: Object数组\n- LinkedList: 双向链表(Jdk1.6之前循环链表,Jdk1.7取消了循环)\n\n### Set\n- HashSet(无序,唯一): 基于HashMap实现,底层采用HashMap保存元素\n- LinkedHashSet(有序,唯一): 是HashSet的子类,内部通过LinkedHashMap实现\n- TreeSet(有序,唯一): 红黑树(自平衡的排序二叉树)\n\n### Queue\n- PriorityQueue: Objecet实现二叉堆\n- ArrayQueue: Object数组 + 双指针\n\n### Map\n- HashMap:\n  - Jdk1.8之前: 数组+链表, 数组是主体,链表是为了解决哈希冲突(拉链法)\n  - Jdk1.8以后: 链表长度大于阈值(默认8),将链表转换红黑树以减少搜索时间\n- LinkedHashMap: 继承HashMap,在基础结构之上增加双向链表,保持键值对的插入顺序\n- HashTable: 数组+链表, 数组是主体,链表是为了解决哈希冲突\n- TreeMap: 红黑树(自平衡的二叉树)\n\n+++\n\n---\n\n## ArrayList 和 Vector 的区别\n- `ArrayList`是`List`的主要实现类,底层使用`Object[]`数组,适用于频繁的查找工作,`线程不安全`.\n- `Vector`是`List`的古老实现类,底层使用`Object[]`数组,`线程安全的`.\n\n---\n\n## ArrayList 与 LinkedList 区别\n\n+++ **点击展开/隐藏**\n\n- 线程是否安全: `ArrayList`和`LinkedList`都是不同步的,不保证线程安全.\n- 底层数据结构: `ArrayList`底层是`Object[]`数组,`LinkedList`底层使用的是`双向链表`(Jdk1.6为循环链表,Jdk1.7之后取消了循环)\n- 插入\\删除是否受元素位置影响: \n  - ArrayList采用数组储存,插入和删除元素的时间复杂度受元素位置的影响.\n    - 追加列表末尾: 时间复杂度O(~1~)\n    - 指定位置`i`插入/删除元素: 时间复杂度 O(~n-1~)\n  - `LinkedList` 采用链表储存\n    - 头尾插入/删除: 不受元素位置影响\n    - 指定位置`i`插入/删除元素: 时间复杂度 O(~n~)\n- 快速随机访问 (通过序号快速获取元素对象`get( int index )` ): \n  - ArrayList 支持\n  - LinkedList 不支持\n- 内存占用:\n  - ArrayList: 内存占用主要体现在list列表的结尾会预留一定的空间\n  - LinkedList: 每一个元素都要消耗比ArrayList更多的空间\n\n### 补充内容:\n\n#### 双向链表\n\n![](./JavaGuide面试突击版-学习-0507-Java集合/Snipaste_2023-05-07_14-13-28.jpg)\n\n#### 双向循环链表\n\n![](./JavaGuide面试突击版-学习-0507-Java集合/Snipaste_2023-05-07_14-13-44.jpg)\n\n+++\n\n---\n\n## [ArrayList 的扩容机制](https://javaguide.cn/java/collection/arraylist-source-code.html#%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90-arraylist-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6)\n\n---\n\n## ⽐较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\n\n<table>\n    <tr>\n        <td>接口实现类</td> \n        <td>集合</td> \n        <td>顺序</td> \n        <td>元素重复</td> \n        <td>线程安全</td> \n        <td>数据结构</td> \n        <td>应用场景</td> \n   </tr>\n    <tr>\n         <td  rowspan=\"3\">Set</td>    \n  \t\t   <td>HashSet</td> \n      \t <td > 无序 </td> \n         <td rowspan=\"3\">元素唯一</td> \n         <td rowspan=\"3\">不安全</td> \n         <td>哈希表（基于 HashMap 实现）</td> \n         <td>不需要保证元素插⼊和取出顺序的场景</td>         \n    </tr>\n    <tr>\n        <td>LinkedHashSet</td>       \t \n        <td > 有序 </td> \n         <td>链表和哈希表( 满足FIFO)</td>  \n         <td>于保证元素的插⼊和取出顺序满⾜ FIFO 的场景</td>           \n    </tr>\n    <tr>\n        <td>TreeSet</td> \n      \t <td> 有序(支持⾃然排序和定制排序) </td>          \n         <td>红黑树</td>         \n         <td>⽤于⽀持对元素⾃定义排序规则的场景</td>   \n    </tr>\n    \n</table>\n\n---\n\n## Queue 与 Deque 的区别\n\n略过\n\n---\n## HashMap和HashTable区别\n\n[HashMap和Hashtable的区别？HashMap和HashSet区别？HashMap和TreeMap区别？](/posts/3318.html)\n\n---\n\n// todo\n\n\n\n\n\n\n\n","categories":["整理归纳","面试问题解析汇总"],"tags":["Java集合"]},{"title":"try-catch-finally的使用?","url":"/posts/45288.html","content":"\n\n \n\n \n**使用try-catch-finally关闭资源情况**\n```\n//读取⽂本⽂件的内容\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"D://read.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} \nfinally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n```\n\n**使用try-with-resources关闭资源情况**\n\n声明单个资源要关闭的情况:\n```\n\ntry ( Scanner scanner = new Scanner(new File(\"test.txt\")) ) {   \n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} \n```\n\n声明多个资源要关闭情况:\n```\ntry (\n    BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(\"test.txt\"))); \n    BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(\"out.txt\")))\n) {\n    int b;\n    while ((b = bin.read()) != -1) {\n        bout.write(b);\n    }\n}\ncatch (IOException e) {\n    e.printStackTrace();\n}\n```\n \n ","categories":["整理归纳","面试问题解析汇总"]},{"title":"jvm内存结构","url":"/posts/62546.html","content":"\n# jvm 内存结构\n> [JVM内存结构和Java内存模型](https://zhuanlan.zhihu.com/p/38348646)\n\n## JVM内存结构\n\n![](./jvm内存结构/Snipaste_2023-04-29_10-13-19.jpg \"深入理解Java虚拟机（第2版）\")\n\nJVM内存结构大概分为：\n- 堆（Heap)：线程共享。所有对象的实例及数组都要在堆上分配。回收器的主要管理对象。\n- 方法区（Method Area）：线程共享。储存信息、常量、静态变量、即时编译后的代码。\n- 方法栈（JVM Stack）：线程私有。储存局部变量表、操作栈、动态链接、方法出口、对象指针。\n- 本地方法栈（Native JVM Stack）：线程私有。为虚拟机使用到的Native方法服务。如Java使用C或C++编写接口服务时，代码在此区运行。\n- 程序计数器（Program Counter Register）：线程私有。也叫PC寄存器，它可以看作是当前线程所执行字节码的行号指示器，指向下一条要执行的执行。\n\n**JVM内存结构的布局和相应的控制参数：**\n![](./jvm内存结构/Snipaste_2023-04-29_10-21-40.jpg)\n### 堆\n堆的主要作用是存放对象实例和数组。\n#### 结构划分\n- 新生代\n- 老年代\n#### 控制参数\n- -Xms设置堆的最小空间\n- -Xmx设置堆的最大空间\n- -XX:NewSize设置新生代最小空间\n- -XX:MaxNewSize设置新生代最大空间\n#### 垃圾回收\n垃圾回收的主要区域\n#### 异常情况\n`堆中没有内存完成实例分配`，并且`堆也无法再扩展`时，将会抛出`OutOfMemoryError`异常\n### 方法区\n方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的`类信息`、`常量`、`静态变量`、`即时编译器编译后的代码`等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做`Non-Heap（非堆）`，目的应该是与Java 堆区分开来。\n#### 控制参数\n- -XX:PermSize 设置最小空间\n- -XX:MaxPermSize 设置最大空间\n#### 垃圾回收\n对此区域会涉及但是`很少进行垃圾回收`。这个区域的内存回收目标主要是针对`常量池的回收和对类型的卸载`。\n#### 异常情况\n根据Java 虚拟机规范的规定， 当方法区`无法满足内存分配需求`时，将抛出`OutOfMemoryError`。\n### 方法栈\n`每个线程会有一个私有的栈`。每个线程中方法的调用又会在本栈中创建一个`栈帧`。在方法栈中会存放编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference） 类型，它不等同于对象本身。`局部变量`表所需的`内存空间在编译期间完成分配`，当进入一个方法时，这个方法需要在`帧中分配多大的局部变量空间是完全确定的`，在`方法运行期间不会改变局部变量表的大小`。\n#### 控制参数\n- -Xss控制每个线程栈的大小。\n#### 异常情况\n- `StackOverflowError`： 异常线程请求的栈深度大于虚拟机所允许的深度时抛出；\n- `OutOfMemoryError` 异常： 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出。\n### 本地方法栈\n本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其`区别`不过是`虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务`，而`本地方法栈`则是为`虚拟机使用到的Native 方法服务`。\n#### 控制参数\nSun JDK中本地方法栈和方法栈是同一个，因此也可以用`-Xss`控制每个线程的大小\n#### 异常情况\n与虚拟机栈一样，本地方法栈区域也会抛出`StackOverflowError `和`OutOfMemoryError`异常。\n### 程序计数器\n作用可以看做是`当前线程`所执行的`字节码的行号指示器`。\n#### 异常情况\n此内存区域是`唯一一个`在Java 虚拟机规范中`没有规定任何OutOfMemoryError 情况`的区域。\n\n ","categories":["整理归纳","面试问题解析汇总"]},{"title":"jvm调优参数","url":"/posts/7617.html","content":"\n# jvm 调优参数\n> [JVM常用调优参数 ——JVM篇](https://blog.csdn.net/m0_46316970/article/details/123585951)\n>> 这篇文章的大佬实在是太👍了!部分待更新内容等我先把其他消化理解了先.\n\n## 性能调优\n性能调优包含多个层次：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等等\n架构调优和代码调优是JVM调优的基础，**其中架构调优是对系统影响最大的**。\n性能调优基本步骤：\n- 发现性能瓶颈\n- 明确优化目标\n- 性能调优\n- 通过监控及数据统计工具获得调优后数据\n- 确认是否达到目标\n\n## 何时进行JVM调优\n- Heap内存（老年代）持续上涨达到设置的最大内存值；\n- Full GC 次数频繁；\n- GC 停顿时间过长（超过1秒）\n- 应用出现OutOfMemory等内存异常；\n- 应用中有使用本地缓存且占用大量内存空间；\n- 系统吞吐量与响应性能不高或不降。\n\n## JVM调优基本原则\n- 大多数的Java应用不需要进行JVM优化；\n- 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；\n- 上线之前，应先考虑将机器的JVM参数设置到最优；\n- 减少创建对象的数量（代码层面）；\n- 减少使用全局变量和大对象（代码层面）；\n- 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）;\n- 分析GC情况优化代码比优化JVM参数更好（代码层面）。\n\n**最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。**\n\n## JVM调优目标\n调优的最终`目的`都是为了`令应用程序使用最小的硬件消耗来承载更大的吞吐`。`JVM调优主要是针对垃圾收集器的收集性能优化`，`令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量`。\n- 延迟：GC低停顿和GC低频率；\n- 低内存占用；\n- 高吞吐量。\n\n## JVM调优量化目标\nJVM调优的量化目标参考实例：\n- Heap 内存使用率 <= 70%;\n- Old generation 内存使用率 <= 70%;\n- avgpause <= 1秒;\n- Full GC 次数 0 或 avg pause interval >= 24小时。\n\n**注意：不同应用的JVM调优量化目标是不一样的。**\n\n## JVM调优的步骤\nJVM调优可通过以下步骤进行：\n- 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；\n- 确定JVM调优量化目标；\n- 确定JVM调优参数（根据历史JVM参数来调整）；\n- 依次调优内存、延迟、吞吐量等指标；\n- 对比观察调优前后的差异；\n- 不断的分析和调整，直到找到合适的JVM参数配置；\n- 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n以上操作步骤中，某些步骤是需要`多次不断迭代完成`的。一般是从满足`程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化`，每一个步骤都是进行下一步的基础，不可逆行之。\n\n## JVM参数\n`-XX` 参数被称为不稳定参数。此类参数的设置很容易引起JVM性能上的差异，使 JVM 存在极大的不稳定性。如果此类参数`设置合理将大大提高JVM的性能及稳定性`。\n\n不稳定参数语法规则包含以下内容：\n- 布尔类型参数值\n  - -XX:+ 表示启用该选项\n  - -XX:- 表示关闭该选项\n- 数字类型参数值：\n  - XX: = 给选项设置一个数字类型值，可跟随单位。\n    - 例如：‘m’或‘M’表示兆字节；‘k’或‘K’千字节；‘g’或‘G’千兆字节。32K与32768是相同大小的。\n- 字符串类型参数值：\n  - -XX: = 给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。\n    - 如：-XX:HeapDumpPath=./dump.core\n  \n## JVM参数解析及调优\n\nJava7及以前版本的示例:\n```\n-Xmx4g \n–Xms4g \n–Xmn1200m \n–Xss512k \n-XX:NewRatio=4 \n-XX:SurvivorRatio=8 \n-XX:PermSize=100m \n-XX:MaxPermSize=256m \n-XX:MaxTenuringThreshold=15\n```\n在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。\n\n\n参数解析:\n- -Xmx4g：堆内存最大值为4GB\n- -Xms4g：初始化堆内存大小为4GB\n- -Xmn1200m：设置年轻代大小为1200MB\n  - 增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8\n- -Xss512k：设置每个线程的堆栈大小。\n  - JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n- -XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）\n  - 设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n- -XX:SurvivorRatio=8: 设置年轻代中Eden区与Survivor区的大小比值。\n  - 设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10\n- -XX:PermSize=100m：初始化永久代大小为100MB。\n- -XX:MaxPermSize=256m：设置持久代大小为256MB。\n- -XX:MaxTenuringThreshold=15：设置垃圾最大年龄。\n  - 如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n\n新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。\n\n可调优参数:\n- -Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。\n- -Xmx：**堆内存最大值。**默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。\n- -Xmn：新生代大小，包括Eden区与2个Survivor区\n- -XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。\n- -XX:MaxDirectMemorySize=1G：**直接内存。**报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。\n- -XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。\n- 注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。\n- -XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。\n- -XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。\n- -XX:ParallelGCThreads=8：新生代并行收集器的线程数。\n- -XX:MaxTenuringThreshold=10：**设置垃圾最大年龄。**如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n- -XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。\n- -XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。\n\n注意：在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。\n\n## 内存优化示例\n![](./jvm调优参数/Snipaste_2023-04-29_11-40-19.jpg)\n以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。\n\n- java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n- 永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久代空间占用。\n- 新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n- 老年代：2-3倍FullGC后的老年代空间占用。\n\n基于以上规则，则对参数定义如下：\n```\n-Xms373m -Xmx373m //4*93=372\n-Xmn140m //1.5*93=139.5\n-XX:PermSize=5m -XX:MaxPermSize=5m //1.5*3=4.5\n```\n\n## 吞吐量调优\n## 调优工具\n借助GCViewer日志分析工具，可以非常直观地分析出待调优点。\n- Memory，分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；\n- Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；\n\n## 总结JVM参数使用手则\n### 内存相关\n### GC策略相关\n### GC日志相关\n### 异常相关\n### 问题定位及优化相关\n\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"==与equals?hashCode与equals?","url":"/posts/33636.html","content":"\n## == 与 equals?hashCode 与 equals ?\n> [【CSDN】== 和 equals 的区别](https://blog.csdn.net/meism5/article/details/89029475)\n\n **== ：**\n `==`是操作符\n > 基本类型：比较值是否相等 （byte,short,char,int,long,float,double,boolean）\n > \n > 引用类型：比较堆内存地址是否相等 （new一个引用类型的对象，会重新分配堆内存空间，使用==比较返回false）\n\n 补充：`==`运行速度比`equals()`快，因为==只是比较引用\n \n\n**equals：**　　\n`equals()`是Object类的一个方法，Java当中所有的类都是继承于Object这个超类。\n> 引用类型：默认情况下，比较内存地址值是否相等\n> `一般重写都是自动生成，比较对象的成员变量值是否相同` \n　　\n\n*hashCode 与 equals ?*\n> [【CSDN】java基础：hashCode() equals()总结](https://blog.csdn.net/maligebilaowang/article/details/129663874)\n\n*equals()性质：*\n1. 自反性（reflexive）。对于任意不为null的引用值x，x.equals(x)一定是true。\n2. 对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。\n3. 传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。\n4. 一致性（consistent）。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。\n5. 非空性。对于任意不为null的引用值x，x.equals(null)返回false。\n\n> 需要注意的是当equals()方法被override时，hashCode()也要被override。按照一般hashCode()方法的实现来说，相等的对象，它们的hash code一定相等。\n \n\n*hashCode()方法*\n> hashCode()方法给对象返回一个hash code值。\n\n1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；\n2. 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；\n3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；\n4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”\n\n\n## 补充: [为什么要有hashCode?](/posts/42174.html)\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"什么是类加载？何时类加载？类加载流程？","url":"/posts/26747.html","content":"\n# 类加载\n> [Java类加载机制](https://zhuanlan.zhihu.com/p/25228545)\n\n## 什么是类加载\n\n加载和初始化，是类生命周期的两个阶段。\n\n\n\n## 何时类加载\n\n对于什么时候加载，Java虚拟机规范中并没有约束，各个虚拟机都可以按自身需要来自由实现。但绝大多数情况下，都遵循“什么时候初始化”来进行加载。\n\n什么时候初始化？Java虚拟机规范有明确规定，当符合以下条件时（包括但不限于），虚拟机内存中没有找到对应类型信息，则必须对类进行“初始化”操作：\n- 使用new实例化对象时、读取或者设置一个类的静态字段或方法时\n- 反射调用时，例如 Class.forName(\"com.xxx.MyTest\")\n- 初始化一个类的子类，会首先初始化子类的父类\n- Java虚拟机启动时标明的启动类\n- JDK8 之后，接口中存在default方法，这个接口的实现类初始化时，接口会其之前进行初始化\n\n> 初始化阶段开始之前，自然还是要先经历 加载、验证、准备 、解析的。\n\n## 类加载流程\n类的加载过程分 5 个阶段，其中 验证、准备、解析 可以归纳为 “连接” 阶段。\n![](./什么是类加载？何时类加载？类加载流程？/Snipaste_2023-04-29_11-49-53.jpg)\n\n需要注意的是，这5个阶段，并不是严格意义上的按顺序完成，在类加载的过程中，这些阶段会互相混合，交叉运行，最终完成类的加载和初始化。\n\n### 加载\n1. 通过一个类的全限定名去找到其对应的.class文件\n2. 将这个.class文件内的二进制数据读取出来，转化成方法区的运行时数据结构\n3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口\n> Java虚拟机并没有规定类的字节流必从.class文件中加载，在加载阶段，程序员可以通过自定义的类加载器，自行定义读取的地方，例如通过网络、数据库等。\n\n\n### 验证\nClass文件中的内容是字节码，这些内容可以由任何途径产出，验证阶段的目的是保证文件内容里的字节流符合Java虚拟机规范，且这些内容信息运行后不会危害虚拟机自身的安全。\n#### 文件格式验证\n验证字节流是否符合Class文件格式的规范。例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型 ...... 等等\n#### 元数据验证\n对字节码描述的元数据信息进行语义分析，要符合Java语言规范。例如：是否继承了不允许被继承的类（例如final修饰过的）、类中的字段、方法是否和父类产生矛盾 ...... 等等\n#### 字节码验证\n对类的方法体进行校验分析，确保这些方法在运行时是合法的、符合逻辑的。 \n#### 符号引用验证\n发生在解析阶段，符号引用转为直接引用的时候，例如：确保符号引用的全限定名能找到对应的类、符号引用中的类、字段、方法允许被当前类所访问 ...... 等等\n\n> 验证阶段不是必须的，虽然这个阶段非常重要。Java虚拟机允许程序员主动取消这个阶段，用来缩短类加载的时间，可以根据自身需求，使用 -Xverify:none参数来关闭大部分的类验证措施。\n>\n\n### 准备\n这个阶段，类的静态字段信息（即使用 static 修饰过的变量）会得到内存分配，并且设置为初始值。\n\n该阶段有以下几个知识点需要注意： \n1. 内存分配仅包括 static 修饰过的变量，而不包括实例变量，实例变量得等到对象实例化时分配内存。\n2. 初始值指的是变量数据类型的默认值，而不是被在Java代码中被显式地赋予的值。但是，当字段信息被 final 修饰成常量（ConstantValue）时，这个初始值就是Java代码中显式地赋予的值。\n>例如：public static int value = 3\n类变量 value 在准备阶段设置的初始值是 0，不是 3。把value赋值为3的 putstatic 指令是在程序编译后，存放于类构造器 <clinit>() 方法中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。\n当使用 final 修饰后：public static final int value = 3\n类变量 value 在准备阶段设置的初始值是 3，不是 0。\n3. 在JDK8取消永久代后，方法区变成了一个逻辑上的区域，这些类变量的内存实际上是分配在Java堆中的。\n\n### 解析\n虚拟机会把这个Class文件中，常量池内的符号引用转换为直接引用。主要解析的是 类或接口、字段、类方法、接口方法、方法类型、方法句柄等符号引用。我们可以把解析阶段中，符号引用转换为直接引用的过程，理解为当前加载的这个类，和它所引用的类，正式进行“连接“的过程。\n\n### 初始化\n初始化的过程，就是执行类构造器 <clinit>()方法的过程。\n\n当初始化完成之后，类中static修饰的变量会赋予程序员实际定义的“值”，同时类中如果存在static代码块，也会执行这个静态代码块里面的代码。\n\n### 加载过程总结\n当一个符合Java虚拟机规范的字节流文件，经历 加载、验证、准备、解析、初始化这些阶段相互协作执行完成之后，加载阶段读取到的Class字节流信息，会按虚拟机规定的格式，在方法区保存一份，然后Java 堆中，会创建一个 java.lang.Class 类的对象，这个对象描述了这个类所有信息，也提供了这个类在方法区的访问入口。\n\n> 方法区中，使用同一加载器的情况下，每个类只会有一份Class字节流信息\n> Java堆中，使用同一加载器的情况下，每个类只会有一份 java.lang.Class 类的对象\n\n\n## 类加载器\n\n还记得在加载阶段，通过类的全限定名，获取该类字节流数据的这个动作么，类加载器就是用来实现这个动作的。\n\n当年为了满足浏览器上 Java Applet 的需求，Java的开发团队设计了类加载器，它独立于Java虚拟机外部，允许程序员按自身需要自行实现类加载器。这是一项非常优秀的创新，它让同一个类可以实现访问隔离、OSGi、程序热部署等等。发展至今，类加载器已经是Java技术体系的一块重要基石。\n\n### 三层类加载器介绍\n#### 启动类加载器（Bootstrap Class Loader）\n负责加载<JAVA_HOME>\\lib 目录，或者被 -Xbootclasspath 参数制定的路径，例如 jre/lib/rt.jar 里所有的class文件。由C++实现，不是ClassLoader子类。\n#### 拓展类加载器（Extension Class Loader）\n负责加载Java平台中扩展功能的一些jar包，包括<JAVA_HOME>\\lib\\ext 目录中 或 java.ext.dirs 指定目录下的jar包。由Java代码实现。\n#### 应用程序类加载器（Application Class Loader）\n我们自己开发的应用程序，就是由它进行加载的，负责加载ClassPath路径下所有jar包。 \n\n## 双亲委派模型\n> 双亲委派模式其实一句话就可以说清楚：任何一个类加载器在接到一个类的加载请求时，都会先让其父类进行加载，只有父类无法加载（或者没有父类）的情况下，才尝试自己加载。\n>\n>\n![](./什么是类加载？何时类加载？类加载流程？/Snipaste_2023-04-29_12-00-01.jpg)\nClassLoader 类中有示例:\n```\nprotected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException\n{\n    // 首先要保证线程安全\n    synchronized (getClassLoadingLock(name)) {\n        // 先判断这个类是否被加载过\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            try {\n                // 有父类，优先交给父类尝试加载\n                if (parent != null) {\n                    c = parent.loadClass(name, false);\n                } else {\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // 父类加载失败，这里捕获异常，但不需要做任何处理\n            }\n\n            if (c == null) {\n                // 没有父类，或者父类无法加载，尝试自己加载\n                c = findClass(name);\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n```\n\n\n### 双亲委派模型好处\n在解答这个问题前，需要先了解一个知识点：不同的类加载器，加载同一个类，结果是虚拟机里会存在两份这个类的信息，所以当判断这两个类是否“相等”时，必定是不相等的。\n\n使用双亲委派模式，可以保证，每一个类只会有一个类加载器。例如Java最基础的Object类，它存放在 rt.jar 之中，这是 Bootstrap 的职责范围，当向上委派到 Bootstrap 时就会被加载。\n\n但如果没有使用双亲委派模式，可以任由自定义加载器进行加载的话，Java这些核心类的API就会被随意篡改。\n\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"BIO,NIO,AIO有什么区别?","url":"/posts/59996.html","content":"## BIO,NIO,AIO 有什么区别?\n> [【CSDN】BIO、NIO、AIO 有什么区别？](https://blog.csdn.net/meism5/article/details/89469101)\n\n- BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。\n- NIO：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。\n- AIO：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。\n\n<br>\n\n- BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。\n- NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。\n- AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。","categories":["整理归纳","面试问题解析汇总"]},{"title":"Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？","url":"/posts/59036.html","content":"\n## Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？\n> [【CSDN】Java基本数据类型有哪些？他们分别占几个字节？为什么？](https://blog.csdn.net/zhang_java_11/article/details/115171350)\n> \n> [【知乎】Java包装类](https://zhuanlan.zhihu.com/p/49970755)\n\n\n\n> Java中提供了**8**种基本类型。\n\n\n|基本类型 |包装类型  |区别    | 占用字节 |\n|  ----  | ----     |----   | ----    |\n| byte   | Byte     |整数类型| 1个字节\n| short  | Short    |整数类型| 2个字节\n| int    | Integer  |整数类型| 4个字节\n| long   | Long     |整数类型| 8个字节\n| float  | Float    |浮点类型| 4个字节\n| double | Double   |浮点类型| 8个字节\n| char   | Character|字符类型| 2个字节\n| boolean| Boolean  |布尔类型| boolean单个占4个字节，boolean数组1个字节\n\n\n问：一个汉字占用几个字节？\n> 答：这和编码有关，UTF8一个汉字占3个字节，GBK一个汉字占2个字节。\n\n\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"Exception和Error有什么区别？","url":"/posts/60744.html","content":"\n \n## Exception 和 Error 有什么区别？\n\n`Error`和`Exception`都属于`java.lang`包中`Trhowable`的子类.\n\n### Exception\n\n程序本身可以处理的异常.可以通过`catch`来捕获. 异常又分为`Checked Exception(受检查异常,必须处理)`和`Unchecked Exception(不受检查异常,可以不处理)`\n\n### Error\n\n属于程序无法处理的错误.例如: Java虚拟机错误(Virtual MachineError)、虚拟机内存不够错误( OutOfMemoryError )、类定义错误（ NoClassDefFoundError ）等 。这些异常发⽣时，Java 虚拟机（JVM）⼀般会选择线程终⽌.\n\n\n ## 拓展: Checked Exception 和 Unchecked Exception 有什么区别?\n\n ![](./Exception和Error有什么区别？/Snipaste_2023-05-07_10-27-50.jpg)\n\n ![](./Exception和Error有什么区别？/Snipaste_2023-05-07_10-29-27.jpg)\n \n ","categories":["整理归纳","面试问题解析汇总"]},{"title":"Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？","url":"/posts/43267.html","content":"\n## Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\n\n**反射的优点：**\n1. 增加程序的灵活性，避免将程序写死到代码里\n2. 代码简洁，提高代码的复用率，外部调用方便\n3. 对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法\n   \n**反射的缺点：**\n1. 性能问题\n2. 安全限制\n3. 程序健壮性","categories":["整理归纳","面试问题解析汇总"]},{"title":"Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？","url":"/posts/47052.html","content":"\n## Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？\n> [Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？](https://blog.csdn.net/qq_41356873/article/details/108823040)\n\nJava的泛型是**伪泛型**，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说`类型擦除`。\n\n**常用的通配符：**  ?,T,K,V,E\n\n- ？ 表示不确定的 java 类型\n- T (type) 表示具体的一个java类型\n- K V (key value) 分别代表java键值中的Key Value\n- E (element) 代表Element\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"Strings1=newString(abc);这段代码创建了几个字符串对象？","url":"/posts/10949.html","content":"\n\n## String s1 = new String(\"abc\") 这段代码创建了几个字符串对象？\n> ⭐ [【博客园】String s=new String(\"abc\")创建了几个对象?](https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html \"解析讲解的比较好\")\n\n\n\n```\n字符串 \"abc\" 是一个对象\nnew String() 这里使用new又创建了一个对象\n```\n\n1. 如果字符串常量池中不存在字符串对象“abc”的引⽤，那么会在堆中创建 2 个字符串对象“abc”。\n2. 如果字符串常量池中已存在字符串对象“abc”的引⽤，则只会在堆中创建 1 个字符串对象“abc”。\n\n\n\n> 答案 :  **会创建 1 或 2 个字符串对象**\n> \n\n<br>\n\n\n*例题解析：*\n\n```\n#创建了一个String对象\nString str=\"abc\"; \n\n#创建了一个String对象\nString a=\"abc\";  String b=\"abc\";\n\n#创建了三个String对象\nString a=\"ab\"+\"cd\";\n\n```\n> 在JAVA虚拟机（JVM）中存在着一个**字符串池**，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。\n> \n> `String a=\"abc\"`，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为\"abc\"的这么一个对象，它的判断依据是`String类equals(Object obj)`方法的返回值。\n> 如果有，则不再创建新的对象，直接返回已存在对象的引用；\n> 如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。\n\n*哪些情况下可以加入字符串池？*\n> 只有使用**引号包含文本**的方式创建的String对象之间使用“+”连接产生的新对象才会被**加入字符串池**中。\n> 对于所有包含**new方式新建对象（包括null）的“+”连接表达式**，它所产生的新对象都**不会被加入字符串池**中\n\n*扩充知识点：*\n> 栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。\n>\n> 堆（heap）：用于存储对象。\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"String、StringBuffer和StringBuilder的区别是什么?String为什么是不可变的?","url":"/posts/21142.html","content":"\n\n\n## String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?\n> [【CSDN】String、StringBuffer、StringBuilder的区别——（详细叙述）](https://blog.csdn.net/Turniper/article/details/111112824)\n>\n> [【知乎】如何理解 String 类型值的不可变？](https://www.zhihu.com/question/20618891 \"摘选`JavaGuide`回答\")\n\n**String 、 StringBuffer 和 StringBuilder 的区别**\n|          |String          |StringBuffer        | StringBuilder \n|  ----    | ----           |----                | ----    \n| 执行速度  | 最差           |其次                | 最高\n| 线程安全  | 线程安全       |线程安全             | 线程不安全\n| 使用场景  | 少量字符串操作  |多线程环境下的大量操作| 单线程环境下的大量操作\n\n**String 为什么是不可变的?**\n```\n\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence,Constable, ConstantDesc {\n    private final byte[] value;\n    //...\n}\n```\n- String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变\n- 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法\n\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"内部类了解吗？匿名内部类了解吗？","url":"/posts/19656.html","content":"## 内部类了解吗？匿名内部类了解吗？\n\n> [【CSDN】Java的内部类和匿名类 ， 您了解过吗？](https://blog.csdn.net/qq_41464123/article/details/107480664)\n\n**内部类：**\n内部类就是类中类，依附于普通类中，可以间接实现Java类的多继承。\n\n1. 成员内部类：就是内部类作为一个成员，存在于类中。\n   `实例化方法：   外部类.内部类 内部类对象 = new 外部类().new 内部类();`\n2. 静态内部类，在成员内部类的基础上，多了一个static关键字，是静态的类，所有的对象都可以直接通过类名调用。\n   `实例化方法：   内部类 内部类对象 = new new 内部类(); `\n3. 方法内部类，在类的方法中，定义内部类。\n   `实例化方法：   new 内部类().内部类方法();   注意只能在当前方法中实例化。`\n4. 匿名内部类，直接new一个没有名字的类，并且直接调用其中的方法。\n   `实例化方法：    new 内部类(){ ...... }.内部类中的方法();`\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"包装类型的缓存机制了解么？","url":"/posts/48309.html","content":"## 包装类型的缓存机制了解么？\n[【CSDN】java 包装类的缓存机制](https://blog.csdn.net/chenchuxu/article/details/78725966)\n\n> Integer 、Byte 、Short 、Long 、Character 五大包装类都有缓冲机制，且缓冲的默认值范围都是-128~127\n>\n> Float,Double,Boolean 三大包装类并没有缓冲机制\n\n1. 前提：发生自动装箱的过程（基本类型–>包装类型）\n2. 机制：当通过自动装箱机制创建包装类对象时，首先会判断数值是否在-128—-127的范围内，如果满足条件，则会从缓存（常量池）中寻找指定数值，若找到缓存，则不会新建对象，只是指向指定数值对应的包装类对象，否则，新建对象。\n3. `原理-请查阅参考博客资料`\n4. 缓存的作用\n在缓存值范围内的对象可以直接在常量池中取出，不用创建新的对象；\n当需要频繁的使用同一对象的时候，如果有缓存，则可以避免重复创建同一对象，节省空间开销和时间消耗，提升了性能 ","categories":["整理归纳","面试问题解析汇总"]},{"title":"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？","url":"/posts/30985.html","content":"\n## 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\n\n**浅拷贝和深拷贝的区别**\n> [【CSDN】引用拷贝、浅拷贝和深拷贝区别](https://blog.csdn.net/MirkoWug/article/details/108889116)\n\n拷贝一般分为二大类 **引用拷贝** 和 **对象拷贝**，我们通常讲的**深拷贝**和**浅拷贝**都属于对象拷贝\n\n**浅拷贝**只复制对象的指针，指向同一块内存，而**深拷贝**复制对象本身，创建一个新的内存，修改一个对象不会影响另一个对象。\n\n>**浅拷贝**的属性如果是引用类型，会共享同一个地址，**深拷贝**的属性如果是引用类型，会拷贝地址指向的内存\n\n\n\n**引用拷贝**\n顾名思义，即是对引用地址的拷贝，说明引用地址一样，指向堆中的对象是同一个对象。\n如果对一个对象进行改变，其他对象也会跟着改变。\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"自动装箱与拆箱了解吗？原理是什么？","url":"/posts/13955.html","content":"\n## 自动装箱与拆箱了解吗？原理是什么？\n> [【博客园】如何理解Java中的自动拆箱和自动装箱？](https://www.cnblogs.com/niceyoo/p/12977541.html)\n>\n\n> 定义：基本数据类型和包装类之间可以自动地相互转换\n>\n> 理解：装箱就是自动将基本数据类型转换为封装类型，拆箱就是自动将封装类型转换为基本数据类型。\n>\n```\n// 自动装箱\n1. Integer a = 100;\n// 自动拆箱\n2. int b = a;\n```\n自动**装箱**，相当于Java编译器替我们执行了 `Integer.valueOf(XXX)`;\n\n自动**拆箱**，相当于Java编译器替我们执行了 `Integer.intValue(XXX)`;\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"ConcurrentHashMap和Hashtable的区别？","url":"/posts/12495.html","content":"# ConcurrentHashMap 和 Hashtable 的区别？\n\nConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的⽅式上不同。\n\n- 底层数据结构：\n  - ConcurrentHashMap\n    - JDK 1.7：ConcurrentHashMap 底层采⽤`分段的数组+链表`实现\n    - JDK1.8 : ConcurrentHashMap 底层采⽤采⽤的数据结构跟 HashMap1.8 的结构⼀样，`数组+链表/红⿊⼆叉树`。\n  - Hashtable: Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采⽤ `数组+链表` 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的\n- <font color='red'>实现线程安全的方式：</font>\n  - ConcurrentHashMap：\n    - JDK 1.7: ConcurrentHashMap 对整个桶数组进⾏了分割分段( Segment ，分段锁)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。\n    - JDK 1.8: Node 数组+链表+红⿊树的数据结构来实现，并发控制使⽤ synchronized 和 CAS 来操作。\n  - HashTable (同⼀把锁) : 使⽤ synchronized 来保证线程安全，效率⾮常低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。\n  \n  <br>\n\n  **数据结构：**\n  ![](Snipaste_2023-04-28_08-04-59.jpg)\n  ![](Snipaste_2023-04-28_08-05-24.jpg)\n  ![](Snipaste_2023-04-28_08-06-00.jpg)\n       \n","categories":["整理归纳","面试问题解析汇总"]},{"title":"ConcurrentHashMap线程安全的具体实现方式/底层具体实现","url":"/posts/19235.html","content":"# ConcurrentHashMap 线程安全的具体实现方式/底层具体实现\n\n**JDK 1.8 之前**\n![](Snipaste_2023-04-28_08-10-38.jpg)\n\n`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成。\n\n`Segment` 继承了 `ReentrantLock` ,所以 `Segment` 是⼀种可重⼊锁，扮演锁的⻆⾊。 `HashEntry` ⽤于\n存储键值对数据。\n```\nstatic class Segment<K,V> extends ReentrantLock implements Serializable {}\n```\n\n⼀个 `ConcurrentHashMap` ⾥包含⼀个 `Segment` 数组， `Segment` 的个数⼀旦初始化就不能改变。\n`Segment` 数组的⼤⼩默认是 16，也就是说默认可以同时⽀持 16 个线程并发写。`Segment` 的结构和 HashMap 类似，是⼀种数组和链表结构，⼀个 `Segment` 包含⼀个 HashEntry数组，每个 HashEntry 是⼀个链表结构的元素，每个 `Segment` 守护着⼀个 HashEntry 数组⾥的元素，当对 HashEntry 数组的数据进⾏修改时，必须⾸先获得对应的 `Segment` 的锁。也就是说，对同⼀ `Segment` 的并发写⼊会被阻塞，不同 `Segment` 的写⼊是可以并发执⾏的。\n\n\n## JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？\n- 线程安全实现⽅式:\n  - JDK 1.7 采⽤ Segment 分段锁来保证安全， Segment 是继承⾃ReentrantLock 。\n  - JDK1.8 放弃了 Segment 分段锁的设计，采⽤ Node + CAS + synchronized 保证线程安全，锁粒度更细， synchronized 只锁定当前链表或红⿊⼆叉树的⾸节点。\n- Hash 碰撞解决⽅法:\n  - JDK 1.7 采⽤拉链法，JDK1.8 采⽤拉链法结合红⿊树（链表⻓度超过⼀定阈值时，将链表转换为红⿊树）\n- 并发度: \n  - JDK 1.7 最⼤并发度是 Segment 的个数，默认是 16。JDK 1.8 最⼤并发度是 Node 数组的⼤⼩，并发度更⼤。\n\n**JDK 1.8 之后**\n![](Snipaste_2023-04-28_08-14-15.jpg)\n\n`ConcurrentHashMap` 取消了 `Segment` 分段锁，采⽤ `Node + CAS + synchronized` 来保证并发安全。数据结构跟 HashMap 1.8 的结构类似，`数组+链表/红⿊⼆叉树`。Java 8 在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红⿊树（寻址时间复杂度为 O(log(N))）。\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"HashMap和Hashtable的区别？HashMap和HashSet区别？HashMap和TreeMap区别？","url":"/posts/3318.html","content":"# HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？\n\n## HashMap 和 Hashtable 的区别\n> [HashMap和Hashtable的区别](https://blog.csdn.net/xuhuaabc/article/details/91475761)\n\n1. 继承的父类不同\n   1. HashMap继承自AbstractMap类。但二者都实现了Map接口\n   2. Hashtable继承自Dictionary类，Dictionary类是一个已经被废弃的类（见其源码中的注释）。\n2. HashMap线程不安全,HashTable线程安全\n3. 包含的contains方法不同\n   1. HashMap是没有contains方法的，而包括containsValue和containsKey方法；\n   2. hashtable则保留了contains方法，效果同containsValue,还包括containsValue和containsKey方法。\n4. 是否允许null值\n   1. Hashmap是允许key和value为null值的，用containsValue和containsKey方法判断是否包含对应键值对\n   2. HashTable键值对都不能为空，否则包空指针异常。\n5. 计算hash值方式不同\n6. 扩容方式不同（容量不够）\n   1. 当容量不足时要进行resize方法，而resize的两个步骤\n      1. 扩容\n      2. rehash\n         1. HashMap 哈希扩容必须要求为原容量的2倍，而且一定是2的幂次倍扩容结果，而且每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入；\n         2. Hashtable扩容为原容量2倍加1；\n7. 解决hash冲突方式不同（地址冲突）\n   1. Jdk1.8后，HashMap中，当出现冲突时可以（Jdk1.8之前这里不论述）\n      1. 如果冲突数量小于8，则是以链表方式解决冲突。\n      2. 当冲突大于等于8时，就会将冲突的Entry转换为**红黑树进行存储。**\n      3. 而又当数量小于6时，则又转化为链表存储\n\n\n## HashMap 和 HashSet 的区别\n> [HashSet与HashMap的区别](https://blog.csdn.net/huhahuha_/article/details/84450967)\n>\n\n区别-储存方式：\n- HashSet实现了Set接口, 仅存储对象; \n- HashMap实现了 Map接口, 存储的是键值对;\n\n相同点-底层实现：\n- HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.\n\n\n## HashMap 和 TreeMap 的区别\n> [HashMap与TreeMap的区别](https://blog.csdn.net/zhangguofengqiang/article/details/52706237)\n\n\n\n相同点：\n- 继承了AbstractMap\n  \n\n不同点：\n- 线程安全：\n  - HashMap非线程安全\n  - TreeMap非线程安全\n- 调优选项：\n  - HashMap 基于哈希表实现，可以调优初始容量和负载因子 \n  - 基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。\n- 应用场景：\n  - 适用于在Map中插入、删除和定位元素。\n  - 适用于按自然顺序或自定义顺序遍历键(key)。\n- 速度效率：\n  - HashMap通常比TreeMap快一点（树和哈希表的数据结构使然）\n- 是否有序\n  - HashMap 无序\n  - TreeMap 有序，默认按键值升序、可指定排序比较器实现自定义排序规则\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"HashMap的底层实现","url":"/posts/34725.html","content":"# HashMap 的底层实现\n\n## JDK1.8之前\nJDK1.8 之前 HashMap 底层是 `数组`和`链表` 结合在⼀起使⽤也就是`链表散列`。\n\n所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建⼀个链表数组，数组中每⼀格就是⼀个链\n表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n![](Snipaste_2023-04-28_07-50-09.jpg)\n\n\n## JDK1.8之后\nJDK1.8 之后在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间。\n![](Snipaste_2023-04-28_07-49-57.jpg)\n\n\n> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都⽤到了红⿊树。红⿊树就是为了解决⼆叉查找树的缺陷，因为⼆叉查找树在某些情况下会退化成⼀个线性结构。\n>\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"HashMap的长度为什么是2的幂次方","url":"/posts/23150.html","content":"# HashMap 的长度为什么是 2 的幂次方\n\n为了能让 HashMap 存取⾼效，尽量减少碰撞，也就是要尽量把数据分配均匀。我们上⾯也讲到了过了，Hash 值的范围值-2147483648 - 2147483647，前后加起来⼤概 40 亿的映射空间，只要哈希函数映射得⽐较均匀松散，⼀般应⽤是很难出现碰撞的。\n但问题是⼀个 40 亿⻓度的数组，内存是放不下的。所以这个散列值是不能直接拿来⽤的。⽤之前还要先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“ (n - 1) & hash ”。（n代表数组⻓度）。这也就解释了 HashMap 的⻓度为什么是 2 的幂次⽅。\n\n> 我们⾸先可能会想到采⽤%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减⼀的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是length 是 2 的 n 次⽅；）。” 并且 采⽤⼆进制位操作 &，相对于%能够提⾼运算效率，这就解释了HashMap 的⻓度为什么是 2 的幂次⽅。\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"有哪些集合是线程不安全的？怎么解决呢？","url":"/posts/62981.html","content":"\n\n\n# 有哪些集合是线程不安全的？如何解决？\n\n> [【CSDN】集合类线程不安全如何解决](https://blog.csdn.net/weixin_45119323/article/details/109067942)\n\n## List|ArrayList\n```\npublic static void main(String[] args) {\n\n        List<String> list = new ArrayList<>();\n        for (int i = 1; i <=20 ; i++) {\n            new Thread(()->{\n                list.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(list);\n            },String.valueOf(i)).start();\n        }\n    }\n```\n多线程环境下并发操作ArrayList操作发生异常\n![](Snipaste_2023-04-27_16-44-50.jpg )\n\n### 解决ArrayList线程不安全\n- 使用Vector\n- 使用Collections.synchronizeList()\n- 使用CopyOnWriteArrayList()\n\n#### Vector\n![](Snipaste_2023-04-27_16-51-07.jpg)\n\nVector底层采用的是加锁的方式，加锁数据的一致性可以保证，但并发性会大大降低。\n\n![](Snipaste_2023-04-27_16-54-04.jpg)\n\n#### Collections.synchronizeList()\n\nCollection和Collections的区别:\n- Collection是一个接口，Set接口和List接口都继承自此接口\n- Collections是一个类，一个辅助工具类，可以使不安全的集合类变为安全的\n\n![](Snipaste_2023-04-27_16-58-04.jpg)\n![](Snipaste_2023-04-27_16-59-25.jpg)\n\n#### CopyOnWriteArrayList()\n\n> 如果是读多写少的情况，推荐使用CopyOnWriteArrayList；\n\nCopyOnWriteArrayList是JUC包下的一个类。写时复制基于读写分离的思想。\n\nCopyOnWrite的add方法，使用Lock来加锁，一次只允许一个线程进行写操作\n![](Snipaste_2023-04-27_17-04-11.jpg)\n![](Snipaste_2023-04-27_17-04-28.jpg)\n\nCopyOnWrite容器被称为写时复制的容器，往一个容器当中添加元素的时候，不直接往当前容器Object[] 添加，而是先将当前的容器Object[] 进行copy，复制出一个新的容器Object[] newElements，往新容器里添加元素，元素添加完成之后，将原容器的引用指向新的容器。\n这样做的好处是可以并发的读，而不需要加锁。\n\n## Set|HashSet\n\n![](Snipaste_2023-04-27_17-10-09.jpg)\n\n**HashSet底层实现**\n![](Snipaste_2023-04-27_17-11-01.jpg)\n\nHashMap以键值对储存数据，而HashSet中add方法只添加一个元素。\nvalue值是一个Object类型的常量，HashSet不关心value值。\n![](Snipaste_2023-04-27_17-12-57.jpg)\n![](Snipaste_2023-04-27_17-12-26.jpg)\n\n### 解决HashSet线程不安全\n\n```\n    public static void main(String[] args) {\n        Set<String> set=new HashSet<>();\n        for(int i=1;i<=40;i++){\n            new Thread(()->{\n                set.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(set);\n            },String.valueOf(i)).start();\n        }\n    }\n```\n\n#### Collections.synchronizeSet\n![](Snipaste_2023-04-27_17-17-49.jpg)\n\n#### CopyOnWriteHashSet\nJUC包下的一个类\n![](Snipaste_2023-04-27_17-20-25.jpg)\n\n## Map|HashMap\n![](Snipaste_2023-04-27_17-24-09.jpg)\n\n### 解决HashMap线程不安全\n\n#### HashTable\n![](Snipaste_2023-04-27_17-27-06.jpg)\n\n![](Snipaste_2023-04-27_17-29-12.jpg)\n\n#### Collections.synchronizedMap\n![](Snipaste_2023-04-27_17-31-15.jpg)\n\n#### ConcurrentHashMap\nJUC下的包\n![](Snipaste_2023-04-27_17-33-32.jpg)\n\n## 拓展知识点-JUC\n[JUC系列（一）| 什么是JUC？](https://juejin.cn/post/6997767449567313927)\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"比较HashSet、LinkedHashSet和TreeSet三者的异同","url":"/posts/18392.html","content":"# 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\n> [【CSDN】(第三点) HashSet LinkedHashSet 和 TreeSet 三者的对比](https://blog.csdn.net/JinYJ2014/article/details/122753667)\n\n\n1. HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类,**都能保证元素唯一，并且都不是线程安全的。**\n2. HashSet、LinkedHashSet 和 TreeSet 的主要区别在于**底层数据结构不同。**\n   1. HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。\n   2. LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。\n   3. TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。\n3. 底层数据结构不同又导致这三者的**应用场景不同**。\n   1. HashSet 用于不需要保证元素插入和取出顺序的场景\n   2. LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景\n   3. TreeSet 用于支持对元素自定义排序规则的场景。\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"说说List,Set,Map三者的区别？三者底层的数据结构？","url":"/posts/50957.html","content":"# 说说 List,Set,Map 三者的区别？三者底层的数据结构？\n\n- List：储存元素是有序的、可重复的。\n- Set：储存元素是无序的、不可重复的。\n- Map：使用键值对（key-value）储存，key是无序、不可重复的；value是无序、可重复的。\n\n## 数据结构\nList：\n- ArrayList：Object[] 数组\n- Vector：Object[] 数组\n- LinkedList: 双向链表(Jdk1.6之前为循环链表，Jdk1.7取消了循环)\n\nSet：\n- HashSet（无序、唯一）：基于HashMap实现，底层采用HashMap保存元素\n- LinkedHashSet：是HashSet的子类，内部通过LinkedHashMap实现，\n- TreeSet（有序、唯一）：红黑树（自平衡的排序二叉树）\n\nMap：\n- HashMap：Jdk1.8之前由数组+链表组成，数组是HashMap的主题，链表是为了解决哈希冲突而存在的（拉链法解决冲突）。Jdk1.8之后，当链表长度大于阈值（默认8）将链表转化红黑树，以减少搜索时间。\n- LinkedHashMap：继承自HashMap，底层仍基于拉链式散列结构即由数组和链表或红黑树组成。另外在基础结构之上增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表的相应操作，实现了访问顺序的相关逻辑。\n- HashTable：数组+链表组成，数组是HashTable的主体，链表则是为了解决哈希冲突而存在的。\n- TreeMap：红黑树(自平衡排序的二叉树)\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"关系型数据库和非关系型数据库区别？","url":"/posts/27108.html","content":"\n> 参考博客：[关系数据库和非关系数据库区别](https://worktile.com/kb/ask/31173.html)\n\n## 关系型数据库和非关系型数据库区别\n\n1. 数据一致性不同\n2. 数据储存方式不同\n3. 扩展方式不同\n4. 对事务的支持不同\n\n\n## 常见关系型数据库\n- Oracle\n- Sql Server\n- Mysql\n- Db2\n\n## 常见非关系型数据库\n- Redis\n- MongoDB\n- HBase\n- Neo4j\n\n\n\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"SpringBean的生命周期说一下","url":"/posts/44604.html","content":"\n> [一文读懂 Spring Bean 的生命周期](https://blog.csdn.net/riemann_/article/details/118500805)","categories":["整理归纳","面试问题解析汇总"]},{"title":"SpringBootApplication注解","url":"/posts/59082.html","content":"\n## @SpringBootApplication注解\n\n> [springbootapplication注解包括哪些注解_@SpringBootApplication 注解 详解](https://blog.csdn.net/weixin_39565332/article/details/111395141)\n\n---\n\n@SpringBootApplication注解源码\n```\n\n@Target({ElementType.TYPE})  //注解的作用域\n@Retention(RetentionPolicy.RUNTIME) //注解的生存周期\n@Documented //可以被文档化\n@Inherited  //注解用于标注一个父类的注解是否可以被子类继承\n@SpringBootConfiguration //声明为一个配置类 proxyBeanMethods是否开启bean代理，默认是true,从IOC容器中取；如果是false则每次获取都是一个新的实例 \n@EnableAutoConfiguration //开启自动配置\n@ComponentScan(\n    excludeFilters = {\n      @Filter(\n        type = FilterType.CUSTOM,\n        classes = {TypeExcludeFilter.class}),\n      @Filter(\n        type = FilterType.CUSTOM,\n        classes = {AutoConfigurationExcludeFilter.class})\n  }\n) //包扫描的规则\npublic @interface SpringBootApplication {\n    // ...\n}\n```\n\n### @Target \n自定义所修饰的注解作用范围\n\n+++ ElementType详解\n#### ElementType\n@Target(ElementType.ANNOTATION_TYPE)\n-  TYPE \n   -  用来描述类、接口(包括注解类型) 或enum声明 Class, interface\n-  FIELD\n   -  用来描述域 Field declaration\n-  METHOD\n   -  用来描述方法\n-  PARAMETER\n   -  用来描述参数\n-  CONSTRUCTOR\n   -  用来描述构造器\n-  LOCAL_VARIABLE\n   -  用来描述局部变量\n-  ANNOTATION_TYPE\n   -  声明类型\n-  PACKAGE\n   -  用来描述包\n-  TYPE_PARAMETER\n   -  用来标注类型参数\n-  TYPE_USE\n   -  标注任何类型名称\n-  MODULE\n-  RECORD_COMPONENT \n+++\n\n### @Retention\n定义所修饰的注解的生命周期\n\n+++ RetentionPolicy详解\n#### RetentionPolicy\n@Retention(RetentionPolicy.RUNTIME)\n- SOURCE\n  - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃。\n- CLASS\n  - 注解被保留到class文件，但jvm加载class文件时候被遗弃，默认的。\n- RUNTIME\n  - 注解被保存到class文件中，jvm加载class文件之后也存在。\n+++\n\n### @Documented\n用来标注生成javadoc的时候是否会被记录。\n### @Inherited\n子类会继承父类的被@Inherited修饰过的注解。\n\n### @SpringBootConfiguration\n- **标注这个类是一个配置类**\n- @Configuration注解的派生注解\n- 与@Configuration注解的功能一致\n- @SpringBootConfiguration是springboot的注解，而@Configuration是spring的注解\n\n#### @Configuration\n> [@SpringBootConfiguration 注解的作用](https://blog.csdn.net/ScorpC/article/details/104752740)\n>\n\n### @EnableAutoConfiguration\n> [SpringBoot之@EnableAutoConfiguration注解](https://blog.csdn.net/zxc123e/article/details/80222967)\n>\n\n开启自动配置\n\n### @ComponentScan\n- 默认扫描@SpringBootApplication所在类的同级包\n- 启动类所在的包高于控制器所在的包，的情况都可以被扫描到\n- 可以通过basePackages参数定义需要扫描的目录\n\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"SpringBoot和Spring的区别","url":"/posts/9789.html","content":"\n> [Spring和Spring Boot之间的区别](https://blog.csdn.net/mengxin_chen/article/details/116240326)\n\n**Spring和Spring Boot基于IOC AOP理念实现，Spring Boot集成了Spring。**\n\n\n## Spring框架\nSpring框架解决了企业级的开发的复杂性，它是一个容器框架，用于装java对象（Bean），使程序间的依赖关系交由容器统一管理，松耦合，提高了可测试性和维护效率，Spring主要为我们做了两件事，一省去了我们创建对象的操作，二声明了属性赋值。\n\n对于我来说，Spring框架就是提供了IOC容器、控制反转、依赖注入以及一些模块，简化了大量的代码，便捷了程序的开发，节省了开发时间，提高了效率。Spring框架为我们提供了全面的基础框架，但是Spring框架的配置是一项问题，使用一项第三方jar包的时候都需要配置相关的XML文件，有时候配置起来十分麻烦，降低了编程效率。编写基于ssm框架的项目需要配置Tomcat，把封装好的war包放到Tomcat容器运行。Spring可以接管Web层、业务层、dao层、持久层的组件，可以配置各种bean。\n\n总体而言，Spring框架就是为我们解决开发中的基础性问题，使我们开发者可以更加专注于应用程序的开发，并且Spring框架是轻量级框架，扩展性强，非侵入式框架，消耗的资源少，占用的空间小，运行和部署简单。\n\n## SrpingBoot框架\nSpring Boot是一个微服务框架，延续了Spring框架的核心思想IOC和AOP，简化了应用的开发和部署。\n\n在我看来Spring Boot框架是对Spring框架的补充，它消除了Spring框架配置XML的麻烦事，完善了Spring框架的开发环境，使我们可以更加高效的完成编程，并且为我们提供了 spring-boot-starter-web 依赖，这个依赖包含了Tomcat和springmvc等一系列的web依赖（无需部署war文件）。\n\n以前我们SpringMVC要配置properties文件的时候需要写大量的配置，现在用Spring Boot只需要导入相关依赖，然后写两句话就可以配置完Web程序，并且还提供了@Configuration来替代XML配置。\n\n## Spring 和 Spring Boot的最大的区别在于Spring Boot的自动装配原理\n我们使用Spring创建Web程序时需要导入几个Maven依赖，而Spring Boot只需要一个Maven依赖来创建Web程序，并且Spring Boot还把我们最常用的依赖都放到了一起，现在的我们只需要spring-boot-starter-web这一个依赖就可以完成一个简单的Web应用。\n\n以前用Spring的时候需要XML文件配置开启一些功能，现在Spring Boot不用XML配置了，只需要写一个配置类（@Configuration和继承对应的接口）就可以继续配置。\n\nSpring Boot会通过启动器开启自动装配功能以@EnableAutoConfiguration扫描在spring.factories中的配置，然后通过@XxxxautoConfiguration进行扫描和配置所需要的Bean，自动的扫描Spring\nBoot项目引入的Maven依赖，只有用到的才会被创建成Bean，然后放到IOC容器内。\n\n## 总结\nSpring Boot就是Spring的完善和扩展，就是为我们便捷开发，方便测试和部署，提高效率而诞生的框架技术。\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"SpringBoot支持哪些嵌入式web容器？","url":"/posts/24826.html","content":"\n> [Spring Boot支持哪些嵌入式Web容器？](https://blog.csdn.net/m0_51945027/article/details/117539357)\n> \n \nSpring Boot支持的嵌入式servlet容器有: Tomcat、Jetty、Undertow。\n ","categories":["整理归纳","面试问题解析汇总"]},{"title":"SpringBoot的自动配置是如何实现的?","url":"/posts/6677.html","content":"\n> [https://blog.csdn.net/h2503652646/article/details/107912486](https://blog.csdn.net/h2503652646/article/details/107912486)","categories":["整理归纳","面试问题解析汇总"]},{"title":"Spring中的bean的作用域有哪些?","url":"/posts/63647.html","content":"\n> [Spring 中 Bean 的作用域有哪些？](https://blog.csdn.net/chinachuang/article/details/120136275)","categories":["整理归纳","面试问题解析汇总"]},{"title":"Spring动态代理默认用哪一种","url":"/posts/21371.html","content":"\n> [spring的动态代理模式有几种?默认是那种?如何切换?](https://blog.csdn.net/moyanqiuyu/article/details/84305295)\n\nJDK动态代理,基于接口(默认代理模式)，CGLIB动态代理（若要使用需要进行配置）","categories":["整理归纳","面试问题解析汇总"]},{"title":"hibernate和mybatis区别","url":"/posts/64579.html","content":"\n工作中使用MyBatis居多,Hibernate了解不是特别多.\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"什么是SpringBootStarter?","url":"/posts/15195.html","content":"\n> [SpringBoot starter的理解与使用](https://blog.csdn.net/Jieur/article/details/122438549)\n>\n\n## 什么是SpringBoot starter机制？\n> SpringBoot中的starter是一种非常重要的机制(自动化配置)，能够抛弃以前繁杂的配置，将其统一集成进starter，应用者只需要在maven中引入starter依赖，SpringBoot就能自动扫描到要加载的信息并启动相应的默认配置。\n> \n>starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。SpringBoot会自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器。SpringBoot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。\n>\n>所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。","categories":["整理归纳","面试问题解析汇总"]},{"title":"什么是Spring框架?","url":"/posts/28206.html","content":"\n> [Spring的主要核心](https://blog.csdn.net/Saika_xy/article/details/87482474)\n\n## 什么是Spring?\nSpring是一个开源框架，为简化企业级应用开发而生。Spring可以使简单的JavaBean实现只有EJB（sun的JavaEE服务器端组件模型）才能实现的功能。\n\n## Spring的核心功能是?\n\n1. 控制反转（IOC）\n2. 面向切面编程（AOP）","categories":["整理归纳","面试问题解析汇总"]},{"title":"列举一些重要的Spring模块？","url":"/posts/34910.html","content":"\n> [spring框架有哪些主要模块?](https://blog.csdn.net/whoamnew/article/details/83622400)\n\n\n- [核心容器（Spring Core）](#核心容器spring-core)\n- [应用上下文（Spring Context）](#应用上下文spring-context)\n- [Spring面向切面编程（Spring AOP）](#spring面向切面编程spring-aop)\n- [JDBC和DAO模块（Spring DAO）](#jdbc和dao模块spring-dao)\n- [对象实体映射（Spring ORM）](#对象实体映射spring-orm)\n- [Web模块（Spring Web）](#web模块spring-web)\n- [MVC模块（SpringWebMVC）](#mvc模块springwebmvc)\n\n![](./列举一些重要的Spring模块？/Snipaste_2023-05-04_08-11-55.jpg)\n\n\n## 核心容器（Spring Core）  \n核心容器提供Spring框架的基础功能。Spring以bean的方式进行java应用的各大组件及关系的组织和管理。Spring使用BeanFactory来产生和管理bean,是工厂模式的实现。BeanFactory使用控制反转（IOC）模式来将应用的配置和依赖性规范与实际的应用程序代码分开。\n\n\n## 应用上下文（Spring Context）\n实现了ApplicationContext接口，Spring的上下文，拓展了核心容器，提供事件处理、国际化等功能。它还提供了一些企业级服务的功能，提供了JNDI、EJB、RMI的支持。\n\n## Spring面向切面编程（Spring AOP）\n提供切面支持，是个轻量级的容器。Spring管理的任何对象都支持AOP，SpringAOP模块基于Spring的应用程序中的对象提供了事务管理服务，通过使用SpringAOP，就可以将声明性事务管理集成在应用程序中。\n\n## JDBC和DAO模块（Spring DAO）\n提供对JDBC的支持，还提供了DAO的支持，提供事务支持。\n\nJDBC、DAO的抽象层，提供了有意义的异常层次结构实现，可用该结构来管理异常处理，和不同数据库提供商抛出的错误信息，异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。\n\n## 对象实体映射（Spring ORM）\nORM：Object Relational Mapping，指对象实体映射。Spring插入了若干个ORM框架，提供了ORM对象的关系工具，其中包括Hibernate，JDO和IBatisSQL Map等，所有这些都遵从Spring的通用事务和DAO异常层次结构。\n\n## Web模块（Spring Web）\n拓展了Spring上下文，提供Web应用上下文，对Web开发提供功能上的支持，如请求、表单、异常等。\n\n## MVC模块（SpringWebMVC）\nMVC框架是一个全功能的构建Web应用程序的MVC实现，通过策略接口，MVC框架编程高度可配置的，MVC容纳了大量视图技术，其中包括JSP，POI等，模型由JavaBean来构成，存放于m当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码，由c的事情。","categories":["整理归纳","面试问题解析汇总"]},{"title":"拦截器和过滤器了解么？","url":"/posts/48331.html","content":"\n> [过滤器 和 拦截器的 6个区别，别再傻傻分不清了](https://blog.csdn.net/xinzhifu1/article/details/106356958)","categories":["整理归纳","面试问题解析汇总"]},{"title":"说出使用SpringBoot的主要优点","url":"/posts/1453.html","content":"\n> [SpringBoot优势](https://zhuanlan.zhihu.com/p/337079078)\n\n\n- 通过简化配置可以快速搭建Spring应用程序。\n- 内嵌servlet容器，能够直接使用java的main方法启动，因此也不需要部署war包文件\n- 提供starter简化Maven配置。springboot提供了一系列的start pol用来简化maven依赖\n- 自动配置。根据项目的maven依赖POM配置，Spring boot可以自动配置SpringMVC等其它开源框架\n- 应用监控。springboot提供了actuator组件，只需要在配置中加入spring-boot-starter-actuator依赖，通过继承AbstractHealthIndicator这个抽象类，然后在doHealthCheck（）方法中检测服务健康的方法，就可以实现一个简单的监控\n","categories":["整理归纳","面试问题解析汇总"]},{"title":"谈谈自己对于SpringIoC和AOP的理解","url":"/posts/5393.html","content":"\n> [Spring框架：谈谈对IOC和AOP的理解](https://blog.csdn.net/weixin_48016395/article/details/123099446)\n\n","categories":["整理归纳","面试问题解析汇总"]}]